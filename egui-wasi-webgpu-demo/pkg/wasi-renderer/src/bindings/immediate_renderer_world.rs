// Generated by `wit-bindgen` 0.52.0. DO NOT EDIT!
// Options used:
//   * default-bindings-module: "crate::bindings::immediate_renderer_world"
#[allow(dead_code, clippy::all)]
pub mod local {
  pub mod immediate_renderer {

    #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
    pub mod types {
      #[used]
      #[doc(hidden)]
      static __FORCE_SECTION_REF: fn() =
      super::super::super::__link_custom_section_describing_imports;
      
      use super::super::super::_rt;
      wit_bindgen::rt::bitflags::bitflags! {
        #[derive(PartialEq, Eq, PartialOrd, Ord, Hash, Debug, Clone, Copy)]
        pub struct ModifierPressed: u8 {
          const LEFT = 1 << 0;
          const RIGHT = 1 << 1;
        }
      }
      #[repr(C)]
      #[derive(Clone, Copy)]
      pub struct ModifierOptions {
        pub ctrl: ModifierPressed,
        pub shift: ModifierPressed,
        pub alt: ModifierPressed,
        pub super_key: ModifierPressed,
      }
      impl ::core::fmt::Debug for ModifierOptions {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("ModifierOptions").field("ctrl", &self.ctrl).field("shift", &self.shift).field("alt", &self.alt).field("super-key", &self.super_key).finish()
        }
      }
      #[repr(C)]
      #[derive(Clone, Copy)]
      pub struct Location {
        pub x: f32,
        pub y: f32,
      }
      impl ::core::fmt::Debug for Location {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("Location").field("x", &self.x).field("y", &self.y).finish()
        }
      }
      #[repr(u8)]
      #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
      pub enum MouseButton {
        Left,
        Right,
        Middle,
        Back,
        Forward,
      }
      impl ::core::fmt::Debug for MouseButton {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            MouseButton::Left => {
              f.debug_tuple("MouseButton::Left").finish()
            }
            MouseButton::Right => {
              f.debug_tuple("MouseButton::Right").finish()
            }
            MouseButton::Middle => {
              f.debug_tuple("MouseButton::Middle").finish()
            }
            MouseButton::Back => {
              f.debug_tuple("MouseButton::Back").finish()
            }
            MouseButton::Forward => {
              f.debug_tuple("MouseButton::Forward").finish()
            }
          }
        }
      }

      impl MouseButton{
        #[doc(hidden)]
        pub unsafe fn _lift(val: u8) -> MouseButton{
          if !cfg!(debug_assertions) {
            return unsafe { ::core::mem::transmute(val) };
          }

          match val {
            0 => MouseButton::Left,
            1 => MouseButton::Right,
            2 => MouseButton::Middle,
            3 => MouseButton::Back,
            4 => MouseButton::Forward,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }

      #[derive(Clone, Copy)]
      pub enum Event {
        Modifiers(ModifierOptions),
        Pointer(Location),
        MouseDown(MouseButton),
        MouseUp(MouseButton),
      }
      impl ::core::fmt::Debug for Event {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            Event::Modifiers(e) => {
              f.debug_tuple("Event::Modifiers").field(e).finish()
            }
            Event::Pointer(e) => {
              f.debug_tuple("Event::Pointer").field(e).finish()
            }
            Event::MouseDown(e) => {
              f.debug_tuple("Event::MouseDown").field(e).finish()
            }
            Event::MouseUp(e) => {
              f.debug_tuple("Event::MouseUp").field(e).finish()
            }
          }
        }
      }
      #[derive(Clone)]
      pub enum UnhandleEvent {
        Event(Event),
        OpenWindow(_rt::String),
      }
      impl ::core::fmt::Debug for UnhandleEvent {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            UnhandleEvent::Event(e) => {
              f.debug_tuple("UnhandleEvent::Event").field(e).finish()
            }
            UnhandleEvent::OpenWindow(e) => {
              f.debug_tuple("UnhandleEvent::OpenWindow").field(e).finish()
            }
          }
        }
      }

    }

  }
  pub mod webgpu_runtime {

    #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
    pub mod surface {
      #[used]
      #[doc(hidden)]
      static __FORCE_SECTION_REF: fn() =
      super::super::super::__link_custom_section_describing_imports;
      
      use super::super::super::_rt;
      pub type GpuDevice = super::super::super::wasi::webgpu::webgpu::GpuDevice;
      pub type GpuCanvasContext = super::super::super::wasi::webgpu::webgpu::GpuCanvasContext;
      pub type GpuRenderPipeline = super::super::super::wasi::webgpu::webgpu::GpuRenderPipeline;
      pub type GpuBindGroupLayout = super::super::super::wasi::webgpu::webgpu::GpuBindGroupLayout;
      #[repr(C)]
      #[derive(Clone, Copy)]
      pub struct FrameSize {
        pub width: u32,
        pub height: u32,
      }
      impl ::core::fmt::Debug for FrameSize {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("FrameSize").field("width", &self.width).field("height", &self.height).finish()
        }
      }

      #[derive(Debug)]
      #[repr(transparent)]
      pub struct RenderContext{
        handle: _rt::Resource<RenderContext>,
      }

      impl RenderContext{
        #[doc(hidden)]
        pub unsafe fn from_handle(handle: u32) -> Self {
          Self {
            handle: unsafe { _rt::Resource::from_handle(handle) },
          }
        }

        #[doc(hidden)]
        pub fn take_handle(&self) -> u32 {
          _rt::Resource::take_handle(&self.handle)
        }

        #[doc(hidden)]
        pub fn handle(&self) -> u32 {
          _rt::Resource::handle(&self.handle)
        }
      }
      

      unsafe impl _rt::WasmResource for RenderContext{
        #[inline]
        unsafe fn drop(_handle: u32) {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "local:webgpu-runtime/surface")]
          unsafe extern "C" {
            #[link_name = "[resource-drop]render-context"]
            fn drop(_: i32, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn drop(_: i32, ) { unreachable!() }
          
          unsafe { drop(_handle as i32); }
        }
      }
      
      impl RenderContext {
        #[allow(unused_unsafe, clippy::all)]
        #[allow(async_fn_in_trait)]
        pub fn size(&self,) -> FrameSize{
          unsafe {

            #[repr(align(4))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 8]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 8]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "local:webgpu-runtime/surface")]
            unsafe extern "C" {
              #[link_name = "[method]render-context.size"]
              fn wit_import1(_: i32, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, ) { unreachable!() }
            wit_import1((self).handle() as i32, ptr0);
            let l2 = *ptr0.add(0).cast::<i32>();
            let l3 = *ptr0.add(4).cast::<i32>();
            let result4 = FrameSize{
              width: l2 as u32,
              height: l3 as u32,
            };
            result4
          }
        }
      }
      impl RenderContext {
        #[allow(unused_unsafe, clippy::all)]
        #[allow(async_fn_in_trait)]
        pub fn scale_factor(&self,) -> f32{
          unsafe {

            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "local:webgpu-runtime/surface")]
            unsafe extern "C" {
              #[link_name = "[method]render-context.scale-factor"]
              fn wit_import0(_: i32, ) -> f32;
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import0(_: i32, ) -> f32 { unreachable!() }
            let ret = wit_import0((self).handle() as i32);
            ret
          }
        }
      }
      impl RenderContext {
        #[allow(unused_unsafe, clippy::all)]
        #[allow(async_fn_in_trait)]
        pub fn request_set_size(&self,size: FrameSize,) -> (){
          unsafe {
            let FrameSize{ width:width0, height:height0, } = size;

            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "local:webgpu-runtime/surface")]
            unsafe extern "C" {
              #[link_name = "[method]render-context.request-set-size"]
              fn wit_import1(_: i32, _: i32, _: i32, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import1(_: i32, _: i32, _: i32, ) { unreachable!() }
            wit_import1((self).handle() as i32, _rt::as_i32(width0), _rt::as_i32(height0));
          }
        }
      }
      impl RenderContext {
        #[allow(unused_unsafe, clippy::all)]
        #[allow(async_fn_in_trait)]
        pub fn get_device(&self,) -> GpuDevice{
          unsafe {

            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "local:webgpu-runtime/surface")]
            unsafe extern "C" {
              #[link_name = "[method]render-context.get-device"]
              fn wit_import0(_: i32, ) -> i32;
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import0(_: i32, ) -> i32 { unreachable!() }
            let ret = wit_import0((self).handle() as i32);
            super::super::super::wasi::webgpu::webgpu::GpuDevice::from_handle(ret as u32)
          }
        }
      }
      impl RenderContext {
        #[allow(unused_unsafe, clippy::all)]
        #[allow(async_fn_in_trait)]
        pub fn get_canvas(&self,) -> GpuCanvasContext{
          unsafe {

            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "local:webgpu-runtime/surface")]
            unsafe extern "C" {
              #[link_name = "[method]render-context.get-canvas"]
              fn wit_import0(_: i32, ) -> i32;
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import0(_: i32, ) -> i32 { unreachable!() }
            let ret = wit_import0((self).handle() as i32);
            super::super::super::wasi::webgpu::webgpu::GpuCanvasContext::from_handle(ret as u32)
          }
        }
      }
      impl RenderContext {
        #[allow(unused_unsafe, clippy::all)]
        #[allow(async_fn_in_trait)]
        pub fn get_pipeline(&self,) -> GpuRenderPipeline{
          unsafe {

            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "local:webgpu-runtime/surface")]
            unsafe extern "C" {
              #[link_name = "[method]render-context.get-pipeline"]
              fn wit_import0(_: i32, ) -> i32;
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import0(_: i32, ) -> i32 { unreachable!() }
            let ret = wit_import0((self).handle() as i32);
            super::super::super::wasi::webgpu::webgpu::GpuRenderPipeline::from_handle(ret as u32)
          }
        }
      }
      impl RenderContext {
        #[allow(unused_unsafe, clippy::all)]
        #[allow(async_fn_in_trait)]
        pub fn get_uniform_layout(&self,) -> GpuBindGroupLayout{
          unsafe {

            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "local:webgpu-runtime/surface")]
            unsafe extern "C" {
              #[link_name = "[method]render-context.get-uniform-layout"]
              fn wit_import0(_: i32, ) -> i32;
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import0(_: i32, ) -> i32 { unreachable!() }
            let ret = wit_import0((self).handle() as i32);
            super::super::super::wasi::webgpu::webgpu::GpuBindGroupLayout::from_handle(ret as u32)
          }
        }
      }
      impl RenderContext {
        #[allow(unused_unsafe, clippy::all)]
        #[allow(async_fn_in_trait)]
        pub fn get_texture_layout(&self,) -> GpuBindGroupLayout{
          unsafe {

            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "local:webgpu-runtime/surface")]
            unsafe extern "C" {
              #[link_name = "[method]render-context.get-texture-layout"]
              fn wit_import0(_: i32, ) -> i32;
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import0(_: i32, ) -> i32 { unreachable!() }
            let ret = wit_import0((self).handle() as i32);
            super::super::super::wasi::webgpu::webgpu::GpuBindGroupLayout::from_handle(ret as u32)
          }
        }
      }

    }

  }
}
#[allow(dead_code, clippy::all)]
pub mod wasi {
  pub mod graphics_context {

    #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
    pub mod graphics_context {
      #[used]
      #[doc(hidden)]
      static __FORCE_SECTION_REF: fn() =
      super::super::super::__link_custom_section_describing_imports;
      
      use super::super::super::_rt;

      #[derive(Debug)]
      #[repr(transparent)]
      pub struct Context{
        handle: _rt::Resource<Context>,
      }

      impl Context{
        #[doc(hidden)]
        pub unsafe fn from_handle(handle: u32) -> Self {
          Self {
            handle: unsafe { _rt::Resource::from_handle(handle) },
          }
        }

        #[doc(hidden)]
        pub fn take_handle(&self) -> u32 {
          _rt::Resource::take_handle(&self.handle)
        }

        #[doc(hidden)]
        pub fn handle(&self) -> u32 {
          _rt::Resource::handle(&self.handle)
        }
      }
      

      unsafe impl _rt::WasmResource for Context{
        #[inline]
        unsafe fn drop(_handle: u32) {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:graphics-context/graphics-context@0.0.1")]
          unsafe extern "C" {
            #[link_name = "[resource-drop]context"]
            fn drop(_: i32, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn drop(_: i32, ) { unreachable!() }
          
          unsafe { drop(_handle as i32); }
        }
      }
      

      #[derive(Debug)]
      #[repr(transparent)]
      pub struct AbstractBuffer{
        handle: _rt::Resource<AbstractBuffer>,
      }

      impl AbstractBuffer{
        #[doc(hidden)]
        pub unsafe fn from_handle(handle: u32) -> Self {
          Self {
            handle: unsafe { _rt::Resource::from_handle(handle) },
          }
        }

        #[doc(hidden)]
        pub fn take_handle(&self) -> u32 {
          _rt::Resource::take_handle(&self.handle)
        }

        #[doc(hidden)]
        pub fn handle(&self) -> u32 {
          _rt::Resource::handle(&self.handle)
        }
      }
      

      unsafe impl _rt::WasmResource for AbstractBuffer{
        #[inline]
        unsafe fn drop(_handle: u32) {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:graphics-context/graphics-context@0.0.1")]
          unsafe extern "C" {
            #[link_name = "[resource-drop]abstract-buffer"]
            fn drop(_: i32, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn drop(_: i32, ) { unreachable!() }
          
          unsafe { drop(_handle as i32); }
        }
      }
      
      impl Context {
        #[allow(unused_unsafe, clippy::all)]
        #[allow(async_fn_in_trait)]
        pub fn new() -> Self{
          unsafe {

            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:graphics-context/graphics-context@0.0.1")]
            unsafe extern "C" {
              #[link_name = "[constructor]context"]
              fn wit_import0() -> i32;
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import0() -> i32 { unreachable!() }
            let ret = wit_import0();
            Context::from_handle(ret as u32)
          }
        }
      }
      impl Context {
        #[allow(unused_unsafe, clippy::all)]
        #[allow(async_fn_in_trait)]
        pub fn get_current_buffer(&self,) -> AbstractBuffer{
          unsafe {

            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:graphics-context/graphics-context@0.0.1")]
            unsafe extern "C" {
              #[link_name = "[method]context.get-current-buffer"]
              fn wit_import0(_: i32, ) -> i32;
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import0(_: i32, ) -> i32 { unreachable!() }
            let ret = wit_import0((self).handle() as i32);
            AbstractBuffer::from_handle(ret as u32)
          }
        }
      }
      impl Context {
        #[allow(unused_unsafe, clippy::all)]
        /// TODO: might want to remove this.
        #[allow(async_fn_in_trait)]
        pub fn present(&self,) -> (){
          unsafe {

            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:graphics-context/graphics-context@0.0.1")]
            unsafe extern "C" {
              #[link_name = "[method]context.present"]
              fn wit_import0(_: i32, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import0(_: i32, ) { unreachable!() }
            wit_import0((self).handle() as i32);
          }
        }
      }

    }

  }
  pub mod io {
    /// A poll API intended to let users wait for I/O events on multiple handles
    /// at once.
    #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
    pub mod poll {
      #[used]
      #[doc(hidden)]
      static __FORCE_SECTION_REF: fn() =
      super::super::super::__link_custom_section_describing_imports;
      
      use super::super::super::_rt;
      /// `pollable` represents a single I/O event which may be ready, or not.

      #[derive(Debug)]
      #[repr(transparent)]
      pub struct Pollable{
        handle: _rt::Resource<Pollable>,
      }

      impl Pollable{
        #[doc(hidden)]
        pub unsafe fn from_handle(handle: u32) -> Self {
          Self {
            handle: unsafe { _rt::Resource::from_handle(handle) },
          }
        }

        #[doc(hidden)]
        pub fn take_handle(&self) -> u32 {
          _rt::Resource::take_handle(&self.handle)
        }

        #[doc(hidden)]
        pub fn handle(&self) -> u32 {
          _rt::Resource::handle(&self.handle)
        }
      }
      

      unsafe impl _rt::WasmResource for Pollable{
        #[inline]
        unsafe fn drop(_handle: u32) {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:io/poll@0.2.9")]
          unsafe extern "C" {
            #[link_name = "[resource-drop]pollable"]
            fn drop(_: i32, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn drop(_: i32, ) { unreachable!() }
          
          unsafe { drop(_handle as i32); }
        }
      }
      
      impl Pollable {
        #[allow(unused_unsafe, clippy::all)]
        /// Return the readiness of a pollable. This function never blocks.
        ///
        /// Returns `true` when the pollable is ready, and `false` otherwise.
        #[allow(async_fn_in_trait)]
        pub fn ready(&self,) -> bool{
          unsafe {

            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:io/poll@0.2.9")]
            unsafe extern "C" {
              #[link_name = "[method]pollable.ready"]
              fn wit_import0(_: i32, ) -> i32;
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import0(_: i32, ) -> i32 { unreachable!() }
            let ret = wit_import0((self).handle() as i32);
            _rt::bool_lift(ret as u8)
          }
        }
      }
      impl Pollable {
        #[allow(unused_unsafe, clippy::all)]
        /// `block` returns immediately if the pollable is ready, and otherwise
        /// blocks until ready.
        ///
        /// This function is equivalent to calling `poll.poll` on a list
        /// containing only this pollable.
        #[allow(async_fn_in_trait)]
        pub fn block(&self,) -> (){
          unsafe {

            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:io/poll@0.2.9")]
            unsafe extern "C" {
              #[link_name = "[method]pollable.block"]
              fn wit_import0(_: i32, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import0(_: i32, ) { unreachable!() }
            wit_import0((self).handle() as i32);
          }
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Poll for completion on a set of pollables.
      ///
      /// This function takes a list of pollables, which identify I/O sources of
      /// interest, and waits until one or more of the events is ready for I/O.
      ///
      /// The result `list<u32>` contains one or more indices of handles in the
      /// argument list that is ready for I/O.
      ///
      /// This function traps if either:
      /// - the list is empty, or:
      /// - the list contains more elements than can be indexed with a `u32` value.
      ///
      /// A timeout can be implemented by adding a pollable from the
      /// wasi-clocks API to the list.
      ///
      /// This function does not return a `result`; polling in itself does not
      /// do any I/O so it doesn't fail. If any of the I/O sources identified by
      /// the pollables has an error, it is indicated by marking the source as
      /// being ready for I/O.
      #[allow(async_fn_in_trait)]
      pub fn poll(in_: &[&Pollable],) -> _rt::Vec::<u32>{
        unsafe {

          #[cfg_attr(target_pointer_width="64", repr(align(8)))]
          #[cfg_attr(target_pointer_width="32", repr(align(4)))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 2*::core::mem::size_of::<*const u8>()]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2*::core::mem::size_of::<*const u8>()]);
          let vec0 = in_;
          let len0 = vec0.len();
          let layout0 = _rt::alloc::Layout::from_size_align(vec0.len() * 4, 4).unwrap();
          let (result0, _cleanup0) = wit_bindgen::rt::Cleanup::new(layout0);for (i, e) in vec0.into_iter().enumerate() {
            let base = result0.add(i * 4);
            {
              *base.add(0).cast::<i32>() = (e).handle() as i32;
            }
          }
          let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:io/poll@0.2.9")]
          unsafe extern "C" {
            #[link_name = "poll"]
            fn wit_import2(_: *mut u8, _: usize, _: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn wit_import2(_: *mut u8, _: usize, _: *mut u8, ) { unreachable!() }
          wit_import2(result0, len0, ptr1);
          let l3 = *ptr1.add(0).cast::<*mut u8>();
          let l4 = *ptr1.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
          let len5 = l4;
          let result6 = <_ as From<_rt::Vec<_>>>::from(_rt::Vec::from_raw_parts(l3.cast(), len5, len5));
          result6
        }
      }

    }

  }
  pub mod webgpu {

    #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
    pub mod webgpu {
      #[used]
      #[doc(hidden)]
      static __FORCE_SECTION_REF: fn() =
      super::super::super::__link_custom_section_describing_imports;
      
      use super::super::super::_rt;
      pub type Pollable = super::super::super::wasi::io::poll::Pollable;
      pub type Context = super::super::super::wasi::graphics_context::graphics_context::Context;
      pub type AbstractBuffer = super::super::super::wasi::graphics_context::graphics_context::AbstractBuffer;

      #[derive(Debug)]
      #[repr(transparent)]
      pub struct GpuSupportedLimits{
        handle: _rt::Resource<GpuSupportedLimits>,
      }

      impl GpuSupportedLimits{
        #[doc(hidden)]
        pub unsafe fn from_handle(handle: u32) -> Self {
          Self {
            handle: unsafe { _rt::Resource::from_handle(handle) },
          }
        }

        #[doc(hidden)]
        pub fn take_handle(&self) -> u32 {
          _rt::Resource::take_handle(&self.handle)
        }

        #[doc(hidden)]
        pub fn handle(&self) -> u32 {
          _rt::Resource::handle(&self.handle)
        }
      }
      

      unsafe impl _rt::WasmResource for GpuSupportedLimits{
        #[inline]
        unsafe fn drop(_handle: u32) {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
          unsafe extern "C" {
            #[link_name = "[resource-drop]gpu-supported-limits"]
            fn drop(_: i32, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn drop(_: i32, ) { unreachable!() }
          
          unsafe { drop(_handle as i32); }
        }
      }
      

      #[derive(Debug)]
      #[repr(transparent)]
      pub struct GpuSupportedFeatures{
        handle: _rt::Resource<GpuSupportedFeatures>,
      }

      impl GpuSupportedFeatures{
        #[doc(hidden)]
        pub unsafe fn from_handle(handle: u32) -> Self {
          Self {
            handle: unsafe { _rt::Resource::from_handle(handle) },
          }
        }

        #[doc(hidden)]
        pub fn take_handle(&self) -> u32 {
          _rt::Resource::take_handle(&self.handle)
        }

        #[doc(hidden)]
        pub fn handle(&self) -> u32 {
          _rt::Resource::handle(&self.handle)
        }
      }
      

      unsafe impl _rt::WasmResource for GpuSupportedFeatures{
        #[inline]
        unsafe fn drop(_handle: u32) {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
          unsafe extern "C" {
            #[link_name = "[resource-drop]gpu-supported-features"]
            fn drop(_: i32, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn drop(_: i32, ) { unreachable!() }
          
          unsafe { drop(_handle as i32); }
        }
      }
      

      #[derive(Debug)]
      #[repr(transparent)]
      pub struct WgslLanguageFeatures{
        handle: _rt::Resource<WgslLanguageFeatures>,
      }

      impl WgslLanguageFeatures{
        #[doc(hidden)]
        pub unsafe fn from_handle(handle: u32) -> Self {
          Self {
            handle: unsafe { _rt::Resource::from_handle(handle) },
          }
        }

        #[doc(hidden)]
        pub fn take_handle(&self) -> u32 {
          _rt::Resource::take_handle(&self.handle)
        }

        #[doc(hidden)]
        pub fn handle(&self) -> u32 {
          _rt::Resource::handle(&self.handle)
        }
      }
      

      unsafe impl _rt::WasmResource for WgslLanguageFeatures{
        #[inline]
        unsafe fn drop(_handle: u32) {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
          unsafe extern "C" {
            #[link_name = "[resource-drop]wgsl-language-features"]
            fn drop(_: i32, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn drop(_: i32, ) { unreachable!() }
          
          unsafe { drop(_handle as i32); }
        }
      }
      

      #[derive(Debug)]
      #[repr(transparent)]
      pub struct GpuAdapterInfo{
        handle: _rt::Resource<GpuAdapterInfo>,
      }

      impl GpuAdapterInfo{
        #[doc(hidden)]
        pub unsafe fn from_handle(handle: u32) -> Self {
          Self {
            handle: unsafe { _rt::Resource::from_handle(handle) },
          }
        }

        #[doc(hidden)]
        pub fn take_handle(&self) -> u32 {
          _rt::Resource::take_handle(&self.handle)
        }

        #[doc(hidden)]
        pub fn handle(&self) -> u32 {
          _rt::Resource::handle(&self.handle)
        }
      }
      

      unsafe impl _rt::WasmResource for GpuAdapterInfo{
        #[inline]
        unsafe fn drop(_handle: u32) {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
          unsafe extern "C" {
            #[link_name = "[resource-drop]gpu-adapter-info"]
            fn drop(_: i32, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn drop(_: i32, ) { unreachable!() }
          
          unsafe { drop(_handle as i32); }
        }
      }
      

      #[derive(Debug)]
      #[repr(transparent)]
      pub struct Gpu{
        handle: _rt::Resource<Gpu>,
      }

      impl Gpu{
        #[doc(hidden)]
        pub unsafe fn from_handle(handle: u32) -> Self {
          Self {
            handle: unsafe { _rt::Resource::from_handle(handle) },
          }
        }

        #[doc(hidden)]
        pub fn take_handle(&self) -> u32 {
          _rt::Resource::take_handle(&self.handle)
        }

        #[doc(hidden)]
        pub fn handle(&self) -> u32 {
          _rt::Resource::handle(&self.handle)
        }
      }
      

      unsafe impl _rt::WasmResource for Gpu{
        #[inline]
        unsafe fn drop(_handle: u32) {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
          unsafe extern "C" {
            #[link_name = "[resource-drop]gpu"]
            fn drop(_: i32, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn drop(_: i32, ) { unreachable!() }
          
          unsafe { drop(_handle as i32); }
        }
      }
      
      #[repr(u8)]
      #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
      pub enum GpuPowerPreference {
        LowPower,
        HighPerformance,
      }
      impl ::core::fmt::Debug for GpuPowerPreference {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            GpuPowerPreference::LowPower => {
              f.debug_tuple("GpuPowerPreference::LowPower").finish()
            }
            GpuPowerPreference::HighPerformance => {
              f.debug_tuple("GpuPowerPreference::HighPerformance").finish()
            }
          }
        }
      }

      impl GpuPowerPreference{
        #[doc(hidden)]
        pub unsafe fn _lift(val: u8) -> GpuPowerPreference{
          if !cfg!(debug_assertions) {
            return unsafe { ::core::mem::transmute(val) };
          }

          match val {
            0 => GpuPowerPreference::LowPower,
            1 => GpuPowerPreference::HighPerformance,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }
      
      #[derive(Clone)]
      pub struct GpuRequestAdapterOptions {
        pub feature_level: Option<_rt::String>,
        pub power_preference: Option<GpuPowerPreference>,
        pub force_fallback_adapter: Option<bool>,
        pub xr_compatible: Option<bool>,
      }
      impl ::core::fmt::Debug for GpuRequestAdapterOptions {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("GpuRequestAdapterOptions").field("feature-level", &self.feature_level).field("power-preference", &self.power_preference).field("force-fallback-adapter", &self.force_fallback_adapter).field("xr-compatible", &self.xr_compatible).finish()
        }
      }

      #[derive(Debug)]
      #[repr(transparent)]
      pub struct GpuAdapter{
        handle: _rt::Resource<GpuAdapter>,
      }

      impl GpuAdapter{
        #[doc(hidden)]
        pub unsafe fn from_handle(handle: u32) -> Self {
          Self {
            handle: unsafe { _rt::Resource::from_handle(handle) },
          }
        }

        #[doc(hidden)]
        pub fn take_handle(&self) -> u32 {
          _rt::Resource::take_handle(&self.handle)
        }

        #[doc(hidden)]
        pub fn handle(&self) -> u32 {
          _rt::Resource::handle(&self.handle)
        }
      }
      

      unsafe impl _rt::WasmResource for GpuAdapter{
        #[inline]
        unsafe fn drop(_handle: u32) {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
          unsafe extern "C" {
            #[link_name = "[resource-drop]gpu-adapter"]
            fn drop(_: i32, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn drop(_: i32, ) { unreachable!() }
          
          unsafe { drop(_handle as i32); }
        }
      }
      

      #[derive(Debug)]
      #[repr(transparent)]
      pub struct RecordOptionGpuSize64{
        handle: _rt::Resource<RecordOptionGpuSize64>,
      }

      impl RecordOptionGpuSize64{
        #[doc(hidden)]
        pub unsafe fn from_handle(handle: u32) -> Self {
          Self {
            handle: unsafe { _rt::Resource::from_handle(handle) },
          }
        }

        #[doc(hidden)]
        pub fn take_handle(&self) -> u32 {
          _rt::Resource::take_handle(&self.handle)
        }

        #[doc(hidden)]
        pub fn handle(&self) -> u32 {
          _rt::Resource::handle(&self.handle)
        }
      }
      

      unsafe impl _rt::WasmResource for RecordOptionGpuSize64{
        #[inline]
        unsafe fn drop(_handle: u32) {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
          unsafe extern "C" {
            #[link_name = "[resource-drop]record-option-gpu-size64"]
            fn drop(_: i32, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn drop(_: i32, ) { unreachable!() }
          
          unsafe { drop(_handle as i32); }
        }
      }
      
      #[repr(u8)]
      #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
      pub enum GpuFeatureName {
        DepthClipControl,
        Depth32floatStencil8,
        TextureCompressionBc,
        TextureCompressionBcSliced3d,
        TextureCompressionEtc2,
        TextureCompressionAstc,
        TextureCompressionAstcSliced3d,
        TimestampQuery,
        IndirectFirstInstance,
        ShaderF16,
        Rg11b10ufloatRenderable,
        Bgra8unormStorage,
        Float32Filterable,
        Float32Blendable,
        ClipDistances,
        DualSourceBlending,
        Subgroups,
      }
      impl ::core::fmt::Debug for GpuFeatureName {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            GpuFeatureName::DepthClipControl => {
              f.debug_tuple("GpuFeatureName::DepthClipControl").finish()
            }
            GpuFeatureName::Depth32floatStencil8 => {
              f.debug_tuple("GpuFeatureName::Depth32floatStencil8").finish()
            }
            GpuFeatureName::TextureCompressionBc => {
              f.debug_tuple("GpuFeatureName::TextureCompressionBc").finish()
            }
            GpuFeatureName::TextureCompressionBcSliced3d => {
              f.debug_tuple("GpuFeatureName::TextureCompressionBcSliced3d").finish()
            }
            GpuFeatureName::TextureCompressionEtc2 => {
              f.debug_tuple("GpuFeatureName::TextureCompressionEtc2").finish()
            }
            GpuFeatureName::TextureCompressionAstc => {
              f.debug_tuple("GpuFeatureName::TextureCompressionAstc").finish()
            }
            GpuFeatureName::TextureCompressionAstcSliced3d => {
              f.debug_tuple("GpuFeatureName::TextureCompressionAstcSliced3d").finish()
            }
            GpuFeatureName::TimestampQuery => {
              f.debug_tuple("GpuFeatureName::TimestampQuery").finish()
            }
            GpuFeatureName::IndirectFirstInstance => {
              f.debug_tuple("GpuFeatureName::IndirectFirstInstance").finish()
            }
            GpuFeatureName::ShaderF16 => {
              f.debug_tuple("GpuFeatureName::ShaderF16").finish()
            }
            GpuFeatureName::Rg11b10ufloatRenderable => {
              f.debug_tuple("GpuFeatureName::Rg11b10ufloatRenderable").finish()
            }
            GpuFeatureName::Bgra8unormStorage => {
              f.debug_tuple("GpuFeatureName::Bgra8unormStorage").finish()
            }
            GpuFeatureName::Float32Filterable => {
              f.debug_tuple("GpuFeatureName::Float32Filterable").finish()
            }
            GpuFeatureName::Float32Blendable => {
              f.debug_tuple("GpuFeatureName::Float32Blendable").finish()
            }
            GpuFeatureName::ClipDistances => {
              f.debug_tuple("GpuFeatureName::ClipDistances").finish()
            }
            GpuFeatureName::DualSourceBlending => {
              f.debug_tuple("GpuFeatureName::DualSourceBlending").finish()
            }
            GpuFeatureName::Subgroups => {
              f.debug_tuple("GpuFeatureName::Subgroups").finish()
            }
          }
        }
      }

      impl GpuFeatureName{
        #[doc(hidden)]
        pub unsafe fn _lift(val: u8) -> GpuFeatureName{
          if !cfg!(debug_assertions) {
            return unsafe { ::core::mem::transmute(val) };
          }

          match val {
            0 => GpuFeatureName::DepthClipControl,
            1 => GpuFeatureName::Depth32floatStencil8,
            2 => GpuFeatureName::TextureCompressionBc,
            3 => GpuFeatureName::TextureCompressionBcSliced3d,
            4 => GpuFeatureName::TextureCompressionEtc2,
            5 => GpuFeatureName::TextureCompressionAstc,
            6 => GpuFeatureName::TextureCompressionAstcSliced3d,
            7 => GpuFeatureName::TimestampQuery,
            8 => GpuFeatureName::IndirectFirstInstance,
            9 => GpuFeatureName::ShaderF16,
            10 => GpuFeatureName::Rg11b10ufloatRenderable,
            11 => GpuFeatureName::Bgra8unormStorage,
            12 => GpuFeatureName::Float32Filterable,
            13 => GpuFeatureName::Float32Blendable,
            14 => GpuFeatureName::ClipDistances,
            15 => GpuFeatureName::DualSourceBlending,
            16 => GpuFeatureName::Subgroups,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }
      

      #[derive(Debug)]
      #[repr(transparent)]
      pub struct GpuDevice{
        handle: _rt::Resource<GpuDevice>,
      }

      impl GpuDevice{
        #[doc(hidden)]
        pub unsafe fn from_handle(handle: u32) -> Self {
          Self {
            handle: unsafe { _rt::Resource::from_handle(handle) },
          }
        }

        #[doc(hidden)]
        pub fn take_handle(&self) -> u32 {
          _rt::Resource::take_handle(&self.handle)
        }

        #[doc(hidden)]
        pub fn handle(&self) -> u32 {
          _rt::Resource::handle(&self.handle)
        }
      }
      

      unsafe impl _rt::WasmResource for GpuDevice{
        #[inline]
        unsafe fn drop(_handle: u32) {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
          unsafe extern "C" {
            #[link_name = "[resource-drop]gpu-device"]
            fn drop(_: i32, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn drop(_: i32, ) { unreachable!() }
          
          unsafe { drop(_handle as i32); }
        }
      }
      

      #[derive(Debug)]
      #[repr(transparent)]
      pub struct GpuBuffer{
        handle: _rt::Resource<GpuBuffer>,
      }

      impl GpuBuffer{
        #[doc(hidden)]
        pub unsafe fn from_handle(handle: u32) -> Self {
          Self {
            handle: unsafe { _rt::Resource::from_handle(handle) },
          }
        }

        #[doc(hidden)]
        pub fn take_handle(&self) -> u32 {
          _rt::Resource::take_handle(&self.handle)
        }

        #[doc(hidden)]
        pub fn handle(&self) -> u32 {
          _rt::Resource::handle(&self.handle)
        }
      }
      

      unsafe impl _rt::WasmResource for GpuBuffer{
        #[inline]
        unsafe fn drop(_handle: u32) {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
          unsafe extern "C" {
            #[link_name = "[resource-drop]gpu-buffer"]
            fn drop(_: i32, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn drop(_: i32, ) { unreachable!() }
          
          unsafe { drop(_handle as i32); }
        }
      }
      
      #[repr(u8)]
      #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
      pub enum GpuBufferMapState {
        Unmapped,
        Pending,
        Mapped,
      }
      impl ::core::fmt::Debug for GpuBufferMapState {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            GpuBufferMapState::Unmapped => {
              f.debug_tuple("GpuBufferMapState::Unmapped").finish()
            }
            GpuBufferMapState::Pending => {
              f.debug_tuple("GpuBufferMapState::Pending").finish()
            }
            GpuBufferMapState::Mapped => {
              f.debug_tuple("GpuBufferMapState::Mapped").finish()
            }
          }
        }
      }

      impl GpuBufferMapState{
        #[doc(hidden)]
        pub unsafe fn _lift(val: u8) -> GpuBufferMapState{
          if !cfg!(debug_assertions) {
            return unsafe { ::core::mem::transmute(val) };
          }

          match val {
            0 => GpuBufferMapState::Unmapped,
            1 => GpuBufferMapState::Pending,
            2 => GpuBufferMapState::Mapped,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }
      
      pub type GpuBufferUsageFlags = u32;

      #[derive(Debug)]
      #[repr(transparent)]
      pub struct GpuBufferUsage{
        handle: _rt::Resource<GpuBufferUsage>,
      }

      impl GpuBufferUsage{
        #[doc(hidden)]
        pub unsafe fn from_handle(handle: u32) -> Self {
          Self {
            handle: unsafe { _rt::Resource::from_handle(handle) },
          }
        }

        #[doc(hidden)]
        pub fn take_handle(&self) -> u32 {
          _rt::Resource::take_handle(&self.handle)
        }

        #[doc(hidden)]
        pub fn handle(&self) -> u32 {
          _rt::Resource::handle(&self.handle)
        }
      }
      

      unsafe impl _rt::WasmResource for GpuBufferUsage{
        #[inline]
        unsafe fn drop(_handle: u32) {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
          unsafe extern "C" {
            #[link_name = "[resource-drop]gpu-buffer-usage"]
            fn drop(_: i32, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn drop(_: i32, ) { unreachable!() }
          
          unsafe { drop(_handle as i32); }
        }
      }
      
      pub type GpuMapModeFlags = u32;

      #[derive(Debug)]
      #[repr(transparent)]
      pub struct GpuMapMode{
        handle: _rt::Resource<GpuMapMode>,
      }

      impl GpuMapMode{
        #[doc(hidden)]
        pub unsafe fn from_handle(handle: u32) -> Self {
          Self {
            handle: unsafe { _rt::Resource::from_handle(handle) },
          }
        }

        #[doc(hidden)]
        pub fn take_handle(&self) -> u32 {
          _rt::Resource::take_handle(&self.handle)
        }

        #[doc(hidden)]
        pub fn handle(&self) -> u32 {
          _rt::Resource::handle(&self.handle)
        }
      }
      

      unsafe impl _rt::WasmResource for GpuMapMode{
        #[inline]
        unsafe fn drop(_handle: u32) {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
          unsafe extern "C" {
            #[link_name = "[resource-drop]gpu-map-mode"]
            fn drop(_: i32, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn drop(_: i32, ) { unreachable!() }
          
          unsafe { drop(_handle as i32); }
        }
      }
      

      #[derive(Debug)]
      #[repr(transparent)]
      pub struct GpuTexture{
        handle: _rt::Resource<GpuTexture>,
      }

      impl GpuTexture{
        #[doc(hidden)]
        pub unsafe fn from_handle(handle: u32) -> Self {
          Self {
            handle: unsafe { _rt::Resource::from_handle(handle) },
          }
        }

        #[doc(hidden)]
        pub fn take_handle(&self) -> u32 {
          _rt::Resource::take_handle(&self.handle)
        }

        #[doc(hidden)]
        pub fn handle(&self) -> u32 {
          _rt::Resource::handle(&self.handle)
        }
      }
      

      unsafe impl _rt::WasmResource for GpuTexture{
        #[inline]
        unsafe fn drop(_handle: u32) {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
          unsafe extern "C" {
            #[link_name = "[resource-drop]gpu-texture"]
            fn drop(_: i32, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn drop(_: i32, ) { unreachable!() }
          
          unsafe { drop(_handle as i32); }
        }
      }
      
      #[repr(u8)]
      #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
      pub enum GpuTextureDimension {
        D1,
        D2,
        D3,
      }
      impl ::core::fmt::Debug for GpuTextureDimension {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            GpuTextureDimension::D1 => {
              f.debug_tuple("GpuTextureDimension::D1").finish()
            }
            GpuTextureDimension::D2 => {
              f.debug_tuple("GpuTextureDimension::D2").finish()
            }
            GpuTextureDimension::D3 => {
              f.debug_tuple("GpuTextureDimension::D3").finish()
            }
          }
        }
      }

      impl GpuTextureDimension{
        #[doc(hidden)]
        pub unsafe fn _lift(val: u8) -> GpuTextureDimension{
          if !cfg!(debug_assertions) {
            return unsafe { ::core::mem::transmute(val) };
          }

          match val {
            0 => GpuTextureDimension::D1,
            1 => GpuTextureDimension::D2,
            2 => GpuTextureDimension::D3,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }
      
      pub type GpuTextureUsageFlags = u32;

      #[derive(Debug)]
      #[repr(transparent)]
      pub struct GpuTextureUsage{
        handle: _rt::Resource<GpuTextureUsage>,
      }

      impl GpuTextureUsage{
        #[doc(hidden)]
        pub unsafe fn from_handle(handle: u32) -> Self {
          Self {
            handle: unsafe { _rt::Resource::from_handle(handle) },
          }
        }

        #[doc(hidden)]
        pub fn take_handle(&self) -> u32 {
          _rt::Resource::take_handle(&self.handle)
        }

        #[doc(hidden)]
        pub fn handle(&self) -> u32 {
          _rt::Resource::handle(&self.handle)
        }
      }
      

      unsafe impl _rt::WasmResource for GpuTextureUsage{
        #[inline]
        unsafe fn drop(_handle: u32) {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
          unsafe extern "C" {
            #[link_name = "[resource-drop]gpu-texture-usage"]
            fn drop(_: i32, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn drop(_: i32, ) { unreachable!() }
          
          unsafe { drop(_handle as i32); }
        }
      }
      

      #[derive(Debug)]
      #[repr(transparent)]
      pub struct GpuTextureView{
        handle: _rt::Resource<GpuTextureView>,
      }

      impl GpuTextureView{
        #[doc(hidden)]
        pub unsafe fn from_handle(handle: u32) -> Self {
          Self {
            handle: unsafe { _rt::Resource::from_handle(handle) },
          }
        }

        #[doc(hidden)]
        pub fn take_handle(&self) -> u32 {
          _rt::Resource::take_handle(&self.handle)
        }

        #[doc(hidden)]
        pub fn handle(&self) -> u32 {
          _rt::Resource::handle(&self.handle)
        }
      }
      

      unsafe impl _rt::WasmResource for GpuTextureView{
        #[inline]
        unsafe fn drop(_handle: u32) {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
          unsafe extern "C" {
            #[link_name = "[resource-drop]gpu-texture-view"]
            fn drop(_: i32, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn drop(_: i32, ) { unreachable!() }
          
          unsafe { drop(_handle as i32); }
        }
      }
      
      #[repr(u8)]
      #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
      pub enum GpuTextureViewDimension {
        D1,
        D2,
        D2Array,
        Cube,
        CubeArray,
        D3,
      }
      impl ::core::fmt::Debug for GpuTextureViewDimension {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            GpuTextureViewDimension::D1 => {
              f.debug_tuple("GpuTextureViewDimension::D1").finish()
            }
            GpuTextureViewDimension::D2 => {
              f.debug_tuple("GpuTextureViewDimension::D2").finish()
            }
            GpuTextureViewDimension::D2Array => {
              f.debug_tuple("GpuTextureViewDimension::D2Array").finish()
            }
            GpuTextureViewDimension::Cube => {
              f.debug_tuple("GpuTextureViewDimension::Cube").finish()
            }
            GpuTextureViewDimension::CubeArray => {
              f.debug_tuple("GpuTextureViewDimension::CubeArray").finish()
            }
            GpuTextureViewDimension::D3 => {
              f.debug_tuple("GpuTextureViewDimension::D3").finish()
            }
          }
        }
      }

      impl GpuTextureViewDimension{
        #[doc(hidden)]
        pub unsafe fn _lift(val: u8) -> GpuTextureViewDimension{
          if !cfg!(debug_assertions) {
            return unsafe { ::core::mem::transmute(val) };
          }

          match val {
            0 => GpuTextureViewDimension::D1,
            1 => GpuTextureViewDimension::D2,
            2 => GpuTextureViewDimension::D2Array,
            3 => GpuTextureViewDimension::Cube,
            4 => GpuTextureViewDimension::CubeArray,
            5 => GpuTextureViewDimension::D3,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }
      
      #[repr(u8)]
      #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
      pub enum GpuTextureAspect {
        All,
        StencilOnly,
        DepthOnly,
      }
      impl ::core::fmt::Debug for GpuTextureAspect {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            GpuTextureAspect::All => {
              f.debug_tuple("GpuTextureAspect::All").finish()
            }
            GpuTextureAspect::StencilOnly => {
              f.debug_tuple("GpuTextureAspect::StencilOnly").finish()
            }
            GpuTextureAspect::DepthOnly => {
              f.debug_tuple("GpuTextureAspect::DepthOnly").finish()
            }
          }
        }
      }

      impl GpuTextureAspect{
        #[doc(hidden)]
        pub unsafe fn _lift(val: u8) -> GpuTextureAspect{
          if !cfg!(debug_assertions) {
            return unsafe { ::core::mem::transmute(val) };
          }

          match val {
            0 => GpuTextureAspect::All,
            1 => GpuTextureAspect::StencilOnly,
            2 => GpuTextureAspect::DepthOnly,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }
      
      #[repr(u8)]
      #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
      pub enum GpuTextureFormat {
        R8unorm,
        R8snorm,
        R8uint,
        R8sint,
        R16uint,
        R16sint,
        R16float,
        Rg8unorm,
        Rg8snorm,
        Rg8uint,
        Rg8sint,
        R32uint,
        R32sint,
        R32float,
        Rg16uint,
        Rg16sint,
        Rg16float,
        Rgba8unorm,
        Rgba8unormSrgb,
        Rgba8snorm,
        Rgba8uint,
        Rgba8sint,
        Bgra8unorm,
        Bgra8unormSrgb,
        Rgb9e5ufloat,
        Rgb10a2uint,
        Rgb10a2unorm,
        Rg11b10ufloat,
        Rg32uint,
        Rg32sint,
        Rg32float,
        Rgba16uint,
        Rgba16sint,
        Rgba16float,
        Rgba32uint,
        Rgba32sint,
        Rgba32float,
        Stencil8,
        Depth16unorm,
        Depth24plus,
        Depth24plusStencil8,
        Depth32float,
        Depth32floatStencil8,
        Bc1RgbaUnorm,
        Bc1RgbaUnormSrgb,
        Bc2RgbaUnorm,
        Bc2RgbaUnormSrgb,
        Bc3RgbaUnorm,
        Bc3RgbaUnormSrgb,
        Bc4RUnorm,
        Bc4RSnorm,
        Bc5RgUnorm,
        Bc5RgSnorm,
        Bc6hRgbUfloat,
        Bc6hRgbFloat,
        Bc7RgbaUnorm,
        Bc7RgbaUnormSrgb,
        Etc2Rgb8unorm,
        Etc2Rgb8unormSrgb,
        Etc2Rgb8a1unorm,
        Etc2Rgb8a1unormSrgb,
        Etc2Rgba8unorm,
        Etc2Rgba8unormSrgb,
        EacR11unorm,
        EacR11snorm,
        EacRg11unorm,
        EacRg11snorm,
        Astc4x4Unorm,
        Astc4x4UnormSrgb,
        Astc5x4Unorm,
        Astc5x4UnormSrgb,
        Astc5x5Unorm,
        Astc5x5UnormSrgb,
        Astc6x5Unorm,
        Astc6x5UnormSrgb,
        Astc6x6Unorm,
        Astc6x6UnormSrgb,
        Astc8x5Unorm,
        Astc8x5UnormSrgb,
        Astc8x6Unorm,
        Astc8x6UnormSrgb,
        Astc8x8Unorm,
        Astc8x8UnormSrgb,
        Astc10x5Unorm,
        Astc10x5UnormSrgb,
        Astc10x6Unorm,
        Astc10x6UnormSrgb,
        Astc10x8Unorm,
        Astc10x8UnormSrgb,
        Astc10x10Unorm,
        Astc10x10UnormSrgb,
        Astc12x10Unorm,
        Astc12x10UnormSrgb,
        Astc12x12Unorm,
        Astc12x12UnormSrgb,
      }
      impl ::core::fmt::Debug for GpuTextureFormat {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            GpuTextureFormat::R8unorm => {
              f.debug_tuple("GpuTextureFormat::R8unorm").finish()
            }
            GpuTextureFormat::R8snorm => {
              f.debug_tuple("GpuTextureFormat::R8snorm").finish()
            }
            GpuTextureFormat::R8uint => {
              f.debug_tuple("GpuTextureFormat::R8uint").finish()
            }
            GpuTextureFormat::R8sint => {
              f.debug_tuple("GpuTextureFormat::R8sint").finish()
            }
            GpuTextureFormat::R16uint => {
              f.debug_tuple("GpuTextureFormat::R16uint").finish()
            }
            GpuTextureFormat::R16sint => {
              f.debug_tuple("GpuTextureFormat::R16sint").finish()
            }
            GpuTextureFormat::R16float => {
              f.debug_tuple("GpuTextureFormat::R16float").finish()
            }
            GpuTextureFormat::Rg8unorm => {
              f.debug_tuple("GpuTextureFormat::Rg8unorm").finish()
            }
            GpuTextureFormat::Rg8snorm => {
              f.debug_tuple("GpuTextureFormat::Rg8snorm").finish()
            }
            GpuTextureFormat::Rg8uint => {
              f.debug_tuple("GpuTextureFormat::Rg8uint").finish()
            }
            GpuTextureFormat::Rg8sint => {
              f.debug_tuple("GpuTextureFormat::Rg8sint").finish()
            }
            GpuTextureFormat::R32uint => {
              f.debug_tuple("GpuTextureFormat::R32uint").finish()
            }
            GpuTextureFormat::R32sint => {
              f.debug_tuple("GpuTextureFormat::R32sint").finish()
            }
            GpuTextureFormat::R32float => {
              f.debug_tuple("GpuTextureFormat::R32float").finish()
            }
            GpuTextureFormat::Rg16uint => {
              f.debug_tuple("GpuTextureFormat::Rg16uint").finish()
            }
            GpuTextureFormat::Rg16sint => {
              f.debug_tuple("GpuTextureFormat::Rg16sint").finish()
            }
            GpuTextureFormat::Rg16float => {
              f.debug_tuple("GpuTextureFormat::Rg16float").finish()
            }
            GpuTextureFormat::Rgba8unorm => {
              f.debug_tuple("GpuTextureFormat::Rgba8unorm").finish()
            }
            GpuTextureFormat::Rgba8unormSrgb => {
              f.debug_tuple("GpuTextureFormat::Rgba8unormSrgb").finish()
            }
            GpuTextureFormat::Rgba8snorm => {
              f.debug_tuple("GpuTextureFormat::Rgba8snorm").finish()
            }
            GpuTextureFormat::Rgba8uint => {
              f.debug_tuple("GpuTextureFormat::Rgba8uint").finish()
            }
            GpuTextureFormat::Rgba8sint => {
              f.debug_tuple("GpuTextureFormat::Rgba8sint").finish()
            }
            GpuTextureFormat::Bgra8unorm => {
              f.debug_tuple("GpuTextureFormat::Bgra8unorm").finish()
            }
            GpuTextureFormat::Bgra8unormSrgb => {
              f.debug_tuple("GpuTextureFormat::Bgra8unormSrgb").finish()
            }
            GpuTextureFormat::Rgb9e5ufloat => {
              f.debug_tuple("GpuTextureFormat::Rgb9e5ufloat").finish()
            }
            GpuTextureFormat::Rgb10a2uint => {
              f.debug_tuple("GpuTextureFormat::Rgb10a2uint").finish()
            }
            GpuTextureFormat::Rgb10a2unorm => {
              f.debug_tuple("GpuTextureFormat::Rgb10a2unorm").finish()
            }
            GpuTextureFormat::Rg11b10ufloat => {
              f.debug_tuple("GpuTextureFormat::Rg11b10ufloat").finish()
            }
            GpuTextureFormat::Rg32uint => {
              f.debug_tuple("GpuTextureFormat::Rg32uint").finish()
            }
            GpuTextureFormat::Rg32sint => {
              f.debug_tuple("GpuTextureFormat::Rg32sint").finish()
            }
            GpuTextureFormat::Rg32float => {
              f.debug_tuple("GpuTextureFormat::Rg32float").finish()
            }
            GpuTextureFormat::Rgba16uint => {
              f.debug_tuple("GpuTextureFormat::Rgba16uint").finish()
            }
            GpuTextureFormat::Rgba16sint => {
              f.debug_tuple("GpuTextureFormat::Rgba16sint").finish()
            }
            GpuTextureFormat::Rgba16float => {
              f.debug_tuple("GpuTextureFormat::Rgba16float").finish()
            }
            GpuTextureFormat::Rgba32uint => {
              f.debug_tuple("GpuTextureFormat::Rgba32uint").finish()
            }
            GpuTextureFormat::Rgba32sint => {
              f.debug_tuple("GpuTextureFormat::Rgba32sint").finish()
            }
            GpuTextureFormat::Rgba32float => {
              f.debug_tuple("GpuTextureFormat::Rgba32float").finish()
            }
            GpuTextureFormat::Stencil8 => {
              f.debug_tuple("GpuTextureFormat::Stencil8").finish()
            }
            GpuTextureFormat::Depth16unorm => {
              f.debug_tuple("GpuTextureFormat::Depth16unorm").finish()
            }
            GpuTextureFormat::Depth24plus => {
              f.debug_tuple("GpuTextureFormat::Depth24plus").finish()
            }
            GpuTextureFormat::Depth24plusStencil8 => {
              f.debug_tuple("GpuTextureFormat::Depth24plusStencil8").finish()
            }
            GpuTextureFormat::Depth32float => {
              f.debug_tuple("GpuTextureFormat::Depth32float").finish()
            }
            GpuTextureFormat::Depth32floatStencil8 => {
              f.debug_tuple("GpuTextureFormat::Depth32floatStencil8").finish()
            }
            GpuTextureFormat::Bc1RgbaUnorm => {
              f.debug_tuple("GpuTextureFormat::Bc1RgbaUnorm").finish()
            }
            GpuTextureFormat::Bc1RgbaUnormSrgb => {
              f.debug_tuple("GpuTextureFormat::Bc1RgbaUnormSrgb").finish()
            }
            GpuTextureFormat::Bc2RgbaUnorm => {
              f.debug_tuple("GpuTextureFormat::Bc2RgbaUnorm").finish()
            }
            GpuTextureFormat::Bc2RgbaUnormSrgb => {
              f.debug_tuple("GpuTextureFormat::Bc2RgbaUnormSrgb").finish()
            }
            GpuTextureFormat::Bc3RgbaUnorm => {
              f.debug_tuple("GpuTextureFormat::Bc3RgbaUnorm").finish()
            }
            GpuTextureFormat::Bc3RgbaUnormSrgb => {
              f.debug_tuple("GpuTextureFormat::Bc3RgbaUnormSrgb").finish()
            }
            GpuTextureFormat::Bc4RUnorm => {
              f.debug_tuple("GpuTextureFormat::Bc4RUnorm").finish()
            }
            GpuTextureFormat::Bc4RSnorm => {
              f.debug_tuple("GpuTextureFormat::Bc4RSnorm").finish()
            }
            GpuTextureFormat::Bc5RgUnorm => {
              f.debug_tuple("GpuTextureFormat::Bc5RgUnorm").finish()
            }
            GpuTextureFormat::Bc5RgSnorm => {
              f.debug_tuple("GpuTextureFormat::Bc5RgSnorm").finish()
            }
            GpuTextureFormat::Bc6hRgbUfloat => {
              f.debug_tuple("GpuTextureFormat::Bc6hRgbUfloat").finish()
            }
            GpuTextureFormat::Bc6hRgbFloat => {
              f.debug_tuple("GpuTextureFormat::Bc6hRgbFloat").finish()
            }
            GpuTextureFormat::Bc7RgbaUnorm => {
              f.debug_tuple("GpuTextureFormat::Bc7RgbaUnorm").finish()
            }
            GpuTextureFormat::Bc7RgbaUnormSrgb => {
              f.debug_tuple("GpuTextureFormat::Bc7RgbaUnormSrgb").finish()
            }
            GpuTextureFormat::Etc2Rgb8unorm => {
              f.debug_tuple("GpuTextureFormat::Etc2Rgb8unorm").finish()
            }
            GpuTextureFormat::Etc2Rgb8unormSrgb => {
              f.debug_tuple("GpuTextureFormat::Etc2Rgb8unormSrgb").finish()
            }
            GpuTextureFormat::Etc2Rgb8a1unorm => {
              f.debug_tuple("GpuTextureFormat::Etc2Rgb8a1unorm").finish()
            }
            GpuTextureFormat::Etc2Rgb8a1unormSrgb => {
              f.debug_tuple("GpuTextureFormat::Etc2Rgb8a1unormSrgb").finish()
            }
            GpuTextureFormat::Etc2Rgba8unorm => {
              f.debug_tuple("GpuTextureFormat::Etc2Rgba8unorm").finish()
            }
            GpuTextureFormat::Etc2Rgba8unormSrgb => {
              f.debug_tuple("GpuTextureFormat::Etc2Rgba8unormSrgb").finish()
            }
            GpuTextureFormat::EacR11unorm => {
              f.debug_tuple("GpuTextureFormat::EacR11unorm").finish()
            }
            GpuTextureFormat::EacR11snorm => {
              f.debug_tuple("GpuTextureFormat::EacR11snorm").finish()
            }
            GpuTextureFormat::EacRg11unorm => {
              f.debug_tuple("GpuTextureFormat::EacRg11unorm").finish()
            }
            GpuTextureFormat::EacRg11snorm => {
              f.debug_tuple("GpuTextureFormat::EacRg11snorm").finish()
            }
            GpuTextureFormat::Astc4x4Unorm => {
              f.debug_tuple("GpuTextureFormat::Astc4x4Unorm").finish()
            }
            GpuTextureFormat::Astc4x4UnormSrgb => {
              f.debug_tuple("GpuTextureFormat::Astc4x4UnormSrgb").finish()
            }
            GpuTextureFormat::Astc5x4Unorm => {
              f.debug_tuple("GpuTextureFormat::Astc5x4Unorm").finish()
            }
            GpuTextureFormat::Astc5x4UnormSrgb => {
              f.debug_tuple("GpuTextureFormat::Astc5x4UnormSrgb").finish()
            }
            GpuTextureFormat::Astc5x5Unorm => {
              f.debug_tuple("GpuTextureFormat::Astc5x5Unorm").finish()
            }
            GpuTextureFormat::Astc5x5UnormSrgb => {
              f.debug_tuple("GpuTextureFormat::Astc5x5UnormSrgb").finish()
            }
            GpuTextureFormat::Astc6x5Unorm => {
              f.debug_tuple("GpuTextureFormat::Astc6x5Unorm").finish()
            }
            GpuTextureFormat::Astc6x5UnormSrgb => {
              f.debug_tuple("GpuTextureFormat::Astc6x5UnormSrgb").finish()
            }
            GpuTextureFormat::Astc6x6Unorm => {
              f.debug_tuple("GpuTextureFormat::Astc6x6Unorm").finish()
            }
            GpuTextureFormat::Astc6x6UnormSrgb => {
              f.debug_tuple("GpuTextureFormat::Astc6x6UnormSrgb").finish()
            }
            GpuTextureFormat::Astc8x5Unorm => {
              f.debug_tuple("GpuTextureFormat::Astc8x5Unorm").finish()
            }
            GpuTextureFormat::Astc8x5UnormSrgb => {
              f.debug_tuple("GpuTextureFormat::Astc8x5UnormSrgb").finish()
            }
            GpuTextureFormat::Astc8x6Unorm => {
              f.debug_tuple("GpuTextureFormat::Astc8x6Unorm").finish()
            }
            GpuTextureFormat::Astc8x6UnormSrgb => {
              f.debug_tuple("GpuTextureFormat::Astc8x6UnormSrgb").finish()
            }
            GpuTextureFormat::Astc8x8Unorm => {
              f.debug_tuple("GpuTextureFormat::Astc8x8Unorm").finish()
            }
            GpuTextureFormat::Astc8x8UnormSrgb => {
              f.debug_tuple("GpuTextureFormat::Astc8x8UnormSrgb").finish()
            }
            GpuTextureFormat::Astc10x5Unorm => {
              f.debug_tuple("GpuTextureFormat::Astc10x5Unorm").finish()
            }
            GpuTextureFormat::Astc10x5UnormSrgb => {
              f.debug_tuple("GpuTextureFormat::Astc10x5UnormSrgb").finish()
            }
            GpuTextureFormat::Astc10x6Unorm => {
              f.debug_tuple("GpuTextureFormat::Astc10x6Unorm").finish()
            }
            GpuTextureFormat::Astc10x6UnormSrgb => {
              f.debug_tuple("GpuTextureFormat::Astc10x6UnormSrgb").finish()
            }
            GpuTextureFormat::Astc10x8Unorm => {
              f.debug_tuple("GpuTextureFormat::Astc10x8Unorm").finish()
            }
            GpuTextureFormat::Astc10x8UnormSrgb => {
              f.debug_tuple("GpuTextureFormat::Astc10x8UnormSrgb").finish()
            }
            GpuTextureFormat::Astc10x10Unorm => {
              f.debug_tuple("GpuTextureFormat::Astc10x10Unorm").finish()
            }
            GpuTextureFormat::Astc10x10UnormSrgb => {
              f.debug_tuple("GpuTextureFormat::Astc10x10UnormSrgb").finish()
            }
            GpuTextureFormat::Astc12x10Unorm => {
              f.debug_tuple("GpuTextureFormat::Astc12x10Unorm").finish()
            }
            GpuTextureFormat::Astc12x10UnormSrgb => {
              f.debug_tuple("GpuTextureFormat::Astc12x10UnormSrgb").finish()
            }
            GpuTextureFormat::Astc12x12Unorm => {
              f.debug_tuple("GpuTextureFormat::Astc12x12Unorm").finish()
            }
            GpuTextureFormat::Astc12x12UnormSrgb => {
              f.debug_tuple("GpuTextureFormat::Astc12x12UnormSrgb").finish()
            }
          }
        }
      }

      impl GpuTextureFormat{
        #[doc(hidden)]
        pub unsafe fn _lift(val: u8) -> GpuTextureFormat{
          if !cfg!(debug_assertions) {
            return unsafe { ::core::mem::transmute(val) };
          }

          match val {
            0 => GpuTextureFormat::R8unorm,
            1 => GpuTextureFormat::R8snorm,
            2 => GpuTextureFormat::R8uint,
            3 => GpuTextureFormat::R8sint,
            4 => GpuTextureFormat::R16uint,
            5 => GpuTextureFormat::R16sint,
            6 => GpuTextureFormat::R16float,
            7 => GpuTextureFormat::Rg8unorm,
            8 => GpuTextureFormat::Rg8snorm,
            9 => GpuTextureFormat::Rg8uint,
            10 => GpuTextureFormat::Rg8sint,
            11 => GpuTextureFormat::R32uint,
            12 => GpuTextureFormat::R32sint,
            13 => GpuTextureFormat::R32float,
            14 => GpuTextureFormat::Rg16uint,
            15 => GpuTextureFormat::Rg16sint,
            16 => GpuTextureFormat::Rg16float,
            17 => GpuTextureFormat::Rgba8unorm,
            18 => GpuTextureFormat::Rgba8unormSrgb,
            19 => GpuTextureFormat::Rgba8snorm,
            20 => GpuTextureFormat::Rgba8uint,
            21 => GpuTextureFormat::Rgba8sint,
            22 => GpuTextureFormat::Bgra8unorm,
            23 => GpuTextureFormat::Bgra8unormSrgb,
            24 => GpuTextureFormat::Rgb9e5ufloat,
            25 => GpuTextureFormat::Rgb10a2uint,
            26 => GpuTextureFormat::Rgb10a2unorm,
            27 => GpuTextureFormat::Rg11b10ufloat,
            28 => GpuTextureFormat::Rg32uint,
            29 => GpuTextureFormat::Rg32sint,
            30 => GpuTextureFormat::Rg32float,
            31 => GpuTextureFormat::Rgba16uint,
            32 => GpuTextureFormat::Rgba16sint,
            33 => GpuTextureFormat::Rgba16float,
            34 => GpuTextureFormat::Rgba32uint,
            35 => GpuTextureFormat::Rgba32sint,
            36 => GpuTextureFormat::Rgba32float,
            37 => GpuTextureFormat::Stencil8,
            38 => GpuTextureFormat::Depth16unorm,
            39 => GpuTextureFormat::Depth24plus,
            40 => GpuTextureFormat::Depth24plusStencil8,
            41 => GpuTextureFormat::Depth32float,
            42 => GpuTextureFormat::Depth32floatStencil8,
            43 => GpuTextureFormat::Bc1RgbaUnorm,
            44 => GpuTextureFormat::Bc1RgbaUnormSrgb,
            45 => GpuTextureFormat::Bc2RgbaUnorm,
            46 => GpuTextureFormat::Bc2RgbaUnormSrgb,
            47 => GpuTextureFormat::Bc3RgbaUnorm,
            48 => GpuTextureFormat::Bc3RgbaUnormSrgb,
            49 => GpuTextureFormat::Bc4RUnorm,
            50 => GpuTextureFormat::Bc4RSnorm,
            51 => GpuTextureFormat::Bc5RgUnorm,
            52 => GpuTextureFormat::Bc5RgSnorm,
            53 => GpuTextureFormat::Bc6hRgbUfloat,
            54 => GpuTextureFormat::Bc6hRgbFloat,
            55 => GpuTextureFormat::Bc7RgbaUnorm,
            56 => GpuTextureFormat::Bc7RgbaUnormSrgb,
            57 => GpuTextureFormat::Etc2Rgb8unorm,
            58 => GpuTextureFormat::Etc2Rgb8unormSrgb,
            59 => GpuTextureFormat::Etc2Rgb8a1unorm,
            60 => GpuTextureFormat::Etc2Rgb8a1unormSrgb,
            61 => GpuTextureFormat::Etc2Rgba8unorm,
            62 => GpuTextureFormat::Etc2Rgba8unormSrgb,
            63 => GpuTextureFormat::EacR11unorm,
            64 => GpuTextureFormat::EacR11snorm,
            65 => GpuTextureFormat::EacRg11unorm,
            66 => GpuTextureFormat::EacRg11snorm,
            67 => GpuTextureFormat::Astc4x4Unorm,
            68 => GpuTextureFormat::Astc4x4UnormSrgb,
            69 => GpuTextureFormat::Astc5x4Unorm,
            70 => GpuTextureFormat::Astc5x4UnormSrgb,
            71 => GpuTextureFormat::Astc5x5Unorm,
            72 => GpuTextureFormat::Astc5x5UnormSrgb,
            73 => GpuTextureFormat::Astc6x5Unorm,
            74 => GpuTextureFormat::Astc6x5UnormSrgb,
            75 => GpuTextureFormat::Astc6x6Unorm,
            76 => GpuTextureFormat::Astc6x6UnormSrgb,
            77 => GpuTextureFormat::Astc8x5Unorm,
            78 => GpuTextureFormat::Astc8x5UnormSrgb,
            79 => GpuTextureFormat::Astc8x6Unorm,
            80 => GpuTextureFormat::Astc8x6UnormSrgb,
            81 => GpuTextureFormat::Astc8x8Unorm,
            82 => GpuTextureFormat::Astc8x8UnormSrgb,
            83 => GpuTextureFormat::Astc10x5Unorm,
            84 => GpuTextureFormat::Astc10x5UnormSrgb,
            85 => GpuTextureFormat::Astc10x6Unorm,
            86 => GpuTextureFormat::Astc10x6UnormSrgb,
            87 => GpuTextureFormat::Astc10x8Unorm,
            88 => GpuTextureFormat::Astc10x8UnormSrgb,
            89 => GpuTextureFormat::Astc10x10Unorm,
            90 => GpuTextureFormat::Astc10x10UnormSrgb,
            91 => GpuTextureFormat::Astc12x10Unorm,
            92 => GpuTextureFormat::Astc12x10UnormSrgb,
            93 => GpuTextureFormat::Astc12x12Unorm,
            94 => GpuTextureFormat::Astc12x12UnormSrgb,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }
      

      #[derive(Debug)]
      #[repr(transparent)]
      pub struct GpuSampler{
        handle: _rt::Resource<GpuSampler>,
      }

      impl GpuSampler{
        #[doc(hidden)]
        pub unsafe fn from_handle(handle: u32) -> Self {
          Self {
            handle: unsafe { _rt::Resource::from_handle(handle) },
          }
        }

        #[doc(hidden)]
        pub fn take_handle(&self) -> u32 {
          _rt::Resource::take_handle(&self.handle)
        }

        #[doc(hidden)]
        pub fn handle(&self) -> u32 {
          _rt::Resource::handle(&self.handle)
        }
      }
      

      unsafe impl _rt::WasmResource for GpuSampler{
        #[inline]
        unsafe fn drop(_handle: u32) {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
          unsafe extern "C" {
            #[link_name = "[resource-drop]gpu-sampler"]
            fn drop(_: i32, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn drop(_: i32, ) { unreachable!() }
          
          unsafe { drop(_handle as i32); }
        }
      }
      
      #[repr(u8)]
      #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
      pub enum GpuAddressMode {
        ClampToEdge,
        Repeat,
        MirrorRepeat,
      }
      impl ::core::fmt::Debug for GpuAddressMode {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            GpuAddressMode::ClampToEdge => {
              f.debug_tuple("GpuAddressMode::ClampToEdge").finish()
            }
            GpuAddressMode::Repeat => {
              f.debug_tuple("GpuAddressMode::Repeat").finish()
            }
            GpuAddressMode::MirrorRepeat => {
              f.debug_tuple("GpuAddressMode::MirrorRepeat").finish()
            }
          }
        }
      }

      impl GpuAddressMode{
        #[doc(hidden)]
        pub unsafe fn _lift(val: u8) -> GpuAddressMode{
          if !cfg!(debug_assertions) {
            return unsafe { ::core::mem::transmute(val) };
          }

          match val {
            0 => GpuAddressMode::ClampToEdge,
            1 => GpuAddressMode::Repeat,
            2 => GpuAddressMode::MirrorRepeat,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }
      
      #[repr(u8)]
      #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
      pub enum GpuFilterMode {
        Nearest,
        Linear,
      }
      impl ::core::fmt::Debug for GpuFilterMode {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            GpuFilterMode::Nearest => {
              f.debug_tuple("GpuFilterMode::Nearest").finish()
            }
            GpuFilterMode::Linear => {
              f.debug_tuple("GpuFilterMode::Linear").finish()
            }
          }
        }
      }

      impl GpuFilterMode{
        #[doc(hidden)]
        pub unsafe fn _lift(val: u8) -> GpuFilterMode{
          if !cfg!(debug_assertions) {
            return unsafe { ::core::mem::transmute(val) };
          }

          match val {
            0 => GpuFilterMode::Nearest,
            1 => GpuFilterMode::Linear,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }
      
      #[repr(u8)]
      #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
      pub enum GpuMipmapFilterMode {
        Nearest,
        Linear,
      }
      impl ::core::fmt::Debug for GpuMipmapFilterMode {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            GpuMipmapFilterMode::Nearest => {
              f.debug_tuple("GpuMipmapFilterMode::Nearest").finish()
            }
            GpuMipmapFilterMode::Linear => {
              f.debug_tuple("GpuMipmapFilterMode::Linear").finish()
            }
          }
        }
      }

      impl GpuMipmapFilterMode{
        #[doc(hidden)]
        pub unsafe fn _lift(val: u8) -> GpuMipmapFilterMode{
          if !cfg!(debug_assertions) {
            return unsafe { ::core::mem::transmute(val) };
          }

          match val {
            0 => GpuMipmapFilterMode::Nearest,
            1 => GpuMipmapFilterMode::Linear,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }
      
      #[repr(u8)]
      #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
      pub enum GpuCompareFunction {
        Never,
        Less,
        Equal,
        LessEqual,
        Greater,
        NotEqual,
        GreaterEqual,
        Always,
      }
      impl ::core::fmt::Debug for GpuCompareFunction {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            GpuCompareFunction::Never => {
              f.debug_tuple("GpuCompareFunction::Never").finish()
            }
            GpuCompareFunction::Less => {
              f.debug_tuple("GpuCompareFunction::Less").finish()
            }
            GpuCompareFunction::Equal => {
              f.debug_tuple("GpuCompareFunction::Equal").finish()
            }
            GpuCompareFunction::LessEqual => {
              f.debug_tuple("GpuCompareFunction::LessEqual").finish()
            }
            GpuCompareFunction::Greater => {
              f.debug_tuple("GpuCompareFunction::Greater").finish()
            }
            GpuCompareFunction::NotEqual => {
              f.debug_tuple("GpuCompareFunction::NotEqual").finish()
            }
            GpuCompareFunction::GreaterEqual => {
              f.debug_tuple("GpuCompareFunction::GreaterEqual").finish()
            }
            GpuCompareFunction::Always => {
              f.debug_tuple("GpuCompareFunction::Always").finish()
            }
          }
        }
      }

      impl GpuCompareFunction{
        #[doc(hidden)]
        pub unsafe fn _lift(val: u8) -> GpuCompareFunction{
          if !cfg!(debug_assertions) {
            return unsafe { ::core::mem::transmute(val) };
          }

          match val {
            0 => GpuCompareFunction::Never,
            1 => GpuCompareFunction::Less,
            2 => GpuCompareFunction::Equal,
            3 => GpuCompareFunction::LessEqual,
            4 => GpuCompareFunction::Greater,
            5 => GpuCompareFunction::NotEqual,
            6 => GpuCompareFunction::GreaterEqual,
            7 => GpuCompareFunction::Always,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }
      
      #[derive(Clone)]
      pub struct GpuSamplerDescriptor {
        pub address_mode_u: Option<GpuAddressMode>,
        pub address_mode_v: Option<GpuAddressMode>,
        pub address_mode_w: Option<GpuAddressMode>,
        pub mag_filter: Option<GpuFilterMode>,
        pub min_filter: Option<GpuFilterMode>,
        pub mipmap_filter: Option<GpuMipmapFilterMode>,
        pub lod_min_clamp: Option<f32>,
        pub lod_max_clamp: Option<f32>,
        pub compare: Option<GpuCompareFunction>,
        pub max_anisotropy: Option<u16>,
        pub label: Option<_rt::String>,
      }
      impl ::core::fmt::Debug for GpuSamplerDescriptor {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("GpuSamplerDescriptor").field("address-mode-u", &self.address_mode_u).field("address-mode-v", &self.address_mode_v).field("address-mode-w", &self.address_mode_w).field("mag-filter", &self.mag_filter).field("min-filter", &self.min_filter).field("mipmap-filter", &self.mipmap_filter).field("lod-min-clamp", &self.lod_min_clamp).field("lod-max-clamp", &self.lod_max_clamp).field("compare", &self.compare).field("max-anisotropy", &self.max_anisotropy).field("label", &self.label).finish()
        }
      }

      #[derive(Debug)]
      #[repr(transparent)]
      pub struct GpuBindGroupLayout{
        handle: _rt::Resource<GpuBindGroupLayout>,
      }

      impl GpuBindGroupLayout{
        #[doc(hidden)]
        pub unsafe fn from_handle(handle: u32) -> Self {
          Self {
            handle: unsafe { _rt::Resource::from_handle(handle) },
          }
        }

        #[doc(hidden)]
        pub fn take_handle(&self) -> u32 {
          _rt::Resource::take_handle(&self.handle)
        }

        #[doc(hidden)]
        pub fn handle(&self) -> u32 {
          _rt::Resource::handle(&self.handle)
        }
      }
      

      unsafe impl _rt::WasmResource for GpuBindGroupLayout{
        #[inline]
        unsafe fn drop(_handle: u32) {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
          unsafe extern "C" {
            #[link_name = "[resource-drop]gpu-bind-group-layout"]
            fn drop(_: i32, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn drop(_: i32, ) { unreachable!() }
          
          unsafe { drop(_handle as i32); }
        }
      }
      
      pub type GpuShaderStageFlags = u32;

      #[derive(Debug)]
      #[repr(transparent)]
      pub struct GpuShaderStage{
        handle: _rt::Resource<GpuShaderStage>,
      }

      impl GpuShaderStage{
        #[doc(hidden)]
        pub unsafe fn from_handle(handle: u32) -> Self {
          Self {
            handle: unsafe { _rt::Resource::from_handle(handle) },
          }
        }

        #[doc(hidden)]
        pub fn take_handle(&self) -> u32 {
          _rt::Resource::take_handle(&self.handle)
        }

        #[doc(hidden)]
        pub fn handle(&self) -> u32 {
          _rt::Resource::handle(&self.handle)
        }
      }
      

      unsafe impl _rt::WasmResource for GpuShaderStage{
        #[inline]
        unsafe fn drop(_handle: u32) {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
          unsafe extern "C" {
            #[link_name = "[resource-drop]gpu-shader-stage"]
            fn drop(_: i32, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn drop(_: i32, ) { unreachable!() }
          
          unsafe { drop(_handle as i32); }
        }
      }
      
      #[repr(u8)]
      #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
      pub enum GpuBufferBindingType {
        Uniform,
        Storage,
        ReadOnlyStorage,
      }
      impl ::core::fmt::Debug for GpuBufferBindingType {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            GpuBufferBindingType::Uniform => {
              f.debug_tuple("GpuBufferBindingType::Uniform").finish()
            }
            GpuBufferBindingType::Storage => {
              f.debug_tuple("GpuBufferBindingType::Storage").finish()
            }
            GpuBufferBindingType::ReadOnlyStorage => {
              f.debug_tuple("GpuBufferBindingType::ReadOnlyStorage").finish()
            }
          }
        }
      }

      impl GpuBufferBindingType{
        #[doc(hidden)]
        pub unsafe fn _lift(val: u8) -> GpuBufferBindingType{
          if !cfg!(debug_assertions) {
            return unsafe { ::core::mem::transmute(val) };
          }

          match val {
            0 => GpuBufferBindingType::Uniform,
            1 => GpuBufferBindingType::Storage,
            2 => GpuBufferBindingType::ReadOnlyStorage,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }
      
      #[repr(u8)]
      #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
      pub enum GpuSamplerBindingType {
        Filtering,
        NonFiltering,
        Comparison,
      }
      impl ::core::fmt::Debug for GpuSamplerBindingType {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            GpuSamplerBindingType::Filtering => {
              f.debug_tuple("GpuSamplerBindingType::Filtering").finish()
            }
            GpuSamplerBindingType::NonFiltering => {
              f.debug_tuple("GpuSamplerBindingType::NonFiltering").finish()
            }
            GpuSamplerBindingType::Comparison => {
              f.debug_tuple("GpuSamplerBindingType::Comparison").finish()
            }
          }
        }
      }

      impl GpuSamplerBindingType{
        #[doc(hidden)]
        pub unsafe fn _lift(val: u8) -> GpuSamplerBindingType{
          if !cfg!(debug_assertions) {
            return unsafe { ::core::mem::transmute(val) };
          }

          match val {
            0 => GpuSamplerBindingType::Filtering,
            1 => GpuSamplerBindingType::NonFiltering,
            2 => GpuSamplerBindingType::Comparison,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }
      
      #[repr(C)]
      #[derive(Clone, Copy)]
      pub struct GpuSamplerBindingLayout {
        pub type_: Option<GpuSamplerBindingType>,
      }
      impl ::core::fmt::Debug for GpuSamplerBindingLayout {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("GpuSamplerBindingLayout").field("type", &self.type_).finish()
        }
      }
      #[repr(u8)]
      #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
      pub enum GpuTextureSampleType {
        Float,
        UnfilterableFloat,
        Depth,
        Sint,
        Uint,
      }
      impl ::core::fmt::Debug for GpuTextureSampleType {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            GpuTextureSampleType::Float => {
              f.debug_tuple("GpuTextureSampleType::Float").finish()
            }
            GpuTextureSampleType::UnfilterableFloat => {
              f.debug_tuple("GpuTextureSampleType::UnfilterableFloat").finish()
            }
            GpuTextureSampleType::Depth => {
              f.debug_tuple("GpuTextureSampleType::Depth").finish()
            }
            GpuTextureSampleType::Sint => {
              f.debug_tuple("GpuTextureSampleType::Sint").finish()
            }
            GpuTextureSampleType::Uint => {
              f.debug_tuple("GpuTextureSampleType::Uint").finish()
            }
          }
        }
      }

      impl GpuTextureSampleType{
        #[doc(hidden)]
        pub unsafe fn _lift(val: u8) -> GpuTextureSampleType{
          if !cfg!(debug_assertions) {
            return unsafe { ::core::mem::transmute(val) };
          }

          match val {
            0 => GpuTextureSampleType::Float,
            1 => GpuTextureSampleType::UnfilterableFloat,
            2 => GpuTextureSampleType::Depth,
            3 => GpuTextureSampleType::Sint,
            4 => GpuTextureSampleType::Uint,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }
      
      #[repr(C)]
      #[derive(Clone, Copy)]
      pub struct GpuTextureBindingLayout {
        pub sample_type: Option<GpuTextureSampleType>,
        pub view_dimension: Option<GpuTextureViewDimension>,
        pub multisampled: Option<bool>,
      }
      impl ::core::fmt::Debug for GpuTextureBindingLayout {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("GpuTextureBindingLayout").field("sample-type", &self.sample_type).field("view-dimension", &self.view_dimension).field("multisampled", &self.multisampled).finish()
        }
      }
      #[repr(u8)]
      #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
      pub enum GpuStorageTextureAccess {
        WriteOnly,
        ReadOnly,
        ReadWrite,
      }
      impl ::core::fmt::Debug for GpuStorageTextureAccess {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            GpuStorageTextureAccess::WriteOnly => {
              f.debug_tuple("GpuStorageTextureAccess::WriteOnly").finish()
            }
            GpuStorageTextureAccess::ReadOnly => {
              f.debug_tuple("GpuStorageTextureAccess::ReadOnly").finish()
            }
            GpuStorageTextureAccess::ReadWrite => {
              f.debug_tuple("GpuStorageTextureAccess::ReadWrite").finish()
            }
          }
        }
      }

      impl GpuStorageTextureAccess{
        #[doc(hidden)]
        pub unsafe fn _lift(val: u8) -> GpuStorageTextureAccess{
          if !cfg!(debug_assertions) {
            return unsafe { ::core::mem::transmute(val) };
          }

          match val {
            0 => GpuStorageTextureAccess::WriteOnly,
            1 => GpuStorageTextureAccess::ReadOnly,
            2 => GpuStorageTextureAccess::ReadWrite,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }
      
      #[repr(C)]
      #[derive(Clone, Copy)]
      pub struct GpuStorageTextureBindingLayout {
        pub access: Option<GpuStorageTextureAccess>,
        pub format: GpuTextureFormat,
        pub view_dimension: Option<GpuTextureViewDimension>,
      }
      impl ::core::fmt::Debug for GpuStorageTextureBindingLayout {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("GpuStorageTextureBindingLayout").field("access", &self.access).field("format", &self.format).field("view-dimension", &self.view_dimension).finish()
        }
      }

      #[derive(Debug)]
      #[repr(transparent)]
      pub struct GpuBindGroup{
        handle: _rt::Resource<GpuBindGroup>,
      }

      impl GpuBindGroup{
        #[doc(hidden)]
        pub unsafe fn from_handle(handle: u32) -> Self {
          Self {
            handle: unsafe { _rt::Resource::from_handle(handle) },
          }
        }

        #[doc(hidden)]
        pub fn take_handle(&self) -> u32 {
          _rt::Resource::take_handle(&self.handle)
        }

        #[doc(hidden)]
        pub fn handle(&self) -> u32 {
          _rt::Resource::handle(&self.handle)
        }
      }
      

      unsafe impl _rt::WasmResource for GpuBindGroup{
        #[inline]
        unsafe fn drop(_handle: u32) {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
          unsafe extern "C" {
            #[link_name = "[resource-drop]gpu-bind-group"]
            fn drop(_: i32, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn drop(_: i32, ) { unreachable!() }
          
          unsafe { drop(_handle as i32); }
        }
      }
      

      #[derive(Debug)]
      #[repr(transparent)]
      pub struct GpuPipelineLayout{
        handle: _rt::Resource<GpuPipelineLayout>,
      }

      impl GpuPipelineLayout{
        #[doc(hidden)]
        pub unsafe fn from_handle(handle: u32) -> Self {
          Self {
            handle: unsafe { _rt::Resource::from_handle(handle) },
          }
        }

        #[doc(hidden)]
        pub fn take_handle(&self) -> u32 {
          _rt::Resource::take_handle(&self.handle)
        }

        #[doc(hidden)]
        pub fn handle(&self) -> u32 {
          _rt::Resource::handle(&self.handle)
        }
      }
      

      unsafe impl _rt::WasmResource for GpuPipelineLayout{
        #[inline]
        unsafe fn drop(_handle: u32) {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
          unsafe extern "C" {
            #[link_name = "[resource-drop]gpu-pipeline-layout"]
            fn drop(_: i32, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn drop(_: i32, ) { unreachable!() }
          
          unsafe { drop(_handle as i32); }
        }
      }
      
      pub struct GpuPipelineLayoutDescriptor<'a,> {
        pub bind_group_layouts: _rt::Vec::<Option<&'a GpuBindGroupLayout>>,
        pub label: Option<_rt::String>,
      }
      impl<'a,> ::core::fmt::Debug for GpuPipelineLayoutDescriptor<'a,> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("GpuPipelineLayoutDescriptor").field("bind-group-layouts", &self.bind_group_layouts).field("label", &self.label).finish()
        }
      }

      #[derive(Debug)]
      #[repr(transparent)]
      pub struct GpuShaderModule{
        handle: _rt::Resource<GpuShaderModule>,
      }

      impl GpuShaderModule{
        #[doc(hidden)]
        pub unsafe fn from_handle(handle: u32) -> Self {
          Self {
            handle: unsafe { _rt::Resource::from_handle(handle) },
          }
        }

        #[doc(hidden)]
        pub fn take_handle(&self) -> u32 {
          _rt::Resource::take_handle(&self.handle)
        }

        #[doc(hidden)]
        pub fn handle(&self) -> u32 {
          _rt::Resource::handle(&self.handle)
        }
      }
      

      unsafe impl _rt::WasmResource for GpuShaderModule{
        #[inline]
        unsafe fn drop(_handle: u32) {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
          unsafe extern "C" {
            #[link_name = "[resource-drop]gpu-shader-module"]
            fn drop(_: i32, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn drop(_: i32, ) { unreachable!() }
          
          unsafe { drop(_handle as i32); }
        }
      }
      
      #[repr(u8)]
      #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
      pub enum GpuCompilationMessageType {
        Error,
        Warning,
        Info,
      }
      impl ::core::fmt::Debug for GpuCompilationMessageType {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            GpuCompilationMessageType::Error => {
              f.debug_tuple("GpuCompilationMessageType::Error").finish()
            }
            GpuCompilationMessageType::Warning => {
              f.debug_tuple("GpuCompilationMessageType::Warning").finish()
            }
            GpuCompilationMessageType::Info => {
              f.debug_tuple("GpuCompilationMessageType::Info").finish()
            }
          }
        }
      }

      impl GpuCompilationMessageType{
        #[doc(hidden)]
        pub unsafe fn _lift(val: u8) -> GpuCompilationMessageType{
          if !cfg!(debug_assertions) {
            return unsafe { ::core::mem::transmute(val) };
          }

          match val {
            0 => GpuCompilationMessageType::Error,
            1 => GpuCompilationMessageType::Warning,
            2 => GpuCompilationMessageType::Info,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }
      

      #[derive(Debug)]
      #[repr(transparent)]
      pub struct GpuCompilationMessage{
        handle: _rt::Resource<GpuCompilationMessage>,
      }

      impl GpuCompilationMessage{
        #[doc(hidden)]
        pub unsafe fn from_handle(handle: u32) -> Self {
          Self {
            handle: unsafe { _rt::Resource::from_handle(handle) },
          }
        }

        #[doc(hidden)]
        pub fn take_handle(&self) -> u32 {
          _rt::Resource::take_handle(&self.handle)
        }

        #[doc(hidden)]
        pub fn handle(&self) -> u32 {
          _rt::Resource::handle(&self.handle)
        }
      }
      

      unsafe impl _rt::WasmResource for GpuCompilationMessage{
        #[inline]
        unsafe fn drop(_handle: u32) {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
          unsafe extern "C" {
            #[link_name = "[resource-drop]gpu-compilation-message"]
            fn drop(_: i32, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn drop(_: i32, ) { unreachable!() }
          
          unsafe { drop(_handle as i32); }
        }
      }
      

      #[derive(Debug)]
      #[repr(transparent)]
      pub struct GpuCompilationInfo{
        handle: _rt::Resource<GpuCompilationInfo>,
      }

      impl GpuCompilationInfo{
        #[doc(hidden)]
        pub unsafe fn from_handle(handle: u32) -> Self {
          Self {
            handle: unsafe { _rt::Resource::from_handle(handle) },
          }
        }

        #[doc(hidden)]
        pub fn take_handle(&self) -> u32 {
          _rt::Resource::take_handle(&self.handle)
        }

        #[doc(hidden)]
        pub fn handle(&self) -> u32 {
          _rt::Resource::handle(&self.handle)
        }
      }
      

      unsafe impl _rt::WasmResource for GpuCompilationInfo{
        #[inline]
        unsafe fn drop(_handle: u32) {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
          unsafe extern "C" {
            #[link_name = "[resource-drop]gpu-compilation-info"]
            fn drop(_: i32, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn drop(_: i32, ) { unreachable!() }
          
          unsafe { drop(_handle as i32); }
        }
      }
      
      #[repr(u8)]
      #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
      pub enum GpuPipelineErrorReason {
        Validation,
        Internal,
      }
      impl ::core::fmt::Debug for GpuPipelineErrorReason {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            GpuPipelineErrorReason::Validation => {
              f.debug_tuple("GpuPipelineErrorReason::Validation").finish()
            }
            GpuPipelineErrorReason::Internal => {
              f.debug_tuple("GpuPipelineErrorReason::Internal").finish()
            }
          }
        }
      }

      impl GpuPipelineErrorReason{
        #[doc(hidden)]
        pub unsafe fn _lift(val: u8) -> GpuPipelineErrorReason{
          if !cfg!(debug_assertions) {
            return unsafe { ::core::mem::transmute(val) };
          }

          match val {
            0 => GpuPipelineErrorReason::Validation,
            1 => GpuPipelineErrorReason::Internal,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }
      
      pub enum GpuLayoutMode<'a,> {
        Specific(&'a GpuPipelineLayout),
        Auto,
      }
      impl<'a,> ::core::fmt::Debug for GpuLayoutMode<'a,> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            GpuLayoutMode::Specific(e) => {
              f.debug_tuple("GpuLayoutMode::Specific").field(e).finish()
            }
            GpuLayoutMode::Auto => {
              f.debug_tuple("GpuLayoutMode::Auto").finish()
            }
          }
        }
      }
      pub struct GpuShaderModuleCompilationHint<'a,> {
        pub entry_point: _rt::String,
        pub layout: Option<GpuLayoutMode<'a,>>,
      }
      impl<'a,> ::core::fmt::Debug for GpuShaderModuleCompilationHint<'a,> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("GpuShaderModuleCompilationHint").field("entry-point", &self.entry_point).field("layout", &self.layout).finish()
        }
      }
      pub struct GpuShaderModuleDescriptor<'a,> {
        pub code: _rt::String,
        pub compilation_hints: Option<_rt::Vec::<GpuShaderModuleCompilationHint<'a,>>>,
        pub label: Option<_rt::String>,
      }
      impl<'a,> ::core::fmt::Debug for GpuShaderModuleDescriptor<'a,> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("GpuShaderModuleDescriptor").field("code", &self.code).field("compilation-hints", &self.compilation_hints).field("label", &self.label).finish()
        }
      }

      #[derive(Debug)]
      #[repr(transparent)]
      pub struct RecordGpuPipelineConstantValue{
        handle: _rt::Resource<RecordGpuPipelineConstantValue>,
      }

      impl RecordGpuPipelineConstantValue{
        #[doc(hidden)]
        pub unsafe fn from_handle(handle: u32) -> Self {
          Self {
            handle: unsafe { _rt::Resource::from_handle(handle) },
          }
        }

        #[doc(hidden)]
        pub fn take_handle(&self) -> u32 {
          _rt::Resource::take_handle(&self.handle)
        }

        #[doc(hidden)]
        pub fn handle(&self) -> u32 {
          _rt::Resource::handle(&self.handle)
        }
      }
      

      unsafe impl _rt::WasmResource for RecordGpuPipelineConstantValue{
        #[inline]
        unsafe fn drop(_handle: u32) {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
          unsafe extern "C" {
            #[link_name = "[resource-drop]record-gpu-pipeline-constant-value"]
            fn drop(_: i32, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn drop(_: i32, ) { unreachable!() }
          
          unsafe { drop(_handle as i32); }
        }
      }
      
      pub struct GpuProgrammableStage<'a,> {
        pub module: &'a GpuShaderModule,
        pub entry_point: Option<_rt::String>,
        pub constants: Option<RecordGpuPipelineConstantValue>,
      }
      impl<'a,> ::core::fmt::Debug for GpuProgrammableStage<'a,> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("GpuProgrammableStage").field("module", &self.module).field("entry-point", &self.entry_point).field("constants", &self.constants).finish()
        }
      }
      pub type GpuPipelineConstantValue = f64;

      #[derive(Debug)]
      #[repr(transparent)]
      pub struct GpuComputePipeline{
        handle: _rt::Resource<GpuComputePipeline>,
      }

      impl GpuComputePipeline{
        #[doc(hidden)]
        pub unsafe fn from_handle(handle: u32) -> Self {
          Self {
            handle: unsafe { _rt::Resource::from_handle(handle) },
          }
        }

        #[doc(hidden)]
        pub fn take_handle(&self) -> u32 {
          _rt::Resource::take_handle(&self.handle)
        }

        #[doc(hidden)]
        pub fn handle(&self) -> u32 {
          _rt::Resource::handle(&self.handle)
        }
      }
      

      unsafe impl _rt::WasmResource for GpuComputePipeline{
        #[inline]
        unsafe fn drop(_handle: u32) {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
          unsafe extern "C" {
            #[link_name = "[resource-drop]gpu-compute-pipeline"]
            fn drop(_: i32, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn drop(_: i32, ) { unreachable!() }
          
          unsafe { drop(_handle as i32); }
        }
      }
      
      pub struct GpuComputePipelineDescriptor<'a,> {
        pub compute: GpuProgrammableStage<'a,>,
        pub layout: GpuLayoutMode<'a,>,
        pub label: Option<_rt::String>,
      }
      impl<'a,> ::core::fmt::Debug for GpuComputePipelineDescriptor<'a,> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("GpuComputePipelineDescriptor").field("compute", &self.compute).field("layout", &self.layout).field("label", &self.label).finish()
        }
      }

      #[derive(Debug)]
      #[repr(transparent)]
      pub struct GpuRenderPipeline{
        handle: _rt::Resource<GpuRenderPipeline>,
      }

      impl GpuRenderPipeline{
        #[doc(hidden)]
        pub unsafe fn from_handle(handle: u32) -> Self {
          Self {
            handle: unsafe { _rt::Resource::from_handle(handle) },
          }
        }

        #[doc(hidden)]
        pub fn take_handle(&self) -> u32 {
          _rt::Resource::take_handle(&self.handle)
        }

        #[doc(hidden)]
        pub fn handle(&self) -> u32 {
          _rt::Resource::handle(&self.handle)
        }
      }
      

      unsafe impl _rt::WasmResource for GpuRenderPipeline{
        #[inline]
        unsafe fn drop(_handle: u32) {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
          unsafe extern "C" {
            #[link_name = "[resource-drop]gpu-render-pipeline"]
            fn drop(_: i32, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn drop(_: i32, ) { unreachable!() }
          
          unsafe { drop(_handle as i32); }
        }
      }
      
      #[repr(u8)]
      #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
      pub enum GpuPrimitiveTopology {
        PointList,
        LineList,
        LineStrip,
        TriangleList,
        TriangleStrip,
      }
      impl ::core::fmt::Debug for GpuPrimitiveTopology {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            GpuPrimitiveTopology::PointList => {
              f.debug_tuple("GpuPrimitiveTopology::PointList").finish()
            }
            GpuPrimitiveTopology::LineList => {
              f.debug_tuple("GpuPrimitiveTopology::LineList").finish()
            }
            GpuPrimitiveTopology::LineStrip => {
              f.debug_tuple("GpuPrimitiveTopology::LineStrip").finish()
            }
            GpuPrimitiveTopology::TriangleList => {
              f.debug_tuple("GpuPrimitiveTopology::TriangleList").finish()
            }
            GpuPrimitiveTopology::TriangleStrip => {
              f.debug_tuple("GpuPrimitiveTopology::TriangleStrip").finish()
            }
          }
        }
      }

      impl GpuPrimitiveTopology{
        #[doc(hidden)]
        pub unsafe fn _lift(val: u8) -> GpuPrimitiveTopology{
          if !cfg!(debug_assertions) {
            return unsafe { ::core::mem::transmute(val) };
          }

          match val {
            0 => GpuPrimitiveTopology::PointList,
            1 => GpuPrimitiveTopology::LineList,
            2 => GpuPrimitiveTopology::LineStrip,
            3 => GpuPrimitiveTopology::TriangleList,
            4 => GpuPrimitiveTopology::TriangleStrip,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }
      
      #[repr(u8)]
      #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
      pub enum GpuFrontFace {
        Ccw,
        Cw,
      }
      impl ::core::fmt::Debug for GpuFrontFace {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            GpuFrontFace::Ccw => {
              f.debug_tuple("GpuFrontFace::Ccw").finish()
            }
            GpuFrontFace::Cw => {
              f.debug_tuple("GpuFrontFace::Cw").finish()
            }
          }
        }
      }

      impl GpuFrontFace{
        #[doc(hidden)]
        pub unsafe fn _lift(val: u8) -> GpuFrontFace{
          if !cfg!(debug_assertions) {
            return unsafe { ::core::mem::transmute(val) };
          }

          match val {
            0 => GpuFrontFace::Ccw,
            1 => GpuFrontFace::Cw,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }
      
      #[repr(u8)]
      #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
      pub enum GpuCullMode {
        None,
        Front,
        Back,
      }
      impl ::core::fmt::Debug for GpuCullMode {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            GpuCullMode::None => {
              f.debug_tuple("GpuCullMode::None").finish()
            }
            GpuCullMode::Front => {
              f.debug_tuple("GpuCullMode::Front").finish()
            }
            GpuCullMode::Back => {
              f.debug_tuple("GpuCullMode::Back").finish()
            }
          }
        }
      }

      impl GpuCullMode{
        #[doc(hidden)]
        pub unsafe fn _lift(val: u8) -> GpuCullMode{
          if !cfg!(debug_assertions) {
            return unsafe { ::core::mem::transmute(val) };
          }

          match val {
            0 => GpuCullMode::None,
            1 => GpuCullMode::Front,
            2 => GpuCullMode::Back,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }
      
      pub type GpuColorWriteFlags = u32;

      #[derive(Debug)]
      #[repr(transparent)]
      pub struct GpuColorWrite{
        handle: _rt::Resource<GpuColorWrite>,
      }

      impl GpuColorWrite{
        #[doc(hidden)]
        pub unsafe fn from_handle(handle: u32) -> Self {
          Self {
            handle: unsafe { _rt::Resource::from_handle(handle) },
          }
        }

        #[doc(hidden)]
        pub fn take_handle(&self) -> u32 {
          _rt::Resource::take_handle(&self.handle)
        }

        #[doc(hidden)]
        pub fn handle(&self) -> u32 {
          _rt::Resource::handle(&self.handle)
        }
      }
      

      unsafe impl _rt::WasmResource for GpuColorWrite{
        #[inline]
        unsafe fn drop(_handle: u32) {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
          unsafe extern "C" {
            #[link_name = "[resource-drop]gpu-color-write"]
            fn drop(_: i32, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn drop(_: i32, ) { unreachable!() }
          
          unsafe { drop(_handle as i32); }
        }
      }
      
      #[repr(u8)]
      #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
      pub enum GpuBlendFactor {
        Zero,
        One,
        Src,
        OneMinusSrc,
        SrcAlpha,
        OneMinusSrcAlpha,
        Dst,
        OneMinusDst,
        DstAlpha,
        OneMinusDstAlpha,
        SrcAlphaSaturated,
        Constant,
        OneMinusConstant,
        Src1,
        OneMinusSrc1,
        Src1Alpha,
        OneMinusSrc1Alpha,
      }
      impl ::core::fmt::Debug for GpuBlendFactor {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            GpuBlendFactor::Zero => {
              f.debug_tuple("GpuBlendFactor::Zero").finish()
            }
            GpuBlendFactor::One => {
              f.debug_tuple("GpuBlendFactor::One").finish()
            }
            GpuBlendFactor::Src => {
              f.debug_tuple("GpuBlendFactor::Src").finish()
            }
            GpuBlendFactor::OneMinusSrc => {
              f.debug_tuple("GpuBlendFactor::OneMinusSrc").finish()
            }
            GpuBlendFactor::SrcAlpha => {
              f.debug_tuple("GpuBlendFactor::SrcAlpha").finish()
            }
            GpuBlendFactor::OneMinusSrcAlpha => {
              f.debug_tuple("GpuBlendFactor::OneMinusSrcAlpha").finish()
            }
            GpuBlendFactor::Dst => {
              f.debug_tuple("GpuBlendFactor::Dst").finish()
            }
            GpuBlendFactor::OneMinusDst => {
              f.debug_tuple("GpuBlendFactor::OneMinusDst").finish()
            }
            GpuBlendFactor::DstAlpha => {
              f.debug_tuple("GpuBlendFactor::DstAlpha").finish()
            }
            GpuBlendFactor::OneMinusDstAlpha => {
              f.debug_tuple("GpuBlendFactor::OneMinusDstAlpha").finish()
            }
            GpuBlendFactor::SrcAlphaSaturated => {
              f.debug_tuple("GpuBlendFactor::SrcAlphaSaturated").finish()
            }
            GpuBlendFactor::Constant => {
              f.debug_tuple("GpuBlendFactor::Constant").finish()
            }
            GpuBlendFactor::OneMinusConstant => {
              f.debug_tuple("GpuBlendFactor::OneMinusConstant").finish()
            }
            GpuBlendFactor::Src1 => {
              f.debug_tuple("GpuBlendFactor::Src1").finish()
            }
            GpuBlendFactor::OneMinusSrc1 => {
              f.debug_tuple("GpuBlendFactor::OneMinusSrc1").finish()
            }
            GpuBlendFactor::Src1Alpha => {
              f.debug_tuple("GpuBlendFactor::Src1Alpha").finish()
            }
            GpuBlendFactor::OneMinusSrc1Alpha => {
              f.debug_tuple("GpuBlendFactor::OneMinusSrc1Alpha").finish()
            }
          }
        }
      }

      impl GpuBlendFactor{
        #[doc(hidden)]
        pub unsafe fn _lift(val: u8) -> GpuBlendFactor{
          if !cfg!(debug_assertions) {
            return unsafe { ::core::mem::transmute(val) };
          }

          match val {
            0 => GpuBlendFactor::Zero,
            1 => GpuBlendFactor::One,
            2 => GpuBlendFactor::Src,
            3 => GpuBlendFactor::OneMinusSrc,
            4 => GpuBlendFactor::SrcAlpha,
            5 => GpuBlendFactor::OneMinusSrcAlpha,
            6 => GpuBlendFactor::Dst,
            7 => GpuBlendFactor::OneMinusDst,
            8 => GpuBlendFactor::DstAlpha,
            9 => GpuBlendFactor::OneMinusDstAlpha,
            10 => GpuBlendFactor::SrcAlphaSaturated,
            11 => GpuBlendFactor::Constant,
            12 => GpuBlendFactor::OneMinusConstant,
            13 => GpuBlendFactor::Src1,
            14 => GpuBlendFactor::OneMinusSrc1,
            15 => GpuBlendFactor::Src1Alpha,
            16 => GpuBlendFactor::OneMinusSrc1Alpha,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }
      
      #[repr(u8)]
      #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
      pub enum GpuBlendOperation {
        Add,
        Subtract,
        ReverseSubtract,
        Min,
        Max,
      }
      impl ::core::fmt::Debug for GpuBlendOperation {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            GpuBlendOperation::Add => {
              f.debug_tuple("GpuBlendOperation::Add").finish()
            }
            GpuBlendOperation::Subtract => {
              f.debug_tuple("GpuBlendOperation::Subtract").finish()
            }
            GpuBlendOperation::ReverseSubtract => {
              f.debug_tuple("GpuBlendOperation::ReverseSubtract").finish()
            }
            GpuBlendOperation::Min => {
              f.debug_tuple("GpuBlendOperation::Min").finish()
            }
            GpuBlendOperation::Max => {
              f.debug_tuple("GpuBlendOperation::Max").finish()
            }
          }
        }
      }

      impl GpuBlendOperation{
        #[doc(hidden)]
        pub unsafe fn _lift(val: u8) -> GpuBlendOperation{
          if !cfg!(debug_assertions) {
            return unsafe { ::core::mem::transmute(val) };
          }

          match val {
            0 => GpuBlendOperation::Add,
            1 => GpuBlendOperation::Subtract,
            2 => GpuBlendOperation::ReverseSubtract,
            3 => GpuBlendOperation::Min,
            4 => GpuBlendOperation::Max,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }
      
      #[repr(C)]
      #[derive(Clone, Copy)]
      pub struct GpuBlendComponent {
        pub operation: Option<GpuBlendOperation>,
        pub src_factor: Option<GpuBlendFactor>,
        pub dst_factor: Option<GpuBlendFactor>,
      }
      impl ::core::fmt::Debug for GpuBlendComponent {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("GpuBlendComponent").field("operation", &self.operation).field("src-factor", &self.src_factor).field("dst-factor", &self.dst_factor).finish()
        }
      }
      #[repr(C)]
      #[derive(Clone, Copy)]
      pub struct GpuBlendState {
        pub color: GpuBlendComponent,
        pub alpha: GpuBlendComponent,
      }
      impl ::core::fmt::Debug for GpuBlendState {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("GpuBlendState").field("color", &self.color).field("alpha", &self.alpha).finish()
        }
      }
      #[repr(C)]
      #[derive(Clone, Copy)]
      pub struct GpuColorTargetState {
        pub format: GpuTextureFormat,
        pub blend: Option<GpuBlendState>,
        pub write_mask: Option<GpuColorWriteFlags>,
      }
      impl ::core::fmt::Debug for GpuColorTargetState {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("GpuColorTargetState").field("format", &self.format).field("blend", &self.blend).field("write-mask", &self.write_mask).finish()
        }
      }
      pub struct GpuFragmentState<'a,> {
        pub targets: _rt::Vec::<Option<GpuColorTargetState>>,
        pub module: &'a GpuShaderModule,
        pub entry_point: Option<_rt::String>,
        pub constants: Option<RecordGpuPipelineConstantValue>,
      }
      impl<'a,> ::core::fmt::Debug for GpuFragmentState<'a,> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("GpuFragmentState").field("targets", &self.targets).field("module", &self.module).field("entry-point", &self.entry_point).field("constants", &self.constants).finish()
        }
      }
      #[repr(u8)]
      #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
      pub enum GpuStencilOperation {
        Keep,
        Zero,
        Replace,
        Invert,
        IncrementClamp,
        DecrementClamp,
        IncrementWrap,
        DecrementWrap,
      }
      impl ::core::fmt::Debug for GpuStencilOperation {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            GpuStencilOperation::Keep => {
              f.debug_tuple("GpuStencilOperation::Keep").finish()
            }
            GpuStencilOperation::Zero => {
              f.debug_tuple("GpuStencilOperation::Zero").finish()
            }
            GpuStencilOperation::Replace => {
              f.debug_tuple("GpuStencilOperation::Replace").finish()
            }
            GpuStencilOperation::Invert => {
              f.debug_tuple("GpuStencilOperation::Invert").finish()
            }
            GpuStencilOperation::IncrementClamp => {
              f.debug_tuple("GpuStencilOperation::IncrementClamp").finish()
            }
            GpuStencilOperation::DecrementClamp => {
              f.debug_tuple("GpuStencilOperation::DecrementClamp").finish()
            }
            GpuStencilOperation::IncrementWrap => {
              f.debug_tuple("GpuStencilOperation::IncrementWrap").finish()
            }
            GpuStencilOperation::DecrementWrap => {
              f.debug_tuple("GpuStencilOperation::DecrementWrap").finish()
            }
          }
        }
      }

      impl GpuStencilOperation{
        #[doc(hidden)]
        pub unsafe fn _lift(val: u8) -> GpuStencilOperation{
          if !cfg!(debug_assertions) {
            return unsafe { ::core::mem::transmute(val) };
          }

          match val {
            0 => GpuStencilOperation::Keep,
            1 => GpuStencilOperation::Zero,
            2 => GpuStencilOperation::Replace,
            3 => GpuStencilOperation::Invert,
            4 => GpuStencilOperation::IncrementClamp,
            5 => GpuStencilOperation::DecrementClamp,
            6 => GpuStencilOperation::IncrementWrap,
            7 => GpuStencilOperation::DecrementWrap,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }
      
      #[repr(C)]
      #[derive(Clone, Copy)]
      pub struct GpuStencilFaceState {
        pub compare: Option<GpuCompareFunction>,
        pub fail_op: Option<GpuStencilOperation>,
        pub depth_fail_op: Option<GpuStencilOperation>,
        pub pass_op: Option<GpuStencilOperation>,
      }
      impl ::core::fmt::Debug for GpuStencilFaceState {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("GpuStencilFaceState").field("compare", &self.compare).field("fail-op", &self.fail_op).field("depth-fail-op", &self.depth_fail_op).field("pass-op", &self.pass_op).finish()
        }
      }
      #[repr(u8)]
      #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
      pub enum GpuIndexFormat {
        Uint16,
        Uint32,
      }
      impl ::core::fmt::Debug for GpuIndexFormat {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            GpuIndexFormat::Uint16 => {
              f.debug_tuple("GpuIndexFormat::Uint16").finish()
            }
            GpuIndexFormat::Uint32 => {
              f.debug_tuple("GpuIndexFormat::Uint32").finish()
            }
          }
        }
      }

      impl GpuIndexFormat{
        #[doc(hidden)]
        pub unsafe fn _lift(val: u8) -> GpuIndexFormat{
          if !cfg!(debug_assertions) {
            return unsafe { ::core::mem::transmute(val) };
          }

          match val {
            0 => GpuIndexFormat::Uint16,
            1 => GpuIndexFormat::Uint32,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }
      
      #[repr(C)]
      #[derive(Clone, Copy)]
      pub struct GpuPrimitiveState {
        pub topology: Option<GpuPrimitiveTopology>,
        pub strip_index_format: Option<GpuIndexFormat>,
        pub front_face: Option<GpuFrontFace>,
        pub cull_mode: Option<GpuCullMode>,
        pub unclipped_depth: Option<bool>,
      }
      impl ::core::fmt::Debug for GpuPrimitiveState {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("GpuPrimitiveState").field("topology", &self.topology).field("strip-index-format", &self.strip_index_format).field("front-face", &self.front_face).field("cull-mode", &self.cull_mode).field("unclipped-depth", &self.unclipped_depth).finish()
        }
      }
      #[repr(u8)]
      #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
      pub enum GpuVertexFormat {
        Uint8,
        Uint8x2,
        Uint8x4,
        Sint8,
        Sint8x2,
        Sint8x4,
        Unorm8,
        Unorm8x2,
        Unorm8x4,
        Snorm8,
        Snorm8x2,
        Snorm8x4,
        Uint16,
        Uint16x2,
        Uint16x4,
        Sint16,
        Sint16x2,
        Sint16x4,
        Unorm16,
        Unorm16x2,
        Unorm16x4,
        Snorm16,
        Snorm16x2,
        Snorm16x4,
        Float16,
        Float16x2,
        Float16x4,
        Float32,
        Float32x2,
        Float32x3,
        Float32x4,
        Uint32,
        Uint32x2,
        Uint32x3,
        Uint32x4,
        Sint32,
        Sint32x2,
        Sint32x3,
        Sint32x4,
        Unorm1010102,
        Unorm8x4Bgra,
      }
      impl ::core::fmt::Debug for GpuVertexFormat {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            GpuVertexFormat::Uint8 => {
              f.debug_tuple("GpuVertexFormat::Uint8").finish()
            }
            GpuVertexFormat::Uint8x2 => {
              f.debug_tuple("GpuVertexFormat::Uint8x2").finish()
            }
            GpuVertexFormat::Uint8x4 => {
              f.debug_tuple("GpuVertexFormat::Uint8x4").finish()
            }
            GpuVertexFormat::Sint8 => {
              f.debug_tuple("GpuVertexFormat::Sint8").finish()
            }
            GpuVertexFormat::Sint8x2 => {
              f.debug_tuple("GpuVertexFormat::Sint8x2").finish()
            }
            GpuVertexFormat::Sint8x4 => {
              f.debug_tuple("GpuVertexFormat::Sint8x4").finish()
            }
            GpuVertexFormat::Unorm8 => {
              f.debug_tuple("GpuVertexFormat::Unorm8").finish()
            }
            GpuVertexFormat::Unorm8x2 => {
              f.debug_tuple("GpuVertexFormat::Unorm8x2").finish()
            }
            GpuVertexFormat::Unorm8x4 => {
              f.debug_tuple("GpuVertexFormat::Unorm8x4").finish()
            }
            GpuVertexFormat::Snorm8 => {
              f.debug_tuple("GpuVertexFormat::Snorm8").finish()
            }
            GpuVertexFormat::Snorm8x2 => {
              f.debug_tuple("GpuVertexFormat::Snorm8x2").finish()
            }
            GpuVertexFormat::Snorm8x4 => {
              f.debug_tuple("GpuVertexFormat::Snorm8x4").finish()
            }
            GpuVertexFormat::Uint16 => {
              f.debug_tuple("GpuVertexFormat::Uint16").finish()
            }
            GpuVertexFormat::Uint16x2 => {
              f.debug_tuple("GpuVertexFormat::Uint16x2").finish()
            }
            GpuVertexFormat::Uint16x4 => {
              f.debug_tuple("GpuVertexFormat::Uint16x4").finish()
            }
            GpuVertexFormat::Sint16 => {
              f.debug_tuple("GpuVertexFormat::Sint16").finish()
            }
            GpuVertexFormat::Sint16x2 => {
              f.debug_tuple("GpuVertexFormat::Sint16x2").finish()
            }
            GpuVertexFormat::Sint16x4 => {
              f.debug_tuple("GpuVertexFormat::Sint16x4").finish()
            }
            GpuVertexFormat::Unorm16 => {
              f.debug_tuple("GpuVertexFormat::Unorm16").finish()
            }
            GpuVertexFormat::Unorm16x2 => {
              f.debug_tuple("GpuVertexFormat::Unorm16x2").finish()
            }
            GpuVertexFormat::Unorm16x4 => {
              f.debug_tuple("GpuVertexFormat::Unorm16x4").finish()
            }
            GpuVertexFormat::Snorm16 => {
              f.debug_tuple("GpuVertexFormat::Snorm16").finish()
            }
            GpuVertexFormat::Snorm16x2 => {
              f.debug_tuple("GpuVertexFormat::Snorm16x2").finish()
            }
            GpuVertexFormat::Snorm16x4 => {
              f.debug_tuple("GpuVertexFormat::Snorm16x4").finish()
            }
            GpuVertexFormat::Float16 => {
              f.debug_tuple("GpuVertexFormat::Float16").finish()
            }
            GpuVertexFormat::Float16x2 => {
              f.debug_tuple("GpuVertexFormat::Float16x2").finish()
            }
            GpuVertexFormat::Float16x4 => {
              f.debug_tuple("GpuVertexFormat::Float16x4").finish()
            }
            GpuVertexFormat::Float32 => {
              f.debug_tuple("GpuVertexFormat::Float32").finish()
            }
            GpuVertexFormat::Float32x2 => {
              f.debug_tuple("GpuVertexFormat::Float32x2").finish()
            }
            GpuVertexFormat::Float32x3 => {
              f.debug_tuple("GpuVertexFormat::Float32x3").finish()
            }
            GpuVertexFormat::Float32x4 => {
              f.debug_tuple("GpuVertexFormat::Float32x4").finish()
            }
            GpuVertexFormat::Uint32 => {
              f.debug_tuple("GpuVertexFormat::Uint32").finish()
            }
            GpuVertexFormat::Uint32x2 => {
              f.debug_tuple("GpuVertexFormat::Uint32x2").finish()
            }
            GpuVertexFormat::Uint32x3 => {
              f.debug_tuple("GpuVertexFormat::Uint32x3").finish()
            }
            GpuVertexFormat::Uint32x4 => {
              f.debug_tuple("GpuVertexFormat::Uint32x4").finish()
            }
            GpuVertexFormat::Sint32 => {
              f.debug_tuple("GpuVertexFormat::Sint32").finish()
            }
            GpuVertexFormat::Sint32x2 => {
              f.debug_tuple("GpuVertexFormat::Sint32x2").finish()
            }
            GpuVertexFormat::Sint32x3 => {
              f.debug_tuple("GpuVertexFormat::Sint32x3").finish()
            }
            GpuVertexFormat::Sint32x4 => {
              f.debug_tuple("GpuVertexFormat::Sint32x4").finish()
            }
            GpuVertexFormat::Unorm1010102 => {
              f.debug_tuple("GpuVertexFormat::Unorm1010102").finish()
            }
            GpuVertexFormat::Unorm8x4Bgra => {
              f.debug_tuple("GpuVertexFormat::Unorm8x4Bgra").finish()
            }
          }
        }
      }

      impl GpuVertexFormat{
        #[doc(hidden)]
        pub unsafe fn _lift(val: u8) -> GpuVertexFormat{
          if !cfg!(debug_assertions) {
            return unsafe { ::core::mem::transmute(val) };
          }

          match val {
            0 => GpuVertexFormat::Uint8,
            1 => GpuVertexFormat::Uint8x2,
            2 => GpuVertexFormat::Uint8x4,
            3 => GpuVertexFormat::Sint8,
            4 => GpuVertexFormat::Sint8x2,
            5 => GpuVertexFormat::Sint8x4,
            6 => GpuVertexFormat::Unorm8,
            7 => GpuVertexFormat::Unorm8x2,
            8 => GpuVertexFormat::Unorm8x4,
            9 => GpuVertexFormat::Snorm8,
            10 => GpuVertexFormat::Snorm8x2,
            11 => GpuVertexFormat::Snorm8x4,
            12 => GpuVertexFormat::Uint16,
            13 => GpuVertexFormat::Uint16x2,
            14 => GpuVertexFormat::Uint16x4,
            15 => GpuVertexFormat::Sint16,
            16 => GpuVertexFormat::Sint16x2,
            17 => GpuVertexFormat::Sint16x4,
            18 => GpuVertexFormat::Unorm16,
            19 => GpuVertexFormat::Unorm16x2,
            20 => GpuVertexFormat::Unorm16x4,
            21 => GpuVertexFormat::Snorm16,
            22 => GpuVertexFormat::Snorm16x2,
            23 => GpuVertexFormat::Snorm16x4,
            24 => GpuVertexFormat::Float16,
            25 => GpuVertexFormat::Float16x2,
            26 => GpuVertexFormat::Float16x4,
            27 => GpuVertexFormat::Float32,
            28 => GpuVertexFormat::Float32x2,
            29 => GpuVertexFormat::Float32x3,
            30 => GpuVertexFormat::Float32x4,
            31 => GpuVertexFormat::Uint32,
            32 => GpuVertexFormat::Uint32x2,
            33 => GpuVertexFormat::Uint32x3,
            34 => GpuVertexFormat::Uint32x4,
            35 => GpuVertexFormat::Sint32,
            36 => GpuVertexFormat::Sint32x2,
            37 => GpuVertexFormat::Sint32x3,
            38 => GpuVertexFormat::Sint32x4,
            39 => GpuVertexFormat::Unorm1010102,
            40 => GpuVertexFormat::Unorm8x4Bgra,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }
      
      #[repr(u8)]
      #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
      pub enum GpuVertexStepMode {
        Vertex,
        Instance,
      }
      impl ::core::fmt::Debug for GpuVertexStepMode {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            GpuVertexStepMode::Vertex => {
              f.debug_tuple("GpuVertexStepMode::Vertex").finish()
            }
            GpuVertexStepMode::Instance => {
              f.debug_tuple("GpuVertexStepMode::Instance").finish()
            }
          }
        }
      }

      impl GpuVertexStepMode{
        #[doc(hidden)]
        pub unsafe fn _lift(val: u8) -> GpuVertexStepMode{
          if !cfg!(debug_assertions) {
            return unsafe { ::core::mem::transmute(val) };
          }

          match val {
            0 => GpuVertexStepMode::Vertex,
            1 => GpuVertexStepMode::Instance,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }
      

      #[derive(Debug)]
      #[repr(transparent)]
      pub struct GpuCommandBuffer{
        handle: _rt::Resource<GpuCommandBuffer>,
      }

      impl GpuCommandBuffer{
        #[doc(hidden)]
        pub unsafe fn from_handle(handle: u32) -> Self {
          Self {
            handle: unsafe { _rt::Resource::from_handle(handle) },
          }
        }

        #[doc(hidden)]
        pub fn take_handle(&self) -> u32 {
          _rt::Resource::take_handle(&self.handle)
        }

        #[doc(hidden)]
        pub fn handle(&self) -> u32 {
          _rt::Resource::handle(&self.handle)
        }
      }
      

      unsafe impl _rt::WasmResource for GpuCommandBuffer{
        #[inline]
        unsafe fn drop(_handle: u32) {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
          unsafe extern "C" {
            #[link_name = "[resource-drop]gpu-command-buffer"]
            fn drop(_: i32, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn drop(_: i32, ) { unreachable!() }
          
          unsafe { drop(_handle as i32); }
        }
      }
      
      #[derive(Clone)]
      pub struct GpuCommandBufferDescriptor {
        pub label: Option<_rt::String>,
      }
      impl ::core::fmt::Debug for GpuCommandBufferDescriptor {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("GpuCommandBufferDescriptor").field("label", &self.label).finish()
        }
      }

      #[derive(Debug)]
      #[repr(transparent)]
      pub struct GpuCommandEncoder{
        handle: _rt::Resource<GpuCommandEncoder>,
      }

      impl GpuCommandEncoder{
        #[doc(hidden)]
        pub unsafe fn from_handle(handle: u32) -> Self {
          Self {
            handle: unsafe { _rt::Resource::from_handle(handle) },
          }
        }

        #[doc(hidden)]
        pub fn take_handle(&self) -> u32 {
          _rt::Resource::take_handle(&self.handle)
        }

        #[doc(hidden)]
        pub fn handle(&self) -> u32 {
          _rt::Resource::handle(&self.handle)
        }
      }
      

      unsafe impl _rt::WasmResource for GpuCommandEncoder{
        #[inline]
        unsafe fn drop(_handle: u32) {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
          unsafe extern "C" {
            #[link_name = "[resource-drop]gpu-command-encoder"]
            fn drop(_: i32, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn drop(_: i32, ) { unreachable!() }
          
          unsafe { drop(_handle as i32); }
        }
      }
      
      #[derive(Clone)]
      pub struct GpuCommandEncoderDescriptor {
        pub label: Option<_rt::String>,
      }
      impl ::core::fmt::Debug for GpuCommandEncoderDescriptor {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("GpuCommandEncoderDescriptor").field("label", &self.label).finish()
        }
      }

      #[derive(Debug)]
      #[repr(transparent)]
      pub struct GpuComputePassEncoder{
        handle: _rt::Resource<GpuComputePassEncoder>,
      }

      impl GpuComputePassEncoder{
        #[doc(hidden)]
        pub unsafe fn from_handle(handle: u32) -> Self {
          Self {
            handle: unsafe { _rt::Resource::from_handle(handle) },
          }
        }

        #[doc(hidden)]
        pub fn take_handle(&self) -> u32 {
          _rt::Resource::take_handle(&self.handle)
        }

        #[doc(hidden)]
        pub fn handle(&self) -> u32 {
          _rt::Resource::handle(&self.handle)
        }
      }
      

      unsafe impl _rt::WasmResource for GpuComputePassEncoder{
        #[inline]
        unsafe fn drop(_handle: u32) {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
          unsafe extern "C" {
            #[link_name = "[resource-drop]gpu-compute-pass-encoder"]
            fn drop(_: i32, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn drop(_: i32, ) { unreachable!() }
          
          unsafe { drop(_handle as i32); }
        }
      }
      

      #[derive(Debug)]
      #[repr(transparent)]
      pub struct GpuRenderPassEncoder{
        handle: _rt::Resource<GpuRenderPassEncoder>,
      }

      impl GpuRenderPassEncoder{
        #[doc(hidden)]
        pub unsafe fn from_handle(handle: u32) -> Self {
          Self {
            handle: unsafe { _rt::Resource::from_handle(handle) },
          }
        }

        #[doc(hidden)]
        pub fn take_handle(&self) -> u32 {
          _rt::Resource::take_handle(&self.handle)
        }

        #[doc(hidden)]
        pub fn handle(&self) -> u32 {
          _rt::Resource::handle(&self.handle)
        }
      }
      

      unsafe impl _rt::WasmResource for GpuRenderPassEncoder{
        #[inline]
        unsafe fn drop(_handle: u32) {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
          unsafe extern "C" {
            #[link_name = "[resource-drop]gpu-render-pass-encoder"]
            fn drop(_: i32, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn drop(_: i32, ) { unreachable!() }
          
          unsafe { drop(_handle as i32); }
        }
      }
      
      #[repr(u8)]
      #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
      pub enum GpuLoadOp {
        Load,
        Clear,
      }
      impl ::core::fmt::Debug for GpuLoadOp {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            GpuLoadOp::Load => {
              f.debug_tuple("GpuLoadOp::Load").finish()
            }
            GpuLoadOp::Clear => {
              f.debug_tuple("GpuLoadOp::Clear").finish()
            }
          }
        }
      }

      impl GpuLoadOp{
        #[doc(hidden)]
        pub unsafe fn _lift(val: u8) -> GpuLoadOp{
          if !cfg!(debug_assertions) {
            return unsafe { ::core::mem::transmute(val) };
          }

          match val {
            0 => GpuLoadOp::Load,
            1 => GpuLoadOp::Clear,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }
      
      #[repr(u8)]
      #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
      pub enum GpuStoreOp {
        Store,
        Discard,
      }
      impl ::core::fmt::Debug for GpuStoreOp {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            GpuStoreOp::Store => {
              f.debug_tuple("GpuStoreOp::Store").finish()
            }
            GpuStoreOp::Discard => {
              f.debug_tuple("GpuStoreOp::Discard").finish()
            }
          }
        }
      }

      impl GpuStoreOp{
        #[doc(hidden)]
        pub unsafe fn _lift(val: u8) -> GpuStoreOp{
          if !cfg!(debug_assertions) {
            return unsafe { ::core::mem::transmute(val) };
          }

          match val {
            0 => GpuStoreOp::Store,
            1 => GpuStoreOp::Discard,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }
      

      #[derive(Debug)]
      #[repr(transparent)]
      pub struct GpuRenderBundle{
        handle: _rt::Resource<GpuRenderBundle>,
      }

      impl GpuRenderBundle{
        #[doc(hidden)]
        pub unsafe fn from_handle(handle: u32) -> Self {
          Self {
            handle: unsafe { _rt::Resource::from_handle(handle) },
          }
        }

        #[doc(hidden)]
        pub fn take_handle(&self) -> u32 {
          _rt::Resource::take_handle(&self.handle)
        }

        #[doc(hidden)]
        pub fn handle(&self) -> u32 {
          _rt::Resource::handle(&self.handle)
        }
      }
      

      unsafe impl _rt::WasmResource for GpuRenderBundle{
        #[inline]
        unsafe fn drop(_handle: u32) {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
          unsafe extern "C" {
            #[link_name = "[resource-drop]gpu-render-bundle"]
            fn drop(_: i32, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn drop(_: i32, ) { unreachable!() }
          
          unsafe { drop(_handle as i32); }
        }
      }
      
      #[derive(Clone)]
      pub struct GpuRenderBundleDescriptor {
        pub label: Option<_rt::String>,
      }
      impl ::core::fmt::Debug for GpuRenderBundleDescriptor {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("GpuRenderBundleDescriptor").field("label", &self.label).finish()
        }
      }

      #[derive(Debug)]
      #[repr(transparent)]
      pub struct GpuRenderBundleEncoder{
        handle: _rt::Resource<GpuRenderBundleEncoder>,
      }

      impl GpuRenderBundleEncoder{
        #[doc(hidden)]
        pub unsafe fn from_handle(handle: u32) -> Self {
          Self {
            handle: unsafe { _rt::Resource::from_handle(handle) },
          }
        }

        #[doc(hidden)]
        pub fn take_handle(&self) -> u32 {
          _rt::Resource::take_handle(&self.handle)
        }

        #[doc(hidden)]
        pub fn handle(&self) -> u32 {
          _rt::Resource::handle(&self.handle)
        }
      }
      

      unsafe impl _rt::WasmResource for GpuRenderBundleEncoder{
        #[inline]
        unsafe fn drop(_handle: u32) {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
          unsafe extern "C" {
            #[link_name = "[resource-drop]gpu-render-bundle-encoder"]
            fn drop(_: i32, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn drop(_: i32, ) { unreachable!() }
          
          unsafe { drop(_handle as i32); }
        }
      }
      
      #[derive(Clone)]
      pub struct GpuQueueDescriptor {
        pub label: Option<_rt::String>,
      }
      impl ::core::fmt::Debug for GpuQueueDescriptor {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("GpuQueueDescriptor").field("label", &self.label).finish()
        }
      }
      pub struct GpuDeviceDescriptor {
        pub required_features: Option<_rt::Vec::<GpuFeatureName>>,
        pub required_limits: Option<RecordOptionGpuSize64>,
        pub default_queue: Option<GpuQueueDescriptor>,
        pub label: Option<_rt::String>,
      }
      impl ::core::fmt::Debug for GpuDeviceDescriptor {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("GpuDeviceDescriptor").field("required-features", &self.required_features).field("required-limits", &self.required_limits).field("default-queue", &self.default_queue).field("label", &self.label).finish()
        }
      }

      #[derive(Debug)]
      #[repr(transparent)]
      pub struct GpuQueue{
        handle: _rt::Resource<GpuQueue>,
      }

      impl GpuQueue{
        #[doc(hidden)]
        pub unsafe fn from_handle(handle: u32) -> Self {
          Self {
            handle: unsafe { _rt::Resource::from_handle(handle) },
          }
        }

        #[doc(hidden)]
        pub fn take_handle(&self) -> u32 {
          _rt::Resource::take_handle(&self.handle)
        }

        #[doc(hidden)]
        pub fn handle(&self) -> u32 {
          _rt::Resource::handle(&self.handle)
        }
      }
      

      unsafe impl _rt::WasmResource for GpuQueue{
        #[inline]
        unsafe fn drop(_handle: u32) {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
          unsafe extern "C" {
            #[link_name = "[resource-drop]gpu-queue"]
            fn drop(_: i32, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn drop(_: i32, ) { unreachable!() }
          
          unsafe { drop(_handle as i32); }
        }
      }
      

      #[derive(Debug)]
      #[repr(transparent)]
      pub struct GpuQuerySet{
        handle: _rt::Resource<GpuQuerySet>,
      }

      impl GpuQuerySet{
        #[doc(hidden)]
        pub unsafe fn from_handle(handle: u32) -> Self {
          Self {
            handle: unsafe { _rt::Resource::from_handle(handle) },
          }
        }

        #[doc(hidden)]
        pub fn take_handle(&self) -> u32 {
          _rt::Resource::take_handle(&self.handle)
        }

        #[doc(hidden)]
        pub fn handle(&self) -> u32 {
          _rt::Resource::handle(&self.handle)
        }
      }
      

      unsafe impl _rt::WasmResource for GpuQuerySet{
        #[inline]
        unsafe fn drop(_handle: u32) {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
          unsafe extern "C" {
            #[link_name = "[resource-drop]gpu-query-set"]
            fn drop(_: i32, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn drop(_: i32, ) { unreachable!() }
          
          unsafe { drop(_handle as i32); }
        }
      }
      
      #[repr(u8)]
      #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
      pub enum GpuQueryType {
        Occlusion,
        Timestamp,
      }
      impl ::core::fmt::Debug for GpuQueryType {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            GpuQueryType::Occlusion => {
              f.debug_tuple("GpuQueryType::Occlusion").finish()
            }
            GpuQueryType::Timestamp => {
              f.debug_tuple("GpuQueryType::Timestamp").finish()
            }
          }
        }
      }

      impl GpuQueryType{
        #[doc(hidden)]
        pub unsafe fn _lift(val: u8) -> GpuQueryType{
          if !cfg!(debug_assertions) {
            return unsafe { ::core::mem::transmute(val) };
          }

          match val {
            0 => GpuQueryType::Occlusion,
            1 => GpuQueryType::Timestamp,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }
      

      #[derive(Debug)]
      #[repr(transparent)]
      pub struct GpuCanvasContext{
        handle: _rt::Resource<GpuCanvasContext>,
      }

      impl GpuCanvasContext{
        #[doc(hidden)]
        pub unsafe fn from_handle(handle: u32) -> Self {
          Self {
            handle: unsafe { _rt::Resource::from_handle(handle) },
          }
        }

        #[doc(hidden)]
        pub fn take_handle(&self) -> u32 {
          _rt::Resource::take_handle(&self.handle)
        }

        #[doc(hidden)]
        pub fn handle(&self) -> u32 {
          _rt::Resource::handle(&self.handle)
        }
      }
      

      unsafe impl _rt::WasmResource for GpuCanvasContext{
        #[inline]
        unsafe fn drop(_handle: u32) {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
          unsafe extern "C" {
            #[link_name = "[resource-drop]gpu-canvas-context"]
            fn drop(_: i32, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn drop(_: i32, ) { unreachable!() }
          
          unsafe { drop(_handle as i32); }
        }
      }
      
      #[repr(u8)]
      #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
      pub enum GpuCanvasAlphaMode {
        Opaque,
        Premultiplied,
      }
      impl ::core::fmt::Debug for GpuCanvasAlphaMode {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            GpuCanvasAlphaMode::Opaque => {
              f.debug_tuple("GpuCanvasAlphaMode::Opaque").finish()
            }
            GpuCanvasAlphaMode::Premultiplied => {
              f.debug_tuple("GpuCanvasAlphaMode::Premultiplied").finish()
            }
          }
        }
      }

      impl GpuCanvasAlphaMode{
        #[doc(hidden)]
        pub unsafe fn _lift(val: u8) -> GpuCanvasAlphaMode{
          if !cfg!(debug_assertions) {
            return unsafe { ::core::mem::transmute(val) };
          }

          match val {
            0 => GpuCanvasAlphaMode::Opaque,
            1 => GpuCanvasAlphaMode::Premultiplied,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }
      
      #[repr(u8)]
      #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
      pub enum GpuCanvasToneMappingMode {
        Standard,
        Extended,
      }
      impl ::core::fmt::Debug for GpuCanvasToneMappingMode {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            GpuCanvasToneMappingMode::Standard => {
              f.debug_tuple("GpuCanvasToneMappingMode::Standard").finish()
            }
            GpuCanvasToneMappingMode::Extended => {
              f.debug_tuple("GpuCanvasToneMappingMode::Extended").finish()
            }
          }
        }
      }

      impl GpuCanvasToneMappingMode{
        #[doc(hidden)]
        pub unsafe fn _lift(val: u8) -> GpuCanvasToneMappingMode{
          if !cfg!(debug_assertions) {
            return unsafe { ::core::mem::transmute(val) };
          }

          match val {
            0 => GpuCanvasToneMappingMode::Standard,
            1 => GpuCanvasToneMappingMode::Extended,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }
      
      #[repr(C)]
      #[derive(Clone, Copy)]
      pub struct GpuCanvasToneMapping {
        pub mode: Option<GpuCanvasToneMappingMode>,
      }
      impl ::core::fmt::Debug for GpuCanvasToneMapping {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("GpuCanvasToneMapping").field("mode", &self.mode).finish()
        }
      }
      #[repr(u8)]
      #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
      pub enum GpuDeviceLostReason {
        Unknown,
        Destroyed,
      }
      impl ::core::fmt::Debug for GpuDeviceLostReason {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            GpuDeviceLostReason::Unknown => {
              f.debug_tuple("GpuDeviceLostReason::Unknown").finish()
            }
            GpuDeviceLostReason::Destroyed => {
              f.debug_tuple("GpuDeviceLostReason::Destroyed").finish()
            }
          }
        }
      }

      impl GpuDeviceLostReason{
        #[doc(hidden)]
        pub unsafe fn _lift(val: u8) -> GpuDeviceLostReason{
          if !cfg!(debug_assertions) {
            return unsafe { ::core::mem::transmute(val) };
          }

          match val {
            0 => GpuDeviceLostReason::Unknown,
            1 => GpuDeviceLostReason::Destroyed,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }
      

      #[derive(Debug)]
      #[repr(transparent)]
      pub struct GpuDeviceLostInfo{
        handle: _rt::Resource<GpuDeviceLostInfo>,
      }

      impl GpuDeviceLostInfo{
        #[doc(hidden)]
        pub unsafe fn from_handle(handle: u32) -> Self {
          Self {
            handle: unsafe { _rt::Resource::from_handle(handle) },
          }
        }

        #[doc(hidden)]
        pub fn take_handle(&self) -> u32 {
          _rt::Resource::take_handle(&self.handle)
        }

        #[doc(hidden)]
        pub fn handle(&self) -> u32 {
          _rt::Resource::handle(&self.handle)
        }
      }
      

      unsafe impl _rt::WasmResource for GpuDeviceLostInfo{
        #[inline]
        unsafe fn drop(_handle: u32) {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
          unsafe extern "C" {
            #[link_name = "[resource-drop]gpu-device-lost-info"]
            fn drop(_: i32, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn drop(_: i32, ) { unreachable!() }
          
          unsafe { drop(_handle as i32); }
        }
      }
      

      #[derive(Debug)]
      #[repr(transparent)]
      pub struct GpuError{
        handle: _rt::Resource<GpuError>,
      }

      impl GpuError{
        #[doc(hidden)]
        pub unsafe fn from_handle(handle: u32) -> Self {
          Self {
            handle: unsafe { _rt::Resource::from_handle(handle) },
          }
        }

        #[doc(hidden)]
        pub fn take_handle(&self) -> u32 {
          _rt::Resource::take_handle(&self.handle)
        }

        #[doc(hidden)]
        pub fn handle(&self) -> u32 {
          _rt::Resource::handle(&self.handle)
        }
      }
      

      unsafe impl _rt::WasmResource for GpuError{
        #[inline]
        unsafe fn drop(_handle: u32) {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
          unsafe extern "C" {
            #[link_name = "[resource-drop]gpu-error"]
            fn drop(_: i32, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn drop(_: i32, ) { unreachable!() }
          
          unsafe { drop(_handle as i32); }
        }
      }
      
      #[repr(u8)]
      #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
      pub enum GpuErrorFilter {
        Validation,
        OutOfMemory,
        Internal,
      }
      impl ::core::fmt::Debug for GpuErrorFilter {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            GpuErrorFilter::Validation => {
              f.debug_tuple("GpuErrorFilter::Validation").finish()
            }
            GpuErrorFilter::OutOfMemory => {
              f.debug_tuple("GpuErrorFilter::OutOfMemory").finish()
            }
            GpuErrorFilter::Internal => {
              f.debug_tuple("GpuErrorFilter::Internal").finish()
            }
          }
        }
      }

      impl GpuErrorFilter{
        #[doc(hidden)]
        pub unsafe fn _lift(val: u8) -> GpuErrorFilter{
          if !cfg!(debug_assertions) {
            return unsafe { ::core::mem::transmute(val) };
          }

          match val {
            0 => GpuErrorFilter::Validation,
            1 => GpuErrorFilter::OutOfMemory,
            2 => GpuErrorFilter::Internal,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }
      

      #[derive(Debug)]
      #[repr(transparent)]
      pub struct GpuUncapturedErrorEvent{
        handle: _rt::Resource<GpuUncapturedErrorEvent>,
      }

      impl GpuUncapturedErrorEvent{
        #[doc(hidden)]
        pub unsafe fn from_handle(handle: u32) -> Self {
          Self {
            handle: unsafe { _rt::Resource::from_handle(handle) },
          }
        }

        #[doc(hidden)]
        pub fn take_handle(&self) -> u32 {
          _rt::Resource::take_handle(&self.handle)
        }

        #[doc(hidden)]
        pub fn handle(&self) -> u32 {
          _rt::Resource::handle(&self.handle)
        }
      }
      

      unsafe impl _rt::WasmResource for GpuUncapturedErrorEvent{
        #[inline]
        unsafe fn drop(_handle: u32) {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
          unsafe extern "C" {
            #[link_name = "[resource-drop]gpu-uncaptured-error-event"]
            fn drop(_: i32, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn drop(_: i32, ) { unreachable!() }
          
          unsafe { drop(_handle as i32); }
        }
      }
      
      pub type GpuBufferDynamicOffset = u32;
      pub type GpuStencilValue = u32;
      pub struct GpuRenderPassDepthStencilAttachment<'a,> {
        pub view: &'a GpuTextureView,
        pub depth_clear_value: Option<f32>,
        pub depth_load_op: Option<GpuLoadOp>,
        pub depth_store_op: Option<GpuStoreOp>,
        pub depth_read_only: Option<bool>,
        pub stencil_clear_value: Option<GpuStencilValue>,
        pub stencil_load_op: Option<GpuLoadOp>,
        pub stencil_store_op: Option<GpuStoreOp>,
        pub stencil_read_only: Option<bool>,
      }
      impl<'a,> ::core::fmt::Debug for GpuRenderPassDepthStencilAttachment<'a,> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("GpuRenderPassDepthStencilAttachment").field("view", &self.view).field("depth-clear-value", &self.depth_clear_value).field("depth-load-op", &self.depth_load_op).field("depth-store-op", &self.depth_store_op).field("depth-read-only", &self.depth_read_only).field("stencil-clear-value", &self.stencil_clear_value).field("stencil-load-op", &self.stencil_load_op).field("stencil-store-op", &self.stencil_store_op).field("stencil-read-only", &self.stencil_read_only).finish()
        }
      }
      pub type GpuSampleMask = u32;
      pub type GpuDepthBias = i32;
      #[repr(C)]
      #[derive(Clone, Copy)]
      pub struct GpuDepthStencilState {
        pub format: GpuTextureFormat,
        pub depth_write_enabled: Option<bool>,
        pub depth_compare: Option<GpuCompareFunction>,
        pub stencil_front: Option<GpuStencilFaceState>,
        pub stencil_back: Option<GpuStencilFaceState>,
        pub stencil_read_mask: Option<GpuStencilValue>,
        pub stencil_write_mask: Option<GpuStencilValue>,
        pub depth_bias: Option<GpuDepthBias>,
        pub depth_bias_slope_scale: Option<f32>,
        pub depth_bias_clamp: Option<f32>,
      }
      impl ::core::fmt::Debug for GpuDepthStencilState {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("GpuDepthStencilState").field("format", &self.format).field("depth-write-enabled", &self.depth_write_enabled).field("depth-compare", &self.depth_compare).field("stencil-front", &self.stencil_front).field("stencil-back", &self.stencil_back).field("stencil-read-mask", &self.stencil_read_mask).field("stencil-write-mask", &self.stencil_write_mask).field("depth-bias", &self.depth_bias).field("depth-bias-slope-scale", &self.depth_bias_slope_scale).field("depth-bias-clamp", &self.depth_bias_clamp).finish()
        }
      }
      pub type GpuSize64 = u64;
      #[derive(Clone)]
      pub struct GpuBufferDescriptor {
        pub size: GpuSize64,
        pub usage: GpuBufferUsageFlags,
        pub mapped_at_creation: Option<bool>,
        pub label: Option<_rt::String>,
      }
      impl ::core::fmt::Debug for GpuBufferDescriptor {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("GpuBufferDescriptor").field("size", &self.size).field("usage", &self.usage).field("mapped-at-creation", &self.mapped_at_creation).field("label", &self.label).finish()
        }
      }
      #[repr(C)]
      #[derive(Clone, Copy)]
      pub struct GpuBufferBindingLayout {
        pub type_: Option<GpuBufferBindingType>,
        pub has_dynamic_offset: Option<bool>,
        pub min_binding_size: Option<GpuSize64>,
      }
      impl ::core::fmt::Debug for GpuBufferBindingLayout {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("GpuBufferBindingLayout").field("type", &self.type_).field("has-dynamic-offset", &self.has_dynamic_offset).field("min-binding-size", &self.min_binding_size).finish()
        }
      }
      pub struct GpuBufferBinding<'a,> {
        pub buffer: &'a GpuBuffer,
        pub offset: Option<GpuSize64>,
        pub size: Option<GpuSize64>,
      }
      impl<'a,> ::core::fmt::Debug for GpuBufferBinding<'a,> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("GpuBufferBinding").field("buffer", &self.buffer).field("offset", &self.offset).field("size", &self.size).finish()
        }
      }
      pub enum GpuBindingResource<'a,> {
        GpuBufferBinding(GpuBufferBinding<'a,>),
        GpuSampler(&'a GpuSampler),
        GpuTextureView(&'a GpuTextureView),
      }
      impl<'a,> ::core::fmt::Debug for GpuBindingResource<'a,> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            GpuBindingResource::GpuBufferBinding(e) => {
              f.debug_tuple("GpuBindingResource::GpuBufferBinding").field(e).finish()
            }
            GpuBindingResource::GpuSampler(e) => {
              f.debug_tuple("GpuBindingResource::GpuSampler").field(e).finish()
            }
            GpuBindingResource::GpuTextureView(e) => {
              f.debug_tuple("GpuBindingResource::GpuTextureView").field(e).finish()
            }
          }
        }
      }
      pub type GpuIntegerCoordinate = u32;
      #[derive(Clone)]
      pub struct GpuTextureViewDescriptor {
        pub format: Option<GpuTextureFormat>,
        pub dimension: Option<GpuTextureViewDimension>,
        pub usage: Option<GpuTextureUsageFlags>,
        pub aspect: Option<GpuTextureAspect>,
        pub base_mip_level: Option<GpuIntegerCoordinate>,
        pub mip_level_count: Option<GpuIntegerCoordinate>,
        pub base_array_layer: Option<GpuIntegerCoordinate>,
        pub array_layer_count: Option<GpuIntegerCoordinate>,
        pub label: Option<_rt::String>,
      }
      impl ::core::fmt::Debug for GpuTextureViewDescriptor {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("GpuTextureViewDescriptor").field("format", &self.format).field("dimension", &self.dimension).field("usage", &self.usage).field("aspect", &self.aspect).field("base-mip-level", &self.base_mip_level).field("mip-level-count", &self.mip_level_count).field("base-array-layer", &self.base_array_layer).field("array-layer-count", &self.array_layer_count).field("label", &self.label).finish()
        }
      }
      pub type GpuIndex32 = u32;
      #[repr(C)]
      #[derive(Clone, Copy)]
      pub struct GpuBindGroupLayoutEntry {
        pub binding: GpuIndex32,
        pub visibility: GpuShaderStageFlags,
        pub buffer: Option<GpuBufferBindingLayout>,
        pub sampler: Option<GpuSamplerBindingLayout>,
        pub texture: Option<GpuTextureBindingLayout>,
        pub storage_texture: Option<GpuStorageTextureBindingLayout>,
      }
      impl ::core::fmt::Debug for GpuBindGroupLayoutEntry {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("GpuBindGroupLayoutEntry").field("binding", &self.binding).field("visibility", &self.visibility).field("buffer", &self.buffer).field("sampler", &self.sampler).field("texture", &self.texture).field("storage-texture", &self.storage_texture).finish()
        }
      }
      #[derive(Clone)]
      pub struct GpuBindGroupLayoutDescriptor {
        pub entries: _rt::Vec::<GpuBindGroupLayoutEntry>,
        pub label: Option<_rt::String>,
      }
      impl ::core::fmt::Debug for GpuBindGroupLayoutDescriptor {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("GpuBindGroupLayoutDescriptor").field("entries", &self.entries).field("label", &self.label).finish()
        }
      }
      pub struct GpuBindGroupEntry<'a,> {
        pub binding: GpuIndex32,
        pub resource: GpuBindingResource<'a,>,
      }
      impl<'a,> ::core::fmt::Debug for GpuBindGroupEntry<'a,> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("GpuBindGroupEntry").field("binding", &self.binding).field("resource", &self.resource).finish()
        }
      }
      pub struct GpuBindGroupDescriptor<'a,> {
        pub layout: &'a GpuBindGroupLayout,
        pub entries: _rt::Vec::<GpuBindGroupEntry<'a,>>,
        pub label: Option<_rt::String>,
      }
      impl<'a,> ::core::fmt::Debug for GpuBindGroupDescriptor<'a,> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("GpuBindGroupDescriptor").field("layout", &self.layout).field("entries", &self.entries).field("label", &self.label).finish()
        }
      }
      #[repr(C)]
      #[derive(Clone, Copy)]
      pub struct GpuVertexAttribute {
        pub format: GpuVertexFormat,
        pub offset: GpuSize64,
        pub shader_location: GpuIndex32,
      }
      impl ::core::fmt::Debug for GpuVertexAttribute {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("GpuVertexAttribute").field("format", &self.format).field("offset", &self.offset).field("shader-location", &self.shader_location).finish()
        }
      }
      #[derive(Clone)]
      pub struct GpuVertexBufferLayout {
        pub array_stride: GpuSize64,
        pub step_mode: Option<GpuVertexStepMode>,
        pub attributes: _rt::Vec::<GpuVertexAttribute>,
      }
      impl ::core::fmt::Debug for GpuVertexBufferLayout {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("GpuVertexBufferLayout").field("array-stride", &self.array_stride).field("step-mode", &self.step_mode).field("attributes", &self.attributes).finish()
        }
      }
      pub struct GpuVertexState<'a,> {
        pub buffers: Option<_rt::Vec::<Option<GpuVertexBufferLayout>>>,
        pub module: &'a GpuShaderModule,
        pub entry_point: Option<_rt::String>,
        pub constants: Option<RecordGpuPipelineConstantValue>,
      }
      impl<'a,> ::core::fmt::Debug for GpuVertexState<'a,> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("GpuVertexState").field("buffers", &self.buffers).field("module", &self.module).field("entry-point", &self.entry_point).field("constants", &self.constants).finish()
        }
      }
      pub type GpuSize32 = u32;
      #[repr(C)]
      #[derive(Clone, Copy)]
      pub struct GpuMultisampleState {
        pub count: Option<GpuSize32>,
        pub mask: Option<GpuSampleMask>,
        pub alpha_to_coverage_enabled: Option<bool>,
      }
      impl ::core::fmt::Debug for GpuMultisampleState {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("GpuMultisampleState").field("count", &self.count).field("mask", &self.mask).field("alpha-to-coverage-enabled", &self.alpha_to_coverage_enabled).finish()
        }
      }
      pub struct GpuRenderPipelineDescriptor<'a,> {
        pub vertex: GpuVertexState<'a,>,
        pub primitive: Option<GpuPrimitiveState>,
        pub depth_stencil: Option<GpuDepthStencilState>,
        pub multisample: Option<GpuMultisampleState>,
        pub fragment: Option<GpuFragmentState<'a,>>,
        pub layout: GpuLayoutMode<'a,>,
        pub label: Option<_rt::String>,
      }
      impl<'a,> ::core::fmt::Debug for GpuRenderPipelineDescriptor<'a,> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("GpuRenderPipelineDescriptor").field("vertex", &self.vertex).field("primitive", &self.primitive).field("depth-stencil", &self.depth_stencil).field("multisample", &self.multisample).field("fragment", &self.fragment).field("layout", &self.layout).field("label", &self.label).finish()
        }
      }
      #[repr(C)]
      #[derive(Clone, Copy)]
      pub struct GpuTexelCopyBufferLayout {
        pub offset: Option<GpuSize64>,
        pub bytes_per_row: Option<GpuSize32>,
        pub rows_per_image: Option<GpuSize32>,
      }
      impl ::core::fmt::Debug for GpuTexelCopyBufferLayout {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("GpuTexelCopyBufferLayout").field("offset", &self.offset).field("bytes-per-row", &self.bytes_per_row).field("rows-per-image", &self.rows_per_image).finish()
        }
      }
      pub struct GpuTexelCopyBufferInfo<'a,> {
        pub buffer: &'a GpuBuffer,
        pub offset: Option<GpuSize64>,
        pub bytes_per_row: Option<GpuSize32>,
        pub rows_per_image: Option<GpuSize32>,
      }
      impl<'a,> ::core::fmt::Debug for GpuTexelCopyBufferInfo<'a,> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("GpuTexelCopyBufferInfo").field("buffer", &self.buffer).field("offset", &self.offset).field("bytes-per-row", &self.bytes_per_row).field("rows-per-image", &self.rows_per_image).finish()
        }
      }
      pub struct GpuComputePassTimestampWrites<'a,> {
        pub query_set: &'a GpuQuerySet,
        pub beginning_of_pass_write_index: Option<GpuSize32>,
        pub end_of_pass_write_index: Option<GpuSize32>,
      }
      impl<'a,> ::core::fmt::Debug for GpuComputePassTimestampWrites<'a,> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("GpuComputePassTimestampWrites").field("query-set", &self.query_set).field("beginning-of-pass-write-index", &self.beginning_of_pass_write_index).field("end-of-pass-write-index", &self.end_of_pass_write_index).finish()
        }
      }
      pub struct GpuComputePassDescriptor<'a,> {
        pub timestamp_writes: Option<GpuComputePassTimestampWrites<'a,>>,
        pub label: Option<_rt::String>,
      }
      impl<'a,> ::core::fmt::Debug for GpuComputePassDescriptor<'a,> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("GpuComputePassDescriptor").field("timestamp-writes", &self.timestamp_writes).field("label", &self.label).finish()
        }
      }
      pub struct GpuRenderPassTimestampWrites<'a,> {
        pub query_set: &'a GpuQuerySet,
        pub beginning_of_pass_write_index: Option<GpuSize32>,
        pub end_of_pass_write_index: Option<GpuSize32>,
      }
      impl<'a,> ::core::fmt::Debug for GpuRenderPassTimestampWrites<'a,> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("GpuRenderPassTimestampWrites").field("query-set", &self.query_set).field("beginning-of-pass-write-index", &self.beginning_of_pass_write_index).field("end-of-pass-write-index", &self.end_of_pass_write_index).finish()
        }
      }
      #[derive(Clone)]
      pub struct GpuRenderBundleEncoderDescriptor {
        pub depth_read_only: Option<bool>,
        pub stencil_read_only: Option<bool>,
        pub color_formats: _rt::Vec::<Option<GpuTextureFormat>>,
        pub depth_stencil_format: Option<GpuTextureFormat>,
        pub sample_count: Option<GpuSize32>,
        pub label: Option<_rt::String>,
      }
      impl ::core::fmt::Debug for GpuRenderBundleEncoderDescriptor {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("GpuRenderBundleEncoderDescriptor").field("depth-read-only", &self.depth_read_only).field("stencil-read-only", &self.stencil_read_only).field("color-formats", &self.color_formats).field("depth-stencil-format", &self.depth_stencil_format).field("sample-count", &self.sample_count).field("label", &self.label).finish()
        }
      }
      #[derive(Clone)]
      pub struct GpuQuerySetDescriptor {
        pub type_: GpuQueryType,
        pub count: GpuSize32,
        pub label: Option<_rt::String>,
      }
      impl ::core::fmt::Debug for GpuQuerySetDescriptor {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("GpuQuerySetDescriptor").field("type", &self.type_).field("count", &self.count).field("label", &self.label).finish()
        }
      }
      pub type GpuSignedOffset32 = i32;
      pub type GpuSize64Out = u64;
      pub type GpuIntegerCoordinateOut = u32;
      pub type GpuSize32Out = u32;
      pub type GpuFlagsConstant = u32;
      #[repr(C)]
      #[derive(Clone, Copy)]
      pub struct GpuColor {
        pub r: f64,
        pub g: f64,
        pub b: f64,
        pub a: f64,
      }
      impl ::core::fmt::Debug for GpuColor {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("GpuColor").field("r", &self.r).field("g", &self.g).field("b", &self.b).field("a", &self.a).finish()
        }
      }
      pub struct GpuRenderPassColorAttachment<'a,> {
        pub view: &'a GpuTextureView,
        pub depth_slice: Option<GpuIntegerCoordinate>,
        pub resolve_target: Option<&'a GpuTextureView>,
        pub clear_value: Option<GpuColor>,
        pub load_op: GpuLoadOp,
        pub store_op: GpuStoreOp,
      }
      impl<'a,> ::core::fmt::Debug for GpuRenderPassColorAttachment<'a,> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("GpuRenderPassColorAttachment").field("view", &self.view).field("depth-slice", &self.depth_slice).field("resolve-target", &self.resolve_target).field("clear-value", &self.clear_value).field("load-op", &self.load_op).field("store-op", &self.store_op).finish()
        }
      }
      pub struct GpuRenderPassDescriptor<'a,> {
        pub color_attachments: _rt::Vec::<Option<GpuRenderPassColorAttachment<'a,>>>,
        pub depth_stencil_attachment: Option<GpuRenderPassDepthStencilAttachment<'a,>>,
        pub occlusion_query_set: Option<&'a GpuQuerySet>,
        pub timestamp_writes: Option<GpuRenderPassTimestampWrites<'a,>>,
        pub max_draw_count: Option<GpuSize64>,
        pub label: Option<_rt::String>,
      }
      impl<'a,> ::core::fmt::Debug for GpuRenderPassDescriptor<'a,> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("GpuRenderPassDescriptor").field("color-attachments", &self.color_attachments).field("depth-stencil-attachment", &self.depth_stencil_attachment).field("occlusion-query-set", &self.occlusion_query_set).field("timestamp-writes", &self.timestamp_writes).field("max-draw-count", &self.max_draw_count).field("label", &self.label).finish()
        }
      }
      #[repr(C)]
      #[derive(Clone, Copy)]
      pub struct GpuOrigin3D {
        pub x: Option<GpuIntegerCoordinate>,
        pub y: Option<GpuIntegerCoordinate>,
        pub z: Option<GpuIntegerCoordinate>,
      }
      impl ::core::fmt::Debug for GpuOrigin3D {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("GpuOrigin3D").field("x", &self.x).field("y", &self.y).field("z", &self.z).finish()
        }
      }
      pub struct GpuTexelCopyTextureInfo<'a,> {
        pub texture: &'a GpuTexture,
        pub mip_level: Option<GpuIntegerCoordinate>,
        pub origin: Option<GpuOrigin3D>,
        pub aspect: Option<GpuTextureAspect>,
      }
      impl<'a,> ::core::fmt::Debug for GpuTexelCopyTextureInfo<'a,> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("GpuTexelCopyTextureInfo").field("texture", &self.texture).field("mip-level", &self.mip_level).field("origin", &self.origin).field("aspect", &self.aspect).finish()
        }
      }
      #[repr(C)]
      #[derive(Clone, Copy)]
      pub struct GpuExtent3D {
        pub width: GpuIntegerCoordinate,
        pub height: Option<GpuIntegerCoordinate>,
        pub depth_or_array_layers: Option<GpuIntegerCoordinate>,
      }
      impl ::core::fmt::Debug for GpuExtent3D {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("GpuExtent3D").field("width", &self.width).field("height", &self.height).field("depth-or-array-layers", &self.depth_or_array_layers).finish()
        }
      }
      #[derive(Clone)]
      pub struct GpuTextureDescriptor {
        pub size: GpuExtent3D,
        pub mip_level_count: Option<GpuIntegerCoordinate>,
        pub sample_count: Option<GpuSize32>,
        pub dimension: Option<GpuTextureDimension>,
        pub format: GpuTextureFormat,
        pub usage: GpuTextureUsageFlags,
        pub view_formats: Option<_rt::Vec::<GpuTextureFormat>>,
        pub label: Option<_rt::String>,
      }
      impl ::core::fmt::Debug for GpuTextureDescriptor {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("GpuTextureDescriptor").field("size", &self.size).field("mip-level-count", &self.mip_level_count).field("sample-count", &self.sample_count).field("dimension", &self.dimension).field("format", &self.format).field("usage", &self.usage).field("view-formats", &self.view_formats).field("label", &self.label).finish()
        }
      }
      #[repr(u8)]
      #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
      pub enum PredefinedColorSpace {
        Srgb,
        DisplayP3,
      }
      impl ::core::fmt::Debug for PredefinedColorSpace {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            PredefinedColorSpace::Srgb => {
              f.debug_tuple("PredefinedColorSpace::Srgb").finish()
            }
            PredefinedColorSpace::DisplayP3 => {
              f.debug_tuple("PredefinedColorSpace::DisplayP3").finish()
            }
          }
        }
      }

      impl PredefinedColorSpace{
        #[doc(hidden)]
        pub unsafe fn _lift(val: u8) -> PredefinedColorSpace{
          if !cfg!(debug_assertions) {
            return unsafe { ::core::mem::transmute(val) };
          }

          match val {
            0 => PredefinedColorSpace::Srgb,
            1 => PredefinedColorSpace::DisplayP3,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }
      
      pub struct GpuCanvasConfiguration<'a,> {
        pub device: &'a GpuDevice,
        pub format: GpuTextureFormat,
        pub usage: Option<GpuTextureUsageFlags>,
        pub view_formats: Option<_rt::Vec::<GpuTextureFormat>>,
        pub color_space: Option<PredefinedColorSpace>,
        pub tone_mapping: Option<GpuCanvasToneMapping>,
        pub alpha_mode: Option<GpuCanvasAlphaMode>,
      }
      impl<'a,> ::core::fmt::Debug for GpuCanvasConfiguration<'a,> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("GpuCanvasConfiguration").field("device", &self.device).field("format", &self.format).field("usage", &self.usage).field("view-formats", &self.view_formats).field("color-space", &self.color_space).field("tone-mapping", &self.tone_mapping).field("alpha-mode", &self.alpha_mode).finish()
        }
      }
      pub struct GpuCanvasConfigurationOwned {
        pub device: GpuDevice,
        pub format: GpuTextureFormat,
        pub usage: Option<GpuTextureUsageFlags>,
        pub view_formats: Option<_rt::Vec::<GpuTextureFormat>>,
        pub color_space: Option<PredefinedColorSpace>,
        pub tone_mapping: Option<GpuCanvasToneMapping>,
        pub alpha_mode: Option<GpuCanvasAlphaMode>,
      }
      impl ::core::fmt::Debug for GpuCanvasConfigurationOwned {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("GpuCanvasConfigurationOwned").field("device", &self.device).field("format", &self.format).field("usage", &self.usage).field("view-formats", &self.view_formats).field("color-space", &self.color_space).field("tone-mapping", &self.tone_mapping).field("alpha-mode", &self.alpha_mode).finish()
        }
      }
      #[derive(Clone, Copy)]
      pub enum GpuErrorKind {
        ValidationError,
        OutOfMemoryError,
        InternalError,
      }
      impl ::core::fmt::Debug for GpuErrorKind {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            GpuErrorKind::ValidationError => {
              f.debug_tuple("GpuErrorKind::ValidationError").finish()
            }
            GpuErrorKind::OutOfMemoryError => {
              f.debug_tuple("GpuErrorKind::OutOfMemoryError").finish()
            }
            GpuErrorKind::InternalError => {
              f.debug_tuple("GpuErrorKind::InternalError").finish()
            }
          }
        }
      }
      #[derive(Clone, Copy)]
      pub enum RequestDeviceErrorKind {
        TypeError,
        OperationError,
      }
      impl ::core::fmt::Debug for RequestDeviceErrorKind {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            RequestDeviceErrorKind::TypeError => {
              f.debug_tuple("RequestDeviceErrorKind::TypeError").finish()
            }
            RequestDeviceErrorKind::OperationError => {
              f.debug_tuple("RequestDeviceErrorKind::OperationError").finish()
            }
          }
        }
      }
      #[derive(Clone)]
      pub struct RequestDeviceError {
        pub kind: RequestDeviceErrorKind,
        pub message: _rt::String,
      }
      impl ::core::fmt::Debug for RequestDeviceError {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("RequestDeviceError").field("kind", &self.kind).field("message", &self.message).finish()
        }
      }
      impl ::core::fmt::Display for RequestDeviceError {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          write!(f, "{:?}", self)
        }
      }
      impl ::core::error::Error for RequestDeviceError {}
      #[derive(Clone, Copy)]
      pub enum CreatePipelineErrorKind {
        GpuPipelineError(GpuPipelineErrorReason),
      }
      impl ::core::fmt::Debug for CreatePipelineErrorKind {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            CreatePipelineErrorKind::GpuPipelineError(e) => {
              f.debug_tuple("CreatePipelineErrorKind::GpuPipelineError").field(e).finish()
            }
          }
        }
      }
      #[derive(Clone)]
      pub struct CreatePipelineError {
        pub kind: CreatePipelineErrorKind,
        pub message: _rt::String,
      }
      impl ::core::fmt::Debug for CreatePipelineError {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("CreatePipelineError").field("kind", &self.kind).field("message", &self.message).finish()
        }
      }
      impl ::core::fmt::Display for CreatePipelineError {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          write!(f, "{:?}", self)
        }
      }
      impl ::core::error::Error for CreatePipelineError {}
      #[derive(Clone, Copy)]
      pub enum CreateQuerySetErrorKind {
        TypeError,
      }
      impl ::core::fmt::Debug for CreateQuerySetErrorKind {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            CreateQuerySetErrorKind::TypeError => {
              f.debug_tuple("CreateQuerySetErrorKind::TypeError").finish()
            }
          }
        }
      }
      #[derive(Clone)]
      pub struct CreateQuerySetError {
        pub kind: CreateQuerySetErrorKind,
        pub message: _rt::String,
      }
      impl ::core::fmt::Debug for CreateQuerySetError {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("CreateQuerySetError").field("kind", &self.kind).field("message", &self.message).finish()
        }
      }
      impl ::core::fmt::Display for CreateQuerySetError {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          write!(f, "{:?}", self)
        }
      }
      impl ::core::error::Error for CreateQuerySetError {}
      #[derive(Clone, Copy)]
      pub enum PopErrorScopeErrorKind {
        OperationError,
      }
      impl ::core::fmt::Debug for PopErrorScopeErrorKind {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            PopErrorScopeErrorKind::OperationError => {
              f.debug_tuple("PopErrorScopeErrorKind::OperationError").finish()
            }
          }
        }
      }
      #[derive(Clone)]
      pub struct PopErrorScopeError {
        pub kind: PopErrorScopeErrorKind,
        pub message: _rt::String,
      }
      impl ::core::fmt::Debug for PopErrorScopeError {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("PopErrorScopeError").field("kind", &self.kind).field("message", &self.message).finish()
        }
      }
      impl ::core::fmt::Display for PopErrorScopeError {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          write!(f, "{:?}", self)
        }
      }
      impl ::core::error::Error for PopErrorScopeError {}
      #[derive(Clone, Copy)]
      pub enum MapAsyncErrorKind {
        OperationError,
        RangeError,
        AbortError,
      }
      impl ::core::fmt::Debug for MapAsyncErrorKind {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            MapAsyncErrorKind::OperationError => {
              f.debug_tuple("MapAsyncErrorKind::OperationError").finish()
            }
            MapAsyncErrorKind::RangeError => {
              f.debug_tuple("MapAsyncErrorKind::RangeError").finish()
            }
            MapAsyncErrorKind::AbortError => {
              f.debug_tuple("MapAsyncErrorKind::AbortError").finish()
            }
          }
        }
      }
      #[derive(Clone)]
      pub struct MapAsyncError {
        pub kind: MapAsyncErrorKind,
        pub message: _rt::String,
      }
      impl ::core::fmt::Debug for MapAsyncError {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("MapAsyncError").field("kind", &self.kind).field("message", &self.message).finish()
        }
      }
      impl ::core::fmt::Display for MapAsyncError {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          write!(f, "{:?}", self)
        }
      }
      impl ::core::error::Error for MapAsyncError {}
      #[derive(Clone, Copy)]
      pub enum GetMappedRangeErrorKind {
        OperationError,
        RangeError,
        TypeError,
      }
      impl ::core::fmt::Debug for GetMappedRangeErrorKind {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            GetMappedRangeErrorKind::OperationError => {
              f.debug_tuple("GetMappedRangeErrorKind::OperationError").finish()
            }
            GetMappedRangeErrorKind::RangeError => {
              f.debug_tuple("GetMappedRangeErrorKind::RangeError").finish()
            }
            GetMappedRangeErrorKind::TypeError => {
              f.debug_tuple("GetMappedRangeErrorKind::TypeError").finish()
            }
          }
        }
      }
      #[derive(Clone)]
      pub struct GetMappedRangeError {
        pub kind: GetMappedRangeErrorKind,
        pub message: _rt::String,
      }
      impl ::core::fmt::Debug for GetMappedRangeError {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("GetMappedRangeError").field("kind", &self.kind).field("message", &self.message).finish()
        }
      }
      impl ::core::fmt::Display for GetMappedRangeError {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          write!(f, "{:?}", self)
        }
      }
      impl ::core::error::Error for GetMappedRangeError {}
      #[derive(Clone, Copy)]
      pub enum UnmapErrorKind {
        AbortError,
      }
      impl ::core::fmt::Debug for UnmapErrorKind {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            UnmapErrorKind::AbortError => {
              f.debug_tuple("UnmapErrorKind::AbortError").finish()
            }
          }
        }
      }
      #[derive(Clone)]
      pub struct UnmapError {
        pub kind: UnmapErrorKind,
        pub message: _rt::String,
      }
      impl ::core::fmt::Debug for UnmapError {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("UnmapError").field("kind", &self.kind).field("message", &self.message).finish()
        }
      }
      impl ::core::fmt::Display for UnmapError {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          write!(f, "{:?}", self)
        }
      }
      impl ::core::error::Error for UnmapError {}
      #[derive(Clone, Copy)]
      pub enum SetBindGroupErrorKind {
        RangeError,
      }
      impl ::core::fmt::Debug for SetBindGroupErrorKind {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            SetBindGroupErrorKind::RangeError => {
              f.debug_tuple("SetBindGroupErrorKind::RangeError").finish()
            }
          }
        }
      }
      #[derive(Clone)]
      pub struct SetBindGroupError {
        pub kind: SetBindGroupErrorKind,
        pub message: _rt::String,
      }
      impl ::core::fmt::Debug for SetBindGroupError {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("SetBindGroupError").field("kind", &self.kind).field("message", &self.message).finish()
        }
      }
      impl ::core::fmt::Display for SetBindGroupError {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          write!(f, "{:?}", self)
        }
      }
      impl ::core::error::Error for SetBindGroupError {}
      #[derive(Clone, Copy)]
      pub enum WriteBufferErrorKind {
        OperationError,
      }
      impl ::core::fmt::Debug for WriteBufferErrorKind {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            WriteBufferErrorKind::OperationError => {
              f.debug_tuple("WriteBufferErrorKind::OperationError").finish()
            }
          }
        }
      }
      #[derive(Clone)]
      pub struct WriteBufferError {
        pub kind: WriteBufferErrorKind,
        pub message: _rt::String,
      }
      impl ::core::fmt::Debug for WriteBufferError {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("WriteBufferError").field("kind", &self.kind).field("message", &self.message).finish()
        }
      }
      impl ::core::fmt::Display for WriteBufferError {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          write!(f, "{:?}", self)
        }
      }
      impl ::core::error::Error for WriteBufferError {}
      impl GpuSupportedLimits {
        #[allow(unused_unsafe, clippy::all)]
        #[allow(async_fn_in_trait)]
        pub fn max_texture_dimension1_d(&self,) -> u32{
          unsafe {

            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
            unsafe extern "C" {
              #[link_name = "[method]gpu-supported-limits.max-texture-dimension1-d"]
              fn wit_import0(_: i32, ) -> i32;
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import0(_: i32, ) -> i32 { unreachable!() }
            let ret = wit_import0((self).handle() as i32);
            ret as u32
          }
        }
      }
      impl GpuSupportedLimits {
        #[allow(unused_unsafe, clippy::all)]
        #[allow(async_fn_in_trait)]
        pub fn max_texture_dimension2_d(&self,) -> u32{
          unsafe {

            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
            unsafe extern "C" {
              #[link_name = "[method]gpu-supported-limits.max-texture-dimension2-d"]
              fn wit_import0(_: i32, ) -> i32;
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import0(_: i32, ) -> i32 { unreachable!() }
            let ret = wit_import0((self).handle() as i32);
            ret as u32
          }
        }
      }
      impl GpuSupportedLimits {
        #[allow(unused_unsafe, clippy::all)]
        #[allow(async_fn_in_trait)]
        pub fn max_texture_dimension3_d(&self,) -> u32{
          unsafe {

            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
            unsafe extern "C" {
              #[link_name = "[method]gpu-supported-limits.max-texture-dimension3-d"]
              fn wit_import0(_: i32, ) -> i32;
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import0(_: i32, ) -> i32 { unreachable!() }
            let ret = wit_import0((self).handle() as i32);
            ret as u32
          }
        }
      }
      impl GpuSupportedLimits {
        #[allow(unused_unsafe, clippy::all)]
        #[allow(async_fn_in_trait)]
        pub fn max_texture_array_layers(&self,) -> u32{
          unsafe {

            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
            unsafe extern "C" {
              #[link_name = "[method]gpu-supported-limits.max-texture-array-layers"]
              fn wit_import0(_: i32, ) -> i32;
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import0(_: i32, ) -> i32 { unreachable!() }
            let ret = wit_import0((self).handle() as i32);
            ret as u32
          }
        }
      }
      impl GpuSupportedLimits {
        #[allow(unused_unsafe, clippy::all)]
        #[allow(async_fn_in_trait)]
        pub fn max_bind_groups(&self,) -> u32{
          unsafe {

            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
            unsafe extern "C" {
              #[link_name = "[method]gpu-supported-limits.max-bind-groups"]
              fn wit_import0(_: i32, ) -> i32;
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import0(_: i32, ) -> i32 { unreachable!() }
            let ret = wit_import0((self).handle() as i32);
            ret as u32
          }
        }
      }
      impl GpuSupportedLimits {
        #[allow(unused_unsafe, clippy::all)]
        #[allow(async_fn_in_trait)]
        pub fn max_bind_groups_plus_vertex_buffers(&self,) -> u32{
          unsafe {

            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
            unsafe extern "C" {
              #[link_name = "[method]gpu-supported-limits.max-bind-groups-plus-vertex-buffers"]
              fn wit_import0(_: i32, ) -> i32;
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import0(_: i32, ) -> i32 { unreachable!() }
            let ret = wit_import0((self).handle() as i32);
            ret as u32
          }
        }
      }
      impl GpuSupportedLimits {
        #[allow(unused_unsafe, clippy::all)]
        #[allow(async_fn_in_trait)]
        pub fn max_bindings_per_bind_group(&self,) -> u32{
          unsafe {

            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
            unsafe extern "C" {
              #[link_name = "[method]gpu-supported-limits.max-bindings-per-bind-group"]
              fn wit_import0(_: i32, ) -> i32;
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import0(_: i32, ) -> i32 { unreachable!() }
            let ret = wit_import0((self).handle() as i32);
            ret as u32
          }
        }
      }
      impl GpuSupportedLimits {
        #[allow(unused_unsafe, clippy::all)]
        #[allow(async_fn_in_trait)]
        pub fn max_dynamic_uniform_buffers_per_pipeline_layout(&self,) -> u32{
          unsafe {

            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
            unsafe extern "C" {
              #[link_name = "[method]gpu-supported-limits.max-dynamic-uniform-buffers-per-pipeline-layout"]
              fn wit_import0(_: i32, ) -> i32;
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import0(_: i32, ) -> i32 { unreachable!() }
            let ret = wit_import0((self).handle() as i32);
            ret as u32
          }
        }
      }
      impl GpuSupportedLimits {
        #[allow(unused_unsafe, clippy::all)]
        #[allow(async_fn_in_trait)]
        pub fn max_dynamic_storage_buffers_per_pipeline_layout(&self,) -> u32{
          unsafe {

            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
            unsafe extern "C" {
              #[link_name = "[method]gpu-supported-limits.max-dynamic-storage-buffers-per-pipeline-layout"]
              fn wit_import0(_: i32, ) -> i32;
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import0(_: i32, ) -> i32 { unreachable!() }
            let ret = wit_import0((self).handle() as i32);
            ret as u32
          }
        }
      }
      impl GpuSupportedLimits {
        #[allow(unused_unsafe, clippy::all)]
        #[allow(async_fn_in_trait)]
        pub fn max_sampled_textures_per_shader_stage(&self,) -> u32{
          unsafe {

            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
            unsafe extern "C" {
              #[link_name = "[method]gpu-supported-limits.max-sampled-textures-per-shader-stage"]
              fn wit_import0(_: i32, ) -> i32;
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import0(_: i32, ) -> i32 { unreachable!() }
            let ret = wit_import0((self).handle() as i32);
            ret as u32
          }
        }
      }
      impl GpuSupportedLimits {
        #[allow(unused_unsafe, clippy::all)]
        #[allow(async_fn_in_trait)]
        pub fn max_samplers_per_shader_stage(&self,) -> u32{
          unsafe {

            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
            unsafe extern "C" {
              #[link_name = "[method]gpu-supported-limits.max-samplers-per-shader-stage"]
              fn wit_import0(_: i32, ) -> i32;
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import0(_: i32, ) -> i32 { unreachable!() }
            let ret = wit_import0((self).handle() as i32);
            ret as u32
          }
        }
      }
      impl GpuSupportedLimits {
        #[allow(unused_unsafe, clippy::all)]
        #[allow(async_fn_in_trait)]
        pub fn max_storage_buffers_per_shader_stage(&self,) -> u32{
          unsafe {

            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
            unsafe extern "C" {
              #[link_name = "[method]gpu-supported-limits.max-storage-buffers-per-shader-stage"]
              fn wit_import0(_: i32, ) -> i32;
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import0(_: i32, ) -> i32 { unreachable!() }
            let ret = wit_import0((self).handle() as i32);
            ret as u32
          }
        }
      }
      impl GpuSupportedLimits {
        #[allow(unused_unsafe, clippy::all)]
        #[allow(async_fn_in_trait)]
        pub fn max_storage_textures_per_shader_stage(&self,) -> u32{
          unsafe {

            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
            unsafe extern "C" {
              #[link_name = "[method]gpu-supported-limits.max-storage-textures-per-shader-stage"]
              fn wit_import0(_: i32, ) -> i32;
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import0(_: i32, ) -> i32 { unreachable!() }
            let ret = wit_import0((self).handle() as i32);
            ret as u32
          }
        }
      }
      impl GpuSupportedLimits {
        #[allow(unused_unsafe, clippy::all)]
        #[allow(async_fn_in_trait)]
        pub fn max_uniform_buffers_per_shader_stage(&self,) -> u32{
          unsafe {

            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
            unsafe extern "C" {
              #[link_name = "[method]gpu-supported-limits.max-uniform-buffers-per-shader-stage"]
              fn wit_import0(_: i32, ) -> i32;
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import0(_: i32, ) -> i32 { unreachable!() }
            let ret = wit_import0((self).handle() as i32);
            ret as u32
          }
        }
      }
      impl GpuSupportedLimits {
        #[allow(unused_unsafe, clippy::all)]
        #[allow(async_fn_in_trait)]
        pub fn max_uniform_buffer_binding_size(&self,) -> u64{
          unsafe {

            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
            unsafe extern "C" {
              #[link_name = "[method]gpu-supported-limits.max-uniform-buffer-binding-size"]
              fn wit_import0(_: i32, ) -> i64;
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import0(_: i32, ) -> i64 { unreachable!() }
            let ret = wit_import0((self).handle() as i32);
            ret as u64
          }
        }
      }
      impl GpuSupportedLimits {
        #[allow(unused_unsafe, clippy::all)]
        #[allow(async_fn_in_trait)]
        pub fn max_storage_buffer_binding_size(&self,) -> u64{
          unsafe {

            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
            unsafe extern "C" {
              #[link_name = "[method]gpu-supported-limits.max-storage-buffer-binding-size"]
              fn wit_import0(_: i32, ) -> i64;
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import0(_: i32, ) -> i64 { unreachable!() }
            let ret = wit_import0((self).handle() as i32);
            ret as u64
          }
        }
      }
      impl GpuSupportedLimits {
        #[allow(unused_unsafe, clippy::all)]
        #[allow(async_fn_in_trait)]
        pub fn min_uniform_buffer_offset_alignment(&self,) -> u32{
          unsafe {

            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
            unsafe extern "C" {
              #[link_name = "[method]gpu-supported-limits.min-uniform-buffer-offset-alignment"]
              fn wit_import0(_: i32, ) -> i32;
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import0(_: i32, ) -> i32 { unreachable!() }
            let ret = wit_import0((self).handle() as i32);
            ret as u32
          }
        }
      }
      impl GpuSupportedLimits {
        #[allow(unused_unsafe, clippy::all)]
        #[allow(async_fn_in_trait)]
        pub fn min_storage_buffer_offset_alignment(&self,) -> u32{
          unsafe {

            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
            unsafe extern "C" {
              #[link_name = "[method]gpu-supported-limits.min-storage-buffer-offset-alignment"]
              fn wit_import0(_: i32, ) -> i32;
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import0(_: i32, ) -> i32 { unreachable!() }
            let ret = wit_import0((self).handle() as i32);
            ret as u32
          }
        }
      }
      impl GpuSupportedLimits {
        #[allow(unused_unsafe, clippy::all)]
        #[allow(async_fn_in_trait)]
        pub fn max_vertex_buffers(&self,) -> u32{
          unsafe {

            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
            unsafe extern "C" {
              #[link_name = "[method]gpu-supported-limits.max-vertex-buffers"]
              fn wit_import0(_: i32, ) -> i32;
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import0(_: i32, ) -> i32 { unreachable!() }
            let ret = wit_import0((self).handle() as i32);
            ret as u32
          }
        }
      }
      impl GpuSupportedLimits {
        #[allow(unused_unsafe, clippy::all)]
        #[allow(async_fn_in_trait)]
        pub fn max_buffer_size(&self,) -> u64{
          unsafe {

            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
            unsafe extern "C" {
              #[link_name = "[method]gpu-supported-limits.max-buffer-size"]
              fn wit_import0(_: i32, ) -> i64;
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import0(_: i32, ) -> i64 { unreachable!() }
            let ret = wit_import0((self).handle() as i32);
            ret as u64
          }
        }
      }
      impl GpuSupportedLimits {
        #[allow(unused_unsafe, clippy::all)]
        #[allow(async_fn_in_trait)]
        pub fn max_vertex_attributes(&self,) -> u32{
          unsafe {

            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
            unsafe extern "C" {
              #[link_name = "[method]gpu-supported-limits.max-vertex-attributes"]
              fn wit_import0(_: i32, ) -> i32;
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import0(_: i32, ) -> i32 { unreachable!() }
            let ret = wit_import0((self).handle() as i32);
            ret as u32
          }
        }
      }
      impl GpuSupportedLimits {
        #[allow(unused_unsafe, clippy::all)]
        #[allow(async_fn_in_trait)]
        pub fn max_vertex_buffer_array_stride(&self,) -> u32{
          unsafe {

            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
            unsafe extern "C" {
              #[link_name = "[method]gpu-supported-limits.max-vertex-buffer-array-stride"]
              fn wit_import0(_: i32, ) -> i32;
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import0(_: i32, ) -> i32 { unreachable!() }
            let ret = wit_import0((self).handle() as i32);
            ret as u32
          }
        }
      }
      impl GpuSupportedLimits {
        #[allow(unused_unsafe, clippy::all)]
        #[allow(async_fn_in_trait)]
        pub fn max_inter_stage_shader_variables(&self,) -> u32{
          unsafe {

            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
            unsafe extern "C" {
              #[link_name = "[method]gpu-supported-limits.max-inter-stage-shader-variables"]
              fn wit_import0(_: i32, ) -> i32;
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import0(_: i32, ) -> i32 { unreachable!() }
            let ret = wit_import0((self).handle() as i32);
            ret as u32
          }
        }
      }
      impl GpuSupportedLimits {
        #[allow(unused_unsafe, clippy::all)]
        #[allow(async_fn_in_trait)]
        pub fn max_color_attachments(&self,) -> u32{
          unsafe {

            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
            unsafe extern "C" {
              #[link_name = "[method]gpu-supported-limits.max-color-attachments"]
              fn wit_import0(_: i32, ) -> i32;
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import0(_: i32, ) -> i32 { unreachable!() }
            let ret = wit_import0((self).handle() as i32);
            ret as u32
          }
        }
      }
      impl GpuSupportedLimits {
        #[allow(unused_unsafe, clippy::all)]
        #[allow(async_fn_in_trait)]
        pub fn max_color_attachment_bytes_per_sample(&self,) -> u32{
          unsafe {

            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
            unsafe extern "C" {
              #[link_name = "[method]gpu-supported-limits.max-color-attachment-bytes-per-sample"]
              fn wit_import0(_: i32, ) -> i32;
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import0(_: i32, ) -> i32 { unreachable!() }
            let ret = wit_import0((self).handle() as i32);
            ret as u32
          }
        }
      }
      impl GpuSupportedLimits {
        #[allow(unused_unsafe, clippy::all)]
        #[allow(async_fn_in_trait)]
        pub fn max_compute_workgroup_storage_size(&self,) -> u32{
          unsafe {

            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
            unsafe extern "C" {
              #[link_name = "[method]gpu-supported-limits.max-compute-workgroup-storage-size"]
              fn wit_import0(_: i32, ) -> i32;
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import0(_: i32, ) -> i32 { unreachable!() }
            let ret = wit_import0((self).handle() as i32);
            ret as u32
          }
        }
      }
      impl GpuSupportedLimits {
        #[allow(unused_unsafe, clippy::all)]
        #[allow(async_fn_in_trait)]
        pub fn max_compute_invocations_per_workgroup(&self,) -> u32{
          unsafe {

            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
            unsafe extern "C" {
              #[link_name = "[method]gpu-supported-limits.max-compute-invocations-per-workgroup"]
              fn wit_import0(_: i32, ) -> i32;
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import0(_: i32, ) -> i32 { unreachable!() }
            let ret = wit_import0((self).handle() as i32);
            ret as u32
          }
        }
      }
      impl GpuSupportedLimits {
        #[allow(unused_unsafe, clippy::all)]
        #[allow(async_fn_in_trait)]
        pub fn max_compute_workgroup_size_x(&self,) -> u32{
          unsafe {

            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
            unsafe extern "C" {
              #[link_name = "[method]gpu-supported-limits.max-compute-workgroup-size-x"]
              fn wit_import0(_: i32, ) -> i32;
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import0(_: i32, ) -> i32 { unreachable!() }
            let ret = wit_import0((self).handle() as i32);
            ret as u32
          }
        }
      }
      impl GpuSupportedLimits {
        #[allow(unused_unsafe, clippy::all)]
        #[allow(async_fn_in_trait)]
        pub fn max_compute_workgroup_size_y(&self,) -> u32{
          unsafe {

            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
            unsafe extern "C" {
              #[link_name = "[method]gpu-supported-limits.max-compute-workgroup-size-y"]
              fn wit_import0(_: i32, ) -> i32;
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import0(_: i32, ) -> i32 { unreachable!() }
            let ret = wit_import0((self).handle() as i32);
            ret as u32
          }
        }
      }
      impl GpuSupportedLimits {
        #[allow(unused_unsafe, clippy::all)]
        #[allow(async_fn_in_trait)]
        pub fn max_compute_workgroup_size_z(&self,) -> u32{
          unsafe {

            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
            unsafe extern "C" {
              #[link_name = "[method]gpu-supported-limits.max-compute-workgroup-size-z"]
              fn wit_import0(_: i32, ) -> i32;
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import0(_: i32, ) -> i32 { unreachable!() }
            let ret = wit_import0((self).handle() as i32);
            ret as u32
          }
        }
      }
      impl GpuSupportedLimits {
        #[allow(unused_unsafe, clippy::all)]
        #[allow(async_fn_in_trait)]
        pub fn max_compute_workgroups_per_dimension(&self,) -> u32{
          unsafe {

            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
            unsafe extern "C" {
              #[link_name = "[method]gpu-supported-limits.max-compute-workgroups-per-dimension"]
              fn wit_import0(_: i32, ) -> i32;
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import0(_: i32, ) -> i32 { unreachable!() }
            let ret = wit_import0((self).handle() as i32);
            ret as u32
          }
        }
      }
      impl GpuSupportedFeatures {
        #[allow(unused_unsafe, clippy::all)]
        #[allow(async_fn_in_trait)]
        pub fn has(&self,value: &str,) -> bool{
          unsafe {
            let vec0 = value;
            let ptr0 = vec0.as_ptr().cast::<u8>();
            let len0 = vec0.len();

            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
            unsafe extern "C" {
              #[link_name = "[method]gpu-supported-features.has"]
              fn wit_import1(_: i32, _: *mut u8, _: usize, ) -> i32;
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, _: usize, ) -> i32 { unreachable!() }
            let ret = wit_import1((self).handle() as i32, ptr0.cast_mut(), len0);
            _rt::bool_lift(ret as u8)
          }
        }
      }
      impl WgslLanguageFeatures {
        #[allow(unused_unsafe, clippy::all)]
        #[allow(async_fn_in_trait)]
        pub fn has(&self,value: &str,) -> bool{
          unsafe {
            let vec0 = value;
            let ptr0 = vec0.as_ptr().cast::<u8>();
            let len0 = vec0.len();

            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
            unsafe extern "C" {
              #[link_name = "[method]wgsl-language-features.has"]
              fn wit_import1(_: i32, _: *mut u8, _: usize, ) -> i32;
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, _: usize, ) -> i32 { unreachable!() }
            let ret = wit_import1((self).handle() as i32, ptr0.cast_mut(), len0);
            _rt::bool_lift(ret as u8)
          }
        }
      }
      impl GpuAdapterInfo {
        #[allow(unused_unsafe, clippy::all)]
        #[allow(async_fn_in_trait)]
        pub fn vendor(&self,) -> _rt::String{
          unsafe {

            #[cfg_attr(target_pointer_width="64", repr(align(8)))]
            #[cfg_attr(target_pointer_width="32", repr(align(4)))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 2*::core::mem::size_of::<*const u8>()]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2*::core::mem::size_of::<*const u8>()]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
            unsafe extern "C" {
              #[link_name = "[method]gpu-adapter-info.vendor"]
              fn wit_import1(_: i32, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, ) { unreachable!() }
            wit_import1((self).handle() as i32, ptr0);
            let l2 = *ptr0.add(0).cast::<*mut u8>();
            let l3 = *ptr0.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
            let len4 = l3;
            let bytes4 = _rt::Vec::from_raw_parts(l2.cast(), len4, len4);
            let result5 = _rt::string_lift(bytes4);
            result5
          }
        }
      }
      impl GpuAdapterInfo {
        #[allow(unused_unsafe, clippy::all)]
        #[allow(async_fn_in_trait)]
        pub fn architecture(&self,) -> _rt::String{
          unsafe {

            #[cfg_attr(target_pointer_width="64", repr(align(8)))]
            #[cfg_attr(target_pointer_width="32", repr(align(4)))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 2*::core::mem::size_of::<*const u8>()]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2*::core::mem::size_of::<*const u8>()]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
            unsafe extern "C" {
              #[link_name = "[method]gpu-adapter-info.architecture"]
              fn wit_import1(_: i32, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, ) { unreachable!() }
            wit_import1((self).handle() as i32, ptr0);
            let l2 = *ptr0.add(0).cast::<*mut u8>();
            let l3 = *ptr0.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
            let len4 = l3;
            let bytes4 = _rt::Vec::from_raw_parts(l2.cast(), len4, len4);
            let result5 = _rt::string_lift(bytes4);
            result5
          }
        }
      }
      impl GpuAdapterInfo {
        #[allow(unused_unsafe, clippy::all)]
        #[allow(async_fn_in_trait)]
        pub fn device(&self,) -> _rt::String{
          unsafe {

            #[cfg_attr(target_pointer_width="64", repr(align(8)))]
            #[cfg_attr(target_pointer_width="32", repr(align(4)))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 2*::core::mem::size_of::<*const u8>()]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2*::core::mem::size_of::<*const u8>()]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
            unsafe extern "C" {
              #[link_name = "[method]gpu-adapter-info.device"]
              fn wit_import1(_: i32, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, ) { unreachable!() }
            wit_import1((self).handle() as i32, ptr0);
            let l2 = *ptr0.add(0).cast::<*mut u8>();
            let l3 = *ptr0.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
            let len4 = l3;
            let bytes4 = _rt::Vec::from_raw_parts(l2.cast(), len4, len4);
            let result5 = _rt::string_lift(bytes4);
            result5
          }
        }
      }
      impl GpuAdapterInfo {
        #[allow(unused_unsafe, clippy::all)]
        #[allow(async_fn_in_trait)]
        pub fn description(&self,) -> _rt::String{
          unsafe {

            #[cfg_attr(target_pointer_width="64", repr(align(8)))]
            #[cfg_attr(target_pointer_width="32", repr(align(4)))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 2*::core::mem::size_of::<*const u8>()]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2*::core::mem::size_of::<*const u8>()]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
            unsafe extern "C" {
              #[link_name = "[method]gpu-adapter-info.description"]
              fn wit_import1(_: i32, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, ) { unreachable!() }
            wit_import1((self).handle() as i32, ptr0);
            let l2 = *ptr0.add(0).cast::<*mut u8>();
            let l3 = *ptr0.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
            let len4 = l3;
            let bytes4 = _rt::Vec::from_raw_parts(l2.cast(), len4, len4);
            let result5 = _rt::string_lift(bytes4);
            result5
          }
        }
      }
      impl GpuAdapterInfo {
        #[allow(unused_unsafe, clippy::all)]
        #[allow(async_fn_in_trait)]
        pub fn subgroup_min_size(&self,) -> u32{
          unsafe {

            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
            unsafe extern "C" {
              #[link_name = "[method]gpu-adapter-info.subgroup-min-size"]
              fn wit_import0(_: i32, ) -> i32;
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import0(_: i32, ) -> i32 { unreachable!() }
            let ret = wit_import0((self).handle() as i32);
            ret as u32
          }
        }
      }
      impl GpuAdapterInfo {
        #[allow(unused_unsafe, clippy::all)]
        #[allow(async_fn_in_trait)]
        pub fn subgroup_max_size(&self,) -> u32{
          unsafe {

            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
            unsafe extern "C" {
              #[link_name = "[method]gpu-adapter-info.subgroup-max-size"]
              fn wit_import0(_: i32, ) -> i32;
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import0(_: i32, ) -> i32 { unreachable!() }
            let ret = wit_import0((self).handle() as i32);
            ret as u32
          }
        }
      }
      impl Gpu {
        #[allow(unused_unsafe, clippy::all)]
        #[allow(async_fn_in_trait)]
        pub fn request_adapter(&self,options: Option<&GpuRequestAdapterOptions>,) -> Option<GpuAdapter>{
          unsafe {

            #[repr(align(4))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 8]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 8]);
            let (result6_0,result6_1,result6_2,result6_3,result6_4,result6_5,result6_6,result6_7,result6_8,result6_9,) = match options {
              Some(e) => {
                let GpuRequestAdapterOptions{ feature_level:feature_level0, power_preference:power_preference0, force_fallback_adapter:force_fallback_adapter0, xr_compatible:xr_compatible0, } = e;
                let (result2_0,result2_1,result2_2,) = match feature_level0 {
                  Some(e) => {
                    let vec1 = e;
                    let ptr1 = vec1.as_ptr().cast::<u8>();
                    let len1 = vec1.len();

                    (1i32, ptr1.cast_mut(), len1)
                  },
                  None => {
                    (0i32, ::core::ptr::null_mut(), 0usize)
                  },
                };let (result3_0,result3_1,) = match power_preference0 {
                  Some(e) => (1i32, e.clone() as i32),
                  None => {
                    (0i32, 0i32)
                  },
                };let (result4_0,result4_1,) = match force_fallback_adapter0 {
                  Some(e) => (1i32, match e { true => 1, false => 0 }),
                  None => {
                    (0i32, 0i32)
                  },
                };let (result5_0,result5_1,) = match xr_compatible0 {
                  Some(e) => (1i32, match e { true => 1, false => 0 }),
                  None => {
                    (0i32, 0i32)
                  },
                };
                (1i32, result2_0, result2_1, result2_2, result3_0, result3_1, result4_0, result4_1, result5_0, result5_1)
              },
              None => {
                (0i32, 0i32, ::core::ptr::null_mut(), 0usize, 0i32, 0i32, 0i32, 0i32, 0i32, 0i32)
              },
            };let ptr7 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
            unsafe extern "C" {
              #[link_name = "[method]gpu.request-adapter"]
              fn wit_import8(_: i32, _: i32, _: i32, _: *mut u8, _: usize, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import8(_: i32, _: i32, _: i32, _: *mut u8, _: usize, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: *mut u8, ) { unreachable!() }
            wit_import8((self).handle() as i32, result6_0, result6_1, result6_2, result6_3, result6_4, result6_5, result6_6, result6_7, result6_8, result6_9, ptr7);
            let l9 = i32::from(*ptr7.add(0).cast::<u8>());
            let result11 = match l9 {
              0 => None,
              1 => {
                let e = {
                  let l10 = *ptr7.add(4).cast::<i32>();

                  GpuAdapter::from_handle(l10 as u32)
                };
                Some(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            };
            result11
          }
        }
      }
      impl Gpu {
        #[allow(unused_unsafe, clippy::all)]
        #[allow(async_fn_in_trait)]
        pub fn get_preferred_canvas_format(&self,) -> GpuTextureFormat{
          unsafe {

            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
            unsafe extern "C" {
              #[link_name = "[method]gpu.get-preferred-canvas-format"]
              fn wit_import0(_: i32, ) -> i32;
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import0(_: i32, ) -> i32 { unreachable!() }
            let ret = wit_import0((self).handle() as i32);
            GpuTextureFormat::_lift(ret as u8)
          }
        }
      }
      impl Gpu {
        #[allow(unused_unsafe, clippy::all)]
        #[allow(async_fn_in_trait)]
        pub fn wgsl_language_features(&self,) -> WgslLanguageFeatures{
          unsafe {

            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
            unsafe extern "C" {
              #[link_name = "[method]gpu.wgsl-language-features"]
              fn wit_import0(_: i32, ) -> i32;
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import0(_: i32, ) -> i32 { unreachable!() }
            let ret = wit_import0((self).handle() as i32);
            WgslLanguageFeatures::from_handle(ret as u32)
          }
        }
      }
      impl GpuAdapter {
        #[allow(unused_unsafe, clippy::all)]
        #[allow(async_fn_in_trait)]
        pub fn features(&self,) -> GpuSupportedFeatures{
          unsafe {

            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
            unsafe extern "C" {
              #[link_name = "[method]gpu-adapter.features"]
              fn wit_import0(_: i32, ) -> i32;
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import0(_: i32, ) -> i32 { unreachable!() }
            let ret = wit_import0((self).handle() as i32);
            GpuSupportedFeatures::from_handle(ret as u32)
          }
        }
      }
      impl GpuAdapter {
        #[allow(unused_unsafe, clippy::all)]
        #[allow(async_fn_in_trait)]
        pub fn limits(&self,) -> GpuSupportedLimits{
          unsafe {

            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
            unsafe extern "C" {
              #[link_name = "[method]gpu-adapter.limits"]
              fn wit_import0(_: i32, ) -> i32;
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import0(_: i32, ) -> i32 { unreachable!() }
            let ret = wit_import0((self).handle() as i32);
            GpuSupportedLimits::from_handle(ret as u32)
          }
        }
      }
      impl GpuAdapter {
        #[allow(unused_unsafe, clippy::all)]
        #[allow(async_fn_in_trait)]
        pub fn info(&self,) -> GpuAdapterInfo{
          unsafe {

            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
            unsafe extern "C" {
              #[link_name = "[method]gpu-adapter.info"]
              fn wit_import0(_: i32, ) -> i32;
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import0(_: i32, ) -> i32 { unreachable!() }
            let ret = wit_import0((self).handle() as i32);
            GpuAdapterInfo::from_handle(ret as u32)
          }
        }
      }
      impl GpuAdapter {
        #[allow(unused_unsafe, clippy::all)]
        #[allow(async_fn_in_trait)]
        pub fn is_fallback_adapter(&self,) -> bool{
          unsafe {

            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
            unsafe extern "C" {
              #[link_name = "[method]gpu-adapter.is-fallback-adapter"]
              fn wit_import0(_: i32, ) -> i32;
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import0(_: i32, ) -> i32 { unreachable!() }
            let ret = wit_import0((self).handle() as i32);
            _rt::bool_lift(ret as u8)
          }
        }
      }
      impl GpuAdapter {
        #[allow(unused_unsafe, clippy::all)]
        #[allow(async_fn_in_trait)]
        pub fn request_device(&self,descriptor: Option<GpuDeviceDescriptor>,) -> Result<GpuDevice,RequestDeviceError>{
          unsafe {
            let mut cleanup_list = _rt::Vec::new();

            #[cfg_attr(target_pointer_width="64", repr(align(8)))]
            #[cfg_attr(target_pointer_width="32", repr(align(4)))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 4*::core::mem::size_of::<*const u8>()]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 4*::core::mem::size_of::<*const u8>()]);
            let (result10_0,result10_1,result10_2,result10_3,result10_4,result10_5,result10_6,result10_7,result10_8,result10_9,result10_10,result10_11,result10_12,) = match &descriptor {
              Some(e) => {
                let GpuDeviceDescriptor{ required_features:required_features0, required_limits:required_limits0, default_queue:default_queue0, label:label0, } = e;
                let (result2_0,result2_1,result2_2,) = match required_features0 {
                  Some(e) => {
                    let vec1 = e;
                    let len1 = vec1.len();
                    let layout1 = _rt::alloc::Layout::from_size_align(vec1.len() * 1, 1).unwrap();
                    let (result1, _cleanup1) = wit_bindgen::rt::Cleanup::new(layout1);cleanup_list.extend(_cleanup1);
                    for (i, e) in vec1.into_iter().enumerate() {
                      let base = result1.add(i * 1);
                      {
                        *base.add(0).cast::<u8>() = (e.clone() as i32) as u8;
                      }
                    }

                    (1i32, result1, len1)
                  },
                  None => {
                    (0i32, ::core::ptr::null_mut(), 0usize)
                  },
                };let (result3_0,result3_1,) = match required_limits0 {
                  Some(e) => (1i32, (e).take_handle() as i32),
                  None => {
                    (0i32, 0i32)
                  },
                };let (result7_0,result7_1,result7_2,result7_3,) = match default_queue0 {
                  Some(e) => {
                    let GpuQueueDescriptor{ label:label4, } = e;
                    let (result6_0,result6_1,result6_2,) = match label4 {
                      Some(e) => {
                        let vec5 = e;
                        let ptr5 = vec5.as_ptr().cast::<u8>();
                        let len5 = vec5.len();

                        (1i32, ptr5.cast_mut(), len5)
                      },
                      None => {
                        (0i32, ::core::ptr::null_mut(), 0usize)
                      },
                    };
                    (1i32, result6_0, result6_1, result6_2)
                  },
                  None => {
                    (0i32, 0i32, ::core::ptr::null_mut(), 0usize)
                  },
                };let (result9_0,result9_1,result9_2,) = match label0 {
                  Some(e) => {
                    let vec8 = e;
                    let ptr8 = vec8.as_ptr().cast::<u8>();
                    let len8 = vec8.len();

                    (1i32, ptr8.cast_mut(), len8)
                  },
                  None => {
                    (0i32, ::core::ptr::null_mut(), 0usize)
                  },
                };
                (1i32, result2_0, result2_1, result2_2, result3_0, result3_1, result7_0, result7_1, result7_2, result7_3, result9_0, result9_1, result9_2)
              },
              None => {
                (0i32, 0i32, ::core::ptr::null_mut(), 0usize, 0i32, 0i32, 0i32, 0i32, ::core::ptr::null_mut(), 0usize, 0i32, ::core::ptr::null_mut(), 0usize)
              },
            };let ptr11 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
            unsafe extern "C" {
              #[link_name = "[method]gpu-adapter.request-device"]
              fn wit_import12(_: i32, _: i32, _: i32, _: *mut u8, _: usize, _: i32, _: i32, _: i32, _: i32, _: *mut u8, _: usize, _: i32, _: *mut u8, _: usize, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import12(_: i32, _: i32, _: i32, _: *mut u8, _: usize, _: i32, _: i32, _: i32, _: i32, _: *mut u8, _: usize, _: i32, _: *mut u8, _: usize, _: *mut u8, ) { unreachable!() }
            wit_import12((self).handle() as i32, result10_0, result10_1, result10_2, result10_3, result10_4, result10_5, result10_6, result10_7, result10_8, result10_9, result10_10, result10_11, result10_12, ptr11);
            let l13 = i32::from(*ptr11.add(0).cast::<u8>());
            let result20 = match l13 {
              0 => {
                let e = {
                  let l14 = *ptr11.add(::core::mem::size_of::<*const u8>()).cast::<i32>();

                  GpuDevice::from_handle(l14 as u32)
                };
                Ok(e)
              }
              1 => {
                let e = {
                  let l15 = i32::from(*ptr11.add(::core::mem::size_of::<*const u8>()).cast::<u8>());
                  let v16 = match l15 {
                    0 => {
                      RequestDeviceErrorKind::TypeError
                    }
                    n => {
                      debug_assert_eq!(n, 1, "invalid enum discriminant");
                      RequestDeviceErrorKind::OperationError
                    }
                  };
                  let l17 = *ptr11.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                  let l18 = *ptr11.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>();
                  let len19 = l18;
                  let bytes19 = _rt::Vec::from_raw_parts(l17.cast(), len19, len19);

                  RequestDeviceError{
                    kind: v16,
                    message: _rt::string_lift(bytes19),
                  }
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            };
            result20
          }
        }
      }
      impl RecordOptionGpuSize64 {
        #[allow(unused_unsafe, clippy::all)]
        #[allow(async_fn_in_trait)]
        pub fn new() -> Self{
          unsafe {

            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
            unsafe extern "C" {
              #[link_name = "[constructor]record-option-gpu-size64"]
              fn wit_import0() -> i32;
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import0() -> i32 { unreachable!() }
            let ret = wit_import0();
            RecordOptionGpuSize64::from_handle(ret as u32)
          }
        }
      }
      impl RecordOptionGpuSize64 {
        #[allow(unused_unsafe, clippy::all)]
        #[allow(async_fn_in_trait)]
        pub fn add(&self,key: &str,value: Option<GpuSize64>,) -> (){
          unsafe {
            let vec0 = key;
            let ptr0 = vec0.as_ptr().cast::<u8>();
            let len0 = vec0.len();
            let (result1_0,result1_1,) = match value {
              Some(e) => (1i32, _rt::as_i64(e)),
              None => {
                (0i32, 0i64)
              },
            };
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
            unsafe extern "C" {
              #[link_name = "[method]record-option-gpu-size64.add"]
              fn wit_import2(_: i32, _: *mut u8, _: usize, _: i32, _: i64, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import2(_: i32, _: *mut u8, _: usize, _: i32, _: i64, ) { unreachable!() }
            wit_import2((self).handle() as i32, ptr0.cast_mut(), len0, result1_0, result1_1);
          }
        }
      }
      impl RecordOptionGpuSize64 {
        #[allow(unused_unsafe, clippy::all)]
        #[allow(async_fn_in_trait)]
        pub fn get(&self,key: &str,) -> Option<Option<GpuSize64>>{
          unsafe {

            #[repr(align(8))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 24]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 24]);
            let vec0 = key;
            let ptr0 = vec0.as_ptr().cast::<u8>();
            let len0 = vec0.len();
            let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
            unsafe extern "C" {
              #[link_name = "[method]record-option-gpu-size64.get"]
              fn wit_import2(_: i32, _: *mut u8, _: usize, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import2(_: i32, _: *mut u8, _: usize, _: *mut u8, ) { unreachable!() }
            wit_import2((self).handle() as i32, ptr0.cast_mut(), len0, ptr1);
            let l3 = i32::from(*ptr1.add(0).cast::<u8>());
            let result6 = match l3 {
              0 => None,
              1 => {
                let e = {
                  let l4 = i32::from(*ptr1.add(8).cast::<u8>());

                  match l4 {
                    0 => None,
                    1 => {
                      let e = {
                        let l5 = *ptr1.add(16).cast::<i64>();

                        l5 as u64
                      };
                      Some(e)
                    }
                    _ => _rt::invalid_enum_discriminant(),
                  }
                };
                Some(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            };
            result6
          }
        }
      }
      impl RecordOptionGpuSize64 {
        #[allow(unused_unsafe, clippy::all)]
        #[allow(async_fn_in_trait)]
        pub fn has(&self,key: &str,) -> bool{
          unsafe {
            let vec0 = key;
            let ptr0 = vec0.as_ptr().cast::<u8>();
            let len0 = vec0.len();

            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
            unsafe extern "C" {
              #[link_name = "[method]record-option-gpu-size64.has"]
              fn wit_import1(_: i32, _: *mut u8, _: usize, ) -> i32;
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, _: usize, ) -> i32 { unreachable!() }
            let ret = wit_import1((self).handle() as i32, ptr0.cast_mut(), len0);
            _rt::bool_lift(ret as u8)
          }
        }
      }
      impl RecordOptionGpuSize64 {
        #[allow(unused_unsafe, clippy::all)]
        #[allow(async_fn_in_trait)]
        pub fn remove(&self,key: &str,) -> (){
          unsafe {
            let vec0 = key;
            let ptr0 = vec0.as_ptr().cast::<u8>();
            let len0 = vec0.len();

            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
            unsafe extern "C" {
              #[link_name = "[method]record-option-gpu-size64.remove"]
              fn wit_import1(_: i32, _: *mut u8, _: usize, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, _: usize, ) { unreachable!() }
            wit_import1((self).handle() as i32, ptr0.cast_mut(), len0);
          }
        }
      }
      impl RecordOptionGpuSize64 {
        #[allow(unused_unsafe, clippy::all)]
        #[allow(async_fn_in_trait)]
        pub fn keys(&self,) -> _rt::Vec::<_rt::String>{
          unsafe {

            #[cfg_attr(target_pointer_width="64", repr(align(8)))]
            #[cfg_attr(target_pointer_width="32", repr(align(4)))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 2*::core::mem::size_of::<*const u8>()]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2*::core::mem::size_of::<*const u8>()]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
            unsafe extern "C" {
              #[link_name = "[method]record-option-gpu-size64.keys"]
              fn wit_import1(_: i32, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, ) { unreachable!() }
            wit_import1((self).handle() as i32, ptr0);
            let l2 = *ptr0.add(0).cast::<*mut u8>();
            let l3 = *ptr0.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
            let base7 = l2;
            let len7 = l3;
            let mut result7 = _rt::Vec::with_capacity(len7);
            for i in 0..len7 {
              let base = base7.add(i * (2*::core::mem::size_of::<*const u8>()));
              let e7 = {
                let l4 = *base.add(0).cast::<*mut u8>();
                let l5 = *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
                let len6 = l5;
                let bytes6 = _rt::Vec::from_raw_parts(l4.cast(), len6, len6);

                _rt::string_lift(bytes6)
              };
              result7.push(e7);
            }
            _rt::cabi_dealloc(base7, len7 * (2*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>());
            let result8 = result7;
            result8
          }
        }
      }
      impl RecordOptionGpuSize64 {
        #[allow(unused_unsafe, clippy::all)]
        #[allow(async_fn_in_trait)]
        pub fn values(&self,) -> _rt::Vec::<Option<GpuSize64>>{
          unsafe {

            #[cfg_attr(target_pointer_width="64", repr(align(8)))]
            #[cfg_attr(target_pointer_width="32", repr(align(4)))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 2*::core::mem::size_of::<*const u8>()]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2*::core::mem::size_of::<*const u8>()]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
            unsafe extern "C" {
              #[link_name = "[method]record-option-gpu-size64.values"]
              fn wit_import1(_: i32, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, ) { unreachable!() }
            wit_import1((self).handle() as i32, ptr0);
            let l2 = *ptr0.add(0).cast::<*mut u8>();
            let l3 = *ptr0.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
            let base6 = l2;
            let len6 = l3;
            let mut result6 = _rt::Vec::with_capacity(len6);
            for i in 0..len6 {
              let base = base6.add(i * 16);
              let e6 = {
                let l4 = i32::from(*base.add(0).cast::<u8>());

                match l4 {
                  0 => None,
                  1 => {
                    let e = {
                      let l5 = *base.add(8).cast::<i64>();

                      l5 as u64
                    };
                    Some(e)
                  }
                  _ => _rt::invalid_enum_discriminant(),
                }
              };
              result6.push(e6);
            }
            _rt::cabi_dealloc(base6, len6 * 16, 8);
            let result7 = result6;
            result7
          }
        }
      }
      impl RecordOptionGpuSize64 {
        #[allow(unused_unsafe, clippy::all)]
        #[allow(async_fn_in_trait)]
        pub fn entries(&self,) -> _rt::Vec::<(_rt::String,Option<GpuSize64>,)>{
          unsafe {

            #[cfg_attr(target_pointer_width="64", repr(align(8)))]
            #[cfg_attr(target_pointer_width="32", repr(align(4)))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 2*::core::mem::size_of::<*const u8>()]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2*::core::mem::size_of::<*const u8>()]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
            unsafe extern "C" {
              #[link_name = "[method]record-option-gpu-size64.entries"]
              fn wit_import1(_: i32, _: *mut u8, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, ) { unreachable!() }
            wit_import1((self).handle() as i32, ptr0);
            let l2 = *ptr0.add(0).cast::<*mut u8>();
            let l3 = *ptr0.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
            let base9 = l2;
            let len9 = l3;
            let mut result9 = _rt::Vec::with_capacity(len9);
            for i in 0..len9 {
              let base = base9.add(i * (16+2*::core::mem::size_of::<*const u8>()));
              let e9 = {
                let l4 = *base.add(0).cast::<*mut u8>();
                let l5 = *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
                let len6 = l5;
                let bytes6 = _rt::Vec::from_raw_parts(l4.cast(), len6, len6);
                let l7 = i32::from(*base.add(2*::core::mem::size_of::<*const u8>()).cast::<u8>());

                (_rt::string_lift(bytes6), match l7 {
                  0 => None,
                  1 => {
                    let e = {
                      let l8 = *base.add(8+2*::core::mem::size_of::<*const u8>()).cast::<i64>();

                      l8 as u64
                    };
                    Some(e)
                  }
                  _ => _rt::invalid_enum_discriminant(),
                })
              };
              result9.push(e9);
            }
            _rt::cabi_dealloc(base9, len9 * (16+2*::core::mem::size_of::<*const u8>()), 8);
            let result10 = result9;
            result10
          }
        }
      }
      impl GpuDevice {
        #[allow(unused_unsafe, clippy::all)]
        #[allow(async_fn_in_trait)]
        pub fn features(&self,) -> GpuSupportedFeatures{
          unsafe {

            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
            unsafe extern "C" {
              #[link_name = "[method]gpu-device.features"]
              fn wit_import0(_: i32, ) -> i32;
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import0(_: i32, ) -> i32 { unreachable!() }
            let ret = wit_import0((self).handle() as i32);
            GpuSupportedFeatures::from_handle(ret as u32)
          }
        }
      }
      impl GpuDevice {
        #[allow(unused_unsafe, clippy::all)]
        #[allow(async_fn_in_trait)]
        pub fn limits(&self,) -> GpuSupportedLimits{
          unsafe {

            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
            unsafe extern "C" {
              #[link_name = "[method]gpu-device.limits"]
              fn wit_import0(_: i32, ) -> i32;
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import0(_: i32, ) -> i32 { unreachable!() }
            let ret = wit_import0((self).handle() as i32);
            GpuSupportedLimits::from_handle(ret as u32)
          }
        }
      }
      impl GpuDevice {
        #[allow(unused_unsafe, clippy::all)]
        #[allow(async_fn_in_trait)]
        pub fn adapter_info(&self,) -> GpuAdapterInfo{
          unsafe {

            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
            unsafe extern "C" {
              #[link_name = "[method]gpu-device.adapter-info"]
              fn wit_import0(_: i32, ) -> i32;
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import0(_: i32, ) -> i32 { unreachable!() }
            let ret = wit_import0((self).handle() as i32);
            GpuAdapterInfo::from_handle(ret as u32)
          }
        }
      }
      impl GpuDevice {
        #[allow(unused_unsafe, clippy::all)]
        #[allow(async_fn_in_trait)]
        pub fn queue(&self,) -> GpuQueue{
          unsafe {

            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
            unsafe extern "C" {
              #[link_name = "[method]gpu-device.queue"]
              fn wit_import0(_: i32, ) -> i32;
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import0(_: i32, ) -> i32 { unreachable!() }
            let ret = wit_import0((self).handle() as i32);
            GpuQueue::from_handle(ret as u32)
          }
        }
      }
      impl GpuDevice {
        #[allow(unused_unsafe, clippy::all)]
        #[allow(async_fn_in_trait)]
        pub fn destroy(&self,) -> (){
          unsafe {

            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
            unsafe extern "C" {
              #[link_name = "[method]gpu-device.destroy"]
              fn wit_import0(_: i32, );
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import0(_: i32, ) { unreachable!() }
            wit_import0((self).handle() as i32);
          }
        }
      }
      impl GpuDevice {
        #[allow(unused_unsafe, clippy::all)]
        #[allow(async_fn_in_trait)]
        pub fn create_buffer(&self,descriptor: &GpuBufferDescriptor,) -> GpuBuffer{
          unsafe {
            let GpuBufferDescriptor{ size:size0, usage:usage0, mapped_at_creation:mapped_at_creation0, label:label0, } = descriptor;
            let (result1_0,result1_1,) = match mapped_at_creation0 {
              Some(e) => (1i32, match e { true => 1, false => 0 }),
              None => {
                (0i32, 0i32)
              },
            };let (result3_0,result3_1,result3_2,) = match label0 {
              Some(e) => {
                let vec2 = e;
                let ptr2 = vec2.as_ptr().cast::<u8>();
                let len2 = vec2.len();

                (1i32, ptr2.cast_mut(), len2)
              },
              None => {
                (0i32, ::core::ptr::null_mut(), 0usize)
              },
            };
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
            unsafe extern "C" {
              #[link_name = "[method]gpu-device.create-buffer"]
              fn wit_import4(_: i32, _: i64, _: i32, _: i32, _: i32, _: i32, _: *mut u8, _: usize, ) -> i32;
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import4(_: i32, _: i64, _: i32, _: i32, _: i32, _: i32, _: *mut u8, _: usize, ) -> i32 { unreachable!() }
            let ret = wit_import4((self).handle() as i32, _rt::as_i64(size0), _rt::as_i32(usage0), result1_0, result1_1, result3_0, result3_1, result3_2);
            GpuBuffer::from_handle(ret as u32)
          }
        }
      }
      impl GpuDevice {
        #[allow(unused_unsafe, clippy::all)]
        #[allow(async_fn_in_trait)]
        pub fn create_texture(&self,descriptor: &GpuTextureDescriptor,) -> GpuTexture{
          unsafe {
            let mut cleanup_list = _rt::Vec::new();

            #[cfg_attr(target_pointer_width="64", repr(align(8)))]
            #[cfg_attr(target_pointer_width="32", repr(align(4)))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 40+8*::core::mem::size_of::<*const u8>()]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 40+8*::core::mem::size_of::<*const u8>()]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();*ptr0.add(0).cast::<i32>() = (self).handle() as i32;
            let GpuTextureDescriptor{ size:size1, mip_level_count:mip_level_count1, sample_count:sample_count1, dimension:dimension1, format:format1, usage:usage1, view_formats:view_formats1, label:label1, } = descriptor;
            let GpuExtent3D{ width:width2, height:height2, depth_or_array_layers:depth_or_array_layers2, } = size1;
            *ptr0.add(::core::mem::size_of::<*const u8>()).cast::<i32>() = _rt::as_i32(width2);
            match height2 {
              Some(e) => {
                *ptr0.add(4+1*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                *ptr0.add(8+1*::core::mem::size_of::<*const u8>()).cast::<i32>() = _rt::as_i32(e);
              },
              None => {
                {
                  *ptr0.add(4+1*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                }
              },
            };match depth_or_array_layers2 {
              Some(e) => {
                *ptr0.add(12+1*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                *ptr0.add(16+1*::core::mem::size_of::<*const u8>()).cast::<i32>() = _rt::as_i32(e);
              },
              None => {
                {
                  *ptr0.add(12+1*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                }
              },
            };match mip_level_count1 {
              Some(e) => {
                *ptr0.add(20+1*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                *ptr0.add(24+1*::core::mem::size_of::<*const u8>()).cast::<i32>() = _rt::as_i32(e);
              },
              None => {
                {
                  *ptr0.add(20+1*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                }
              },
            };match sample_count1 {
              Some(e) => {
                *ptr0.add(28+1*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                *ptr0.add(32+1*::core::mem::size_of::<*const u8>()).cast::<i32>() = _rt::as_i32(e);
              },
              None => {
                {
                  *ptr0.add(28+1*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                }
              },
            };match dimension1 {
              Some(e) => {
                *ptr0.add(36+1*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                *ptr0.add(37+1*::core::mem::size_of::<*const u8>()).cast::<u8>() = (e.clone() as i32) as u8;
              },
              None => {
                {
                  *ptr0.add(36+1*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                }
              },
            };*ptr0.add(38+1*::core::mem::size_of::<*const u8>()).cast::<u8>() = (format1.clone() as i32) as u8;
            *ptr0.add(40+1*::core::mem::size_of::<*const u8>()).cast::<i32>() = _rt::as_i32(usage1);
            match view_formats1 {
              Some(e) => {
                *ptr0.add(40+2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                let vec3 = e;
                let len3 = vec3.len();
                let layout3 = _rt::alloc::Layout::from_size_align(vec3.len() * 1, 1).unwrap();
                let (result3, _cleanup3) = wit_bindgen::rt::Cleanup::new(layout3);cleanup_list.extend(_cleanup3);
                for (i, e) in vec3.into_iter().enumerate() {
                  let base = result3.add(i * 1);
                  {
                    *base.add(0).cast::<u8>() = (e.clone() as i32) as u8;
                  }
                }
                *ptr0.add(40+4*::core::mem::size_of::<*const u8>()).cast::<usize>() = len3;
                *ptr0.add(40+3*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = result3;
              },
              None => {
                {
                  *ptr0.add(40+2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                }
              },
            };match label1 {
              Some(e) => {
                *ptr0.add(40+5*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                let vec4 = e;
                let ptr4 = vec4.as_ptr().cast::<u8>();
                let len4 = vec4.len();
                *ptr0.add(40+7*::core::mem::size_of::<*const u8>()).cast::<usize>() = len4;
                *ptr0.add(40+6*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr4.cast_mut();
              },
              None => {
                {
                  *ptr0.add(40+5*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                }
              },
            };
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
            unsafe extern "C" {
              #[link_name = "[method]gpu-device.create-texture"]
              fn wit_import5(_: *mut u8, ) -> i32;
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn wit_import5(_: *mut u8, ) -> i32 { unreachable!() }
            let ret = wit_import5(ptr0);
            GpuTexture::from_handle(ret as u32)
          }
        }
      }
      impl GpuDevice {
        #[allow(unused_unsafe, clippy::all)]
        #[allow(async_fn_in_trait)]
        pub fn create_sampler(&self,descriptor: Option<&GpuSamplerDescriptor>,) -> GpuSampler{
          unsafe {

            #[cfg_attr(target_pointer_width="64", repr(align(8)))]
            #[cfg_attr(target_pointer_width="32", repr(align(4)))]
            struct RetArea([::core::mem::MaybeUninit::<u8>; 32+6*::core::mem::size_of::<*const u8>()]);
            let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 32+6*::core::mem::size_of::<*const u8>()]);
            let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();*ptr0.add(0).cast::<i32>() = (self).handle() as i32;
            match descriptor {
              Some(e) => {
                *ptr0.add(::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                let GpuSamplerDescriptor{ address_mode_u:address_mode_u1, address_mode_v:address_mode_v1, address_mode_w:address_mode_w1, mag_filter:mag_filter1, min_filter:min_filter1, mipmap_filter:mipmap_filter1, lod_min_clamp:lod_min_clamp1, lod_max_clamp:lod_max_clamp1, compare:compare1, max_anisotropy:max_anisotropy1, label:label1, } = e;
                match address_mode_u1 {
                  Some(e) => {
                    *ptr0.add(2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                    *ptr0.add(1+2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (e.clone() as i32) as u8;
                  },
                  None => {
                    {
                      *ptr0.add(2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                    }
                  },
                };match address_mode_v1 {
                  Some(e) => {
                    *ptr0.add(2+2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                    *ptr0.add(3+2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (e.clone() as i32) as u8;
                  },
                  None => {
                    {
                      *ptr0.add(2+2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                    }
                  },
                };match address_mode_w1 {
                  Some(e) => {
                    *ptr0.add(4+2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                    *ptr0.add(5+2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (e.clone() as i32) as u8;
                  },
                  None => {
                    {
                      *ptr0.add(4+2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                    }
                  },
                };match mag_filter1 {
                  Some(e) => {
                    *ptr0.add(6+2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                    *ptr0.add(7+2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (e.clone() as i32) as u8;
                  },
                  None => {
                    {
                      *ptr0.add(6+2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                    }
                  },
                };match min_filter1 {
                  Some(e) => {
                    *ptr0.add(8+2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                    *ptr0.add(9+2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (e.clone() as i32) as u8;
                  },
                  None => {
                    {
                      *ptr0.add(8+2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                    }
                  },
                };match mipmap_filter1 {
                  Some(e) => {
                    *ptr0.add(10+2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                    *ptr0.add(11+2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (e.clone() as i32) as u8;
                  },
                  None => {
                    {
                      *ptr0.add(10+2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                    }
                  },
                };match lod_min_clamp1 {
                  Some(e) => {
                    *ptr0.add(12+2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                    *ptr0.add(16+2*::core::mem::size_of::<*const u8>()).cast::<f32>() = _rt::as_f32(e);
                  },
                  None => {
                    {
                      *ptr0.add(12+2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                    }
                  },
                };match lod_max_clamp1 {
                  Some(e) => {
                    *ptr0.add(20+2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                    *ptr0.add(24+2*::core::mem::size_of::<*const u8>()).cast::<f32>() = _rt::as_f32(e);
                  },
                  None => {
                    {
                      *ptr0.add(20+2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                    }
                  },
                };match compare1 {
                  Some(e) => {
                    *ptr0.add(28+2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                    *ptr0.add(29+2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (e.clone() as i32) as u8;
                  },
                  None => {
                    {
                      *ptr0.add(28+2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                    }
                  },
                };match max_anisotropy1 {
                  Some(e) => {
                    *ptr0.add(30+2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                    *ptr0.add(32+2*::core::mem::size_of::<*const u8>()).cast::<u16>() = (_rt::as_i32(e)) as u16;
                  },
                  None => {
                    {
                      *ptr0.add(30+2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                    }
                  },
                };match label1 {
                  Some(e) => {
                    *ptr0.add(32+3*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                    let vec2 = e;
                    let ptr2 = vec2.as_ptr().cast::<u8>();
                    let len2 = vec2.len();
                    *ptr0.add(32+5*::core::mem::size_of::<*const u8>()).cast::<usize>() = len2;
                    *ptr0.add(32+4*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr2.cast_mut();
                  },
                  None => {
                    {
                      *ptr0.add(32+3*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                    }
                  },
                };},
                None => {
                  {
                    *ptr0.add(::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                  }
                },
              };
              #[cfg(target_arch = "wasm32")]
              #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
              unsafe extern "C" {
                #[link_name = "[method]gpu-device.create-sampler"]
                fn wit_import3(_: *mut u8, ) -> i32;
              }

              #[cfg(not(target_arch = "wasm32"))]
              unsafe extern "C" fn wit_import3(_: *mut u8, ) -> i32 { unreachable!() }
              let ret = wit_import3(ptr0);
              GpuSampler::from_handle(ret as u32)
            }
          }
        }
        impl GpuDevice {
          #[allow(unused_unsafe, clippy::all)]
          #[allow(async_fn_in_trait)]
          pub fn create_bind_group_layout(&self,descriptor: &GpuBindGroupLayoutDescriptor,) -> GpuBindGroupLayout{
            unsafe {
              let GpuBindGroupLayoutDescriptor{ entries:entries0, label:label0, } = descriptor;
              let vec6 = entries0;
              let len6 = vec6.len();
              let layout6 = _rt::alloc::Layout::from_size_align(vec6.len() * 56, 8).unwrap();
              let (result6, _cleanup6) = wit_bindgen::rt::Cleanup::new(layout6);for (i, e) in vec6.into_iter().enumerate() {
                let base = result6.add(i * 56);
                {
                  let GpuBindGroupLayoutEntry{ binding:binding1, visibility:visibility1, buffer:buffer1, sampler:sampler1, texture:texture1, storage_texture:storage_texture1, } = e;
                  *base.add(0).cast::<i32>() = _rt::as_i32(binding1);
                  *base.add(4).cast::<i32>() = _rt::as_i32(visibility1);
                  match buffer1 {
                    Some(e) => {
                      *base.add(8).cast::<u8>() = (1i32) as u8;
                      let GpuBufferBindingLayout{ type_:type_2, has_dynamic_offset:has_dynamic_offset2, min_binding_size:min_binding_size2, } = e;
                      match type_2 {
                        Some(e) => {
                          *base.add(16).cast::<u8>() = (1i32) as u8;
                          *base.add(17).cast::<u8>() = (e.clone() as i32) as u8;
                        },
                        None => {
                          {
                            *base.add(16).cast::<u8>() = (0i32) as u8;
                          }
                        },
                      };match has_dynamic_offset2 {
                        Some(e) => {
                          *base.add(18).cast::<u8>() = (1i32) as u8;
                          *base.add(19).cast::<u8>() = (match e { true => 1, false => 0 }) as u8;
                        },
                        None => {
                          {
                            *base.add(18).cast::<u8>() = (0i32) as u8;
                          }
                        },
                      };match min_binding_size2 {
                        Some(e) => {
                          *base.add(24).cast::<u8>() = (1i32) as u8;
                          *base.add(32).cast::<i64>() = _rt::as_i64(e);
                        },
                        None => {
                          {
                            *base.add(24).cast::<u8>() = (0i32) as u8;
                          }
                        },
                      };},
                      None => {
                        {
                          *base.add(8).cast::<u8>() = (0i32) as u8;
                        }
                      },
                    };match sampler1 {
                      Some(e) => {
                        *base.add(40).cast::<u8>() = (1i32) as u8;
                        let GpuSamplerBindingLayout{ type_:type_3, } = e;
                        match type_3 {
                          Some(e) => {
                            *base.add(41).cast::<u8>() = (1i32) as u8;
                            *base.add(42).cast::<u8>() = (e.clone() as i32) as u8;
                          },
                          None => {
                            {
                              *base.add(41).cast::<u8>() = (0i32) as u8;
                            }
                          },
                        };},
                        None => {
                          {
                            *base.add(40).cast::<u8>() = (0i32) as u8;
                          }
                        },
                      };match texture1 {
                        Some(e) => {
                          *base.add(43).cast::<u8>() = (1i32) as u8;
                          let GpuTextureBindingLayout{ sample_type:sample_type4, view_dimension:view_dimension4, multisampled:multisampled4, } = e;
                          match sample_type4 {
                            Some(e) => {
                              *base.add(44).cast::<u8>() = (1i32) as u8;
                              *base.add(45).cast::<u8>() = (e.clone() as i32) as u8;
                            },
                            None => {
                              {
                                *base.add(44).cast::<u8>() = (0i32) as u8;
                              }
                            },
                          };match view_dimension4 {
                            Some(e) => {
                              *base.add(46).cast::<u8>() = (1i32) as u8;
                              *base.add(47).cast::<u8>() = (e.clone() as i32) as u8;
                            },
                            None => {
                              {
                                *base.add(46).cast::<u8>() = (0i32) as u8;
                              }
                            },
                          };match multisampled4 {
                            Some(e) => {
                              *base.add(48).cast::<u8>() = (1i32) as u8;
                              *base.add(49).cast::<u8>() = (match e { true => 1, false => 0 }) as u8;
                            },
                            None => {
                              {
                                *base.add(48).cast::<u8>() = (0i32) as u8;
                              }
                            },
                          };},
                          None => {
                            {
                              *base.add(43).cast::<u8>() = (0i32) as u8;
                            }
                          },
                        };match storage_texture1 {
                          Some(e) => {
                            *base.add(50).cast::<u8>() = (1i32) as u8;
                            let GpuStorageTextureBindingLayout{ access:access5, format:format5, view_dimension:view_dimension5, } = e;
                            match access5 {
                              Some(e) => {
                                *base.add(51).cast::<u8>() = (1i32) as u8;
                                *base.add(52).cast::<u8>() = (e.clone() as i32) as u8;
                              },
                              None => {
                                {
                                  *base.add(51).cast::<u8>() = (0i32) as u8;
                                }
                              },
                            };*base.add(53).cast::<u8>() = (format5.clone() as i32) as u8;
                            match view_dimension5 {
                              Some(e) => {
                                *base.add(54).cast::<u8>() = (1i32) as u8;
                                *base.add(55).cast::<u8>() = (e.clone() as i32) as u8;
                              },
                              None => {
                                {
                                  *base.add(54).cast::<u8>() = (0i32) as u8;
                                }
                              },
                            };},
                            None => {
                              {
                                *base.add(50).cast::<u8>() = (0i32) as u8;
                              }
                            },
                          };}
                        }
                        let (result8_0,result8_1,result8_2,) = match label0 {
                          Some(e) => {
                            let vec7 = e;
                            let ptr7 = vec7.as_ptr().cast::<u8>();
                            let len7 = vec7.len();

                            (1i32, ptr7.cast_mut(), len7)
                          },
                          None => {
                            (0i32, ::core::ptr::null_mut(), 0usize)
                          },
                        };
                        #[cfg(target_arch = "wasm32")]
                        #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                        unsafe extern "C" {
                          #[link_name = "[method]gpu-device.create-bind-group-layout"]
                          fn wit_import9(_: i32, _: *mut u8, _: usize, _: i32, _: *mut u8, _: usize, ) -> i32;
                        }

                        #[cfg(not(target_arch = "wasm32"))]
                        unsafe extern "C" fn wit_import9(_: i32, _: *mut u8, _: usize, _: i32, _: *mut u8, _: usize, ) -> i32 { unreachable!() }
                        let ret = wit_import9((self).handle() as i32, result6, len6, result8_0, result8_1, result8_2);
                        GpuBindGroupLayout::from_handle(ret as u32)
                      }
                    }
                  }
                  impl GpuDevice {
                    #[allow(unused_unsafe, clippy::all)]
                    #[allow(async_fn_in_trait)]
                    pub fn create_pipeline_layout(&self,descriptor: &GpuPipelineLayoutDescriptor<'_,>,) -> GpuPipelineLayout{
                      unsafe {
                        let GpuPipelineLayoutDescriptor{ bind_group_layouts:bind_group_layouts0, label:label0, } = descriptor;
                        let vec1 = bind_group_layouts0;
                        let len1 = vec1.len();
                        let layout1 = _rt::alloc::Layout::from_size_align(vec1.len() * 8, 4).unwrap();
                        let (result1, _cleanup1) = wit_bindgen::rt::Cleanup::new(layout1);for (i, e) in vec1.into_iter().enumerate() {
                          let base = result1.add(i * 8);
                          {
                            match e {
                              Some(e) => {
                                *base.add(0).cast::<u8>() = (1i32) as u8;
                                *base.add(4).cast::<i32>() = (e).handle() as i32;
                              },
                              None => {
                                {
                                  *base.add(0).cast::<u8>() = (0i32) as u8;
                                }
                              },
                            };}
                          }
                          let (result3_0,result3_1,result3_2,) = match label0 {
                            Some(e) => {
                              let vec2 = e;
                              let ptr2 = vec2.as_ptr().cast::<u8>();
                              let len2 = vec2.len();

                              (1i32, ptr2.cast_mut(), len2)
                            },
                            None => {
                              (0i32, ::core::ptr::null_mut(), 0usize)
                            },
                          };
                          #[cfg(target_arch = "wasm32")]
                          #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                          unsafe extern "C" {
                            #[link_name = "[method]gpu-device.create-pipeline-layout"]
                            fn wit_import4(_: i32, _: *mut u8, _: usize, _: i32, _: *mut u8, _: usize, ) -> i32;
                          }

                          #[cfg(not(target_arch = "wasm32"))]
                          unsafe extern "C" fn wit_import4(_: i32, _: *mut u8, _: usize, _: i32, _: *mut u8, _: usize, ) -> i32 { unreachable!() }
                          let ret = wit_import4((self).handle() as i32, result1, len1, result3_0, result3_1, result3_2);
                          GpuPipelineLayout::from_handle(ret as u32)
                        }
                      }
                    }
                    impl GpuDevice {
                      #[allow(unused_unsafe, clippy::all)]
                      #[allow(async_fn_in_trait)]
                      pub fn create_bind_group(&self,descriptor: &GpuBindGroupDescriptor<'_,>,) -> GpuBindGroup{
                        unsafe {
                          let GpuBindGroupDescriptor{ layout:layout0, entries:entries0, label:label0, } = descriptor;
                          let vec3 = entries0;
                          let len3 = vec3.len();
                          let layout3 = _rt::alloc::Layout::from_size_align(vec3.len() * 56, 8).unwrap();
                          let (result3, _cleanup3) = wit_bindgen::rt::Cleanup::new(layout3);for (i, e) in vec3.into_iter().enumerate() {
                            let base = result3.add(i * 56);
                            {
                              let GpuBindGroupEntry{ binding:binding1, resource:resource1, } = e;
                              *base.add(0).cast::<i32>() = _rt::as_i32(binding1);
                              match resource1 {
                                GpuBindingResource::GpuBufferBinding(e) => {
                                  *base.add(8).cast::<u8>() = (0i32) as u8;
                                  let GpuBufferBinding{ buffer:buffer2, offset:offset2, size:size2, } = e;
                                  *base.add(16).cast::<i32>() = (buffer2).handle() as i32;
                                  match offset2 {
                                    Some(e) => {
                                      *base.add(24).cast::<u8>() = (1i32) as u8;
                                      *base.add(32).cast::<i64>() = _rt::as_i64(e);
                                    },
                                    None => {
                                      {
                                        *base.add(24).cast::<u8>() = (0i32) as u8;
                                      }
                                    },
                                  };match size2 {
                                    Some(e) => {
                                      *base.add(40).cast::<u8>() = (1i32) as u8;
                                      *base.add(48).cast::<i64>() = _rt::as_i64(e);
                                    },
                                    None => {
                                      {
                                        *base.add(40).cast::<u8>() = (0i32) as u8;
                                      }
                                    },
                                  };},
                                  GpuBindingResource::GpuSampler(e) => {
                                    *base.add(8).cast::<u8>() = (1i32) as u8;
                                    *base.add(16).cast::<i32>() = (e).handle() as i32;
                                  },
                                  GpuBindingResource::GpuTextureView(e) => {
                                    *base.add(8).cast::<u8>() = (2i32) as u8;
                                    *base.add(16).cast::<i32>() = (e).handle() as i32;
                                  },
                                }
                              }
                            }
                            let (result5_0,result5_1,result5_2,) = match label0 {
                              Some(e) => {
                                let vec4 = e;
                                let ptr4 = vec4.as_ptr().cast::<u8>();
                                let len4 = vec4.len();

                                (1i32, ptr4.cast_mut(), len4)
                              },
                              None => {
                                (0i32, ::core::ptr::null_mut(), 0usize)
                              },
                            };
                            #[cfg(target_arch = "wasm32")]
                            #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                            unsafe extern "C" {
                              #[link_name = "[method]gpu-device.create-bind-group"]
                              fn wit_import6(_: i32, _: i32, _: *mut u8, _: usize, _: i32, _: *mut u8, _: usize, ) -> i32;
                            }

                            #[cfg(not(target_arch = "wasm32"))]
                            unsafe extern "C" fn wit_import6(_: i32, _: i32, _: *mut u8, _: usize, _: i32, _: *mut u8, _: usize, ) -> i32 { unreachable!() }
                            let ret = wit_import6((self).handle() as i32, (layout0).handle() as i32, result3, len3, result5_0, result5_1, result5_2);
                            GpuBindGroup::from_handle(ret as u32)
                          }
                        }
                      }
                      impl GpuDevice {
                        #[allow(unused_unsafe, clippy::all)]
                        #[allow(async_fn_in_trait)]
                        pub fn create_shader_module(&self,descriptor: &GpuShaderModuleDescriptor<'_,>,) -> GpuShaderModule{
                          unsafe {
                            let mut cleanup_list = _rt::Vec::new();
                            let GpuShaderModuleDescriptor{ code:code0, compilation_hints:compilation_hints0, label:label0, } = descriptor;
                            let vec1 = code0;
                            let ptr1 = vec1.as_ptr().cast::<u8>();
                            let len1 = vec1.len();
                            let (result5_0,result5_1,result5_2,) = match compilation_hints0 {
                              Some(e) => {
                                let vec4 = e;
                                let len4 = vec4.len();
                                let layout4 = _rt::alloc::Layout::from_size_align(vec4.len() * (8+3*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>()).unwrap();
                                let (result4, _cleanup4) = wit_bindgen::rt::Cleanup::new(layout4);cleanup_list.extend(_cleanup4);
                                for (i, e) in vec4.into_iter().enumerate() {
                                  let base = result4.add(i * (8+3*::core::mem::size_of::<*const u8>()));
                                  {
                                    let GpuShaderModuleCompilationHint{ entry_point:entry_point2, layout:layout2, } = e;
                                    let vec3 = entry_point2;
                                    let ptr3 = vec3.as_ptr().cast::<u8>();
                                    let len3 = vec3.len();
                                    *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len3;
                                    *base.add(0).cast::<*mut u8>() = ptr3.cast_mut();
                                    match layout2 {
                                      Some(e) => {
                                        *base.add(2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                        match e {
                                          GpuLayoutMode::Specific(e) => {
                                            *base.add(4+2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                            *base.add(8+2*::core::mem::size_of::<*const u8>()).cast::<i32>() = (e).handle() as i32;
                                          },
                                          GpuLayoutMode::Auto=> {
                                            {
                                              *base.add(4+2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                            }
                                          }
                                        }
                                      },
                                      None => {
                                        {
                                          *base.add(2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                        }
                                      },
                                    };}
                                  }

                                  (1i32, result4, len4)
                                },
                                None => {
                                  (0i32, ::core::ptr::null_mut(), 0usize)
                                },
                              };let (result7_0,result7_1,result7_2,) = match label0 {
                                Some(e) => {
                                  let vec6 = e;
                                  let ptr6 = vec6.as_ptr().cast::<u8>();
                                  let len6 = vec6.len();

                                  (1i32, ptr6.cast_mut(), len6)
                                },
                                None => {
                                  (0i32, ::core::ptr::null_mut(), 0usize)
                                },
                              };
                              #[cfg(target_arch = "wasm32")]
                              #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                              unsafe extern "C" {
                                #[link_name = "[method]gpu-device.create-shader-module"]
                                fn wit_import8(_: i32, _: *mut u8, _: usize, _: i32, _: *mut u8, _: usize, _: i32, _: *mut u8, _: usize, ) -> i32;
                              }

                              #[cfg(not(target_arch = "wasm32"))]
                              unsafe extern "C" fn wit_import8(_: i32, _: *mut u8, _: usize, _: i32, _: *mut u8, _: usize, _: i32, _: *mut u8, _: usize, ) -> i32 { unreachable!() }
                              let ret = wit_import8((self).handle() as i32, ptr1.cast_mut(), len1, result5_0, result5_1, result5_2, result7_0, result7_1, result7_2);
                              GpuShaderModule::from_handle(ret as u32)
                            }
                          }
                        }
                        impl GpuDevice {
                          #[allow(unused_unsafe, clippy::all)]
                          #[allow(async_fn_in_trait)]
                          pub fn create_compute_pipeline(&self,descriptor: GpuComputePipelineDescriptor<'_,>,) -> GpuComputePipeline{
                            unsafe {
                              let GpuComputePipelineDescriptor{ compute:compute0, layout:layout0, label:label0, } = &descriptor;
                              let GpuProgrammableStage{ module:module1, entry_point:entry_point1, constants:constants1, } = compute0;
                              let (result3_0,result3_1,result3_2,) = match entry_point1 {
                                Some(e) => {
                                  let vec2 = e;
                                  let ptr2 = vec2.as_ptr().cast::<u8>();
                                  let len2 = vec2.len();

                                  (1i32, ptr2.cast_mut(), len2)
                                },
                                None => {
                                  (0i32, ::core::ptr::null_mut(), 0usize)
                                },
                              };let (result4_0,result4_1,) = match constants1 {
                                Some(e) => (1i32, (e).take_handle() as i32),
                                None => {
                                  (0i32, 0i32)
                                },
                              };let (result5_0,result5_1,) = match layout0 {
                                GpuLayoutMode::Specific(e) => (0i32, (e).handle() as i32),
                                GpuLayoutMode::Auto=> {
                                  (1i32, 0i32)
                                }
                              };
                              let (result7_0,result7_1,result7_2,) = match label0 {
                                Some(e) => {
                                  let vec6 = e;
                                  let ptr6 = vec6.as_ptr().cast::<u8>();
                                  let len6 = vec6.len();

                                  (1i32, ptr6.cast_mut(), len6)
                                },
                                None => {
                                  (0i32, ::core::ptr::null_mut(), 0usize)
                                },
                              };
                              #[cfg(target_arch = "wasm32")]
                              #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                              unsafe extern "C" {
                                #[link_name = "[method]gpu-device.create-compute-pipeline"]
                                fn wit_import8(_: i32, _: i32, _: i32, _: *mut u8, _: usize, _: i32, _: i32, _: i32, _: i32, _: i32, _: *mut u8, _: usize, ) -> i32;
                              }

                              #[cfg(not(target_arch = "wasm32"))]
                              unsafe extern "C" fn wit_import8(_: i32, _: i32, _: i32, _: *mut u8, _: usize, _: i32, _: i32, _: i32, _: i32, _: i32, _: *mut u8, _: usize, ) -> i32 { unreachable!() }
                              let ret = wit_import8((self).handle() as i32, (module1).handle() as i32, result3_0, result3_1, result3_2, result4_0, result4_1, result5_0, result5_1, result7_0, result7_1, result7_2);
                              GpuComputePipeline::from_handle(ret as u32)
                            }
                          }
                        }
                        impl GpuDevice {
                          #[allow(unused_unsafe, clippy::all)]
                          #[allow(async_fn_in_trait)]
                          pub fn create_render_pipeline(&self,descriptor: GpuRenderPipelineDescriptor<'_,>,) -> GpuRenderPipeline{
                            unsafe {
                              let mut cleanup_list = _rt::Vec::new();

                              #[cfg_attr(target_pointer_width="64", repr(align(8)))]
                              #[cfg_attr(target_pointer_width="32", repr(align(4)))]
                              struct RetArea([::core::mem::MaybeUninit::<u8>; 128+18*::core::mem::size_of::<*const u8>()]);
                              let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 128+18*::core::mem::size_of::<*const u8>()]);
                              let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();*ptr0.add(0).cast::<i32>() = (self).handle() as i32;
                              let GpuRenderPipelineDescriptor{ vertex:vertex1, primitive:primitive1, depth_stencil:depth_stencil1, multisample:multisample1, fragment:fragment1, layout:layout1, label:label1, } = &descriptor;
                              let GpuVertexState{ buffers:buffers2, module:module2, entry_point:entry_point2, constants:constants2, } = vertex1;
                              match buffers2 {
                                Some(e) => {
                                  *ptr0.add(::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                  let vec6 = e;
                                  let len6 = vec6.len();
                                  let layout6 = _rt::alloc::Layout::from_size_align(vec6.len() * (24+2*::core::mem::size_of::<*const u8>()), 8).unwrap();
                                  let (result6, _cleanup6) = wit_bindgen::rt::Cleanup::new(layout6);cleanup_list.extend(_cleanup6);
                                  for (i, e) in vec6.into_iter().enumerate() {
                                    let base = result6.add(i * (24+2*::core::mem::size_of::<*const u8>()));
                                    {
                                      match e {
                                        Some(e) => {
                                          *base.add(0).cast::<u8>() = (1i32) as u8;
                                          let GpuVertexBufferLayout{ array_stride:array_stride3, step_mode:step_mode3, attributes:attributes3, } = e;
                                          *base.add(8).cast::<i64>() = _rt::as_i64(array_stride3);
                                          match step_mode3 {
                                            Some(e) => {
                                              *base.add(16).cast::<u8>() = (1i32) as u8;
                                              *base.add(17).cast::<u8>() = (e.clone() as i32) as u8;
                                            },
                                            None => {
                                              {
                                                *base.add(16).cast::<u8>() = (0i32) as u8;
                                              }
                                            },
                                          };let vec5 = attributes3;
                                          let len5 = vec5.len();
                                          let layout5 = _rt::alloc::Layout::from_size_align(vec5.len() * 24, 8).unwrap();
                                          let (result5, _cleanup5) = wit_bindgen::rt::Cleanup::new(layout5);cleanup_list.extend(_cleanup5);
                                          for (i, e) in vec5.into_iter().enumerate() {
                                            let base = result5.add(i * 24);
                                            {
                                              let GpuVertexAttribute{ format:format4, offset:offset4, shader_location:shader_location4, } = e;
                                              *base.add(0).cast::<u8>() = (format4.clone() as i32) as u8;
                                              *base.add(8).cast::<i64>() = _rt::as_i64(offset4);
                                              *base.add(16).cast::<i32>() = _rt::as_i32(shader_location4);
                                            }
                                          }
                                          *base.add(16+2*::core::mem::size_of::<*const u8>()).cast::<usize>() = len5;
                                          *base.add(16+1*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = result5;
                                        },
                                        None => {
                                          {
                                            *base.add(0).cast::<u8>() = (0i32) as u8;
                                          }
                                        },
                                      };}
                                    }
                                    *ptr0.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>() = len6;
                                    *ptr0.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = result6;
                                  },
                                  None => {
                                    {
                                      *ptr0.add(::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                    }
                                  },
                                };*ptr0.add(4*::core::mem::size_of::<*const u8>()).cast::<i32>() = (module2).handle() as i32;
                                match entry_point2 {
                                  Some(e) => {
                                    *ptr0.add(5*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                    let vec7 = e;
                                    let ptr7 = vec7.as_ptr().cast::<u8>();
                                    let len7 = vec7.len();
                                    *ptr0.add(7*::core::mem::size_of::<*const u8>()).cast::<usize>() = len7;
                                    *ptr0.add(6*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr7.cast_mut();
                                  },
                                  None => {
                                    {
                                      *ptr0.add(5*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                    }
                                  },
                                };match constants2 {
                                  Some(e) => {
                                    *ptr0.add(8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                    *ptr0.add(4+8*::core::mem::size_of::<*const u8>()).cast::<i32>() = (e).take_handle() as i32;
                                  },
                                  None => {
                                    {
                                      *ptr0.add(8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                    }
                                  },
                                };match primitive1 {
                                  Some(e) => {
                                    *ptr0.add(8+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                    let GpuPrimitiveState{ topology:topology8, strip_index_format:strip_index_format8, front_face:front_face8, cull_mode:cull_mode8, unclipped_depth:unclipped_depth8, } = e;
                                    match topology8 {
                                      Some(e) => {
                                        *ptr0.add(9+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                        *ptr0.add(10+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (e.clone() as i32) as u8;
                                      },
                                      None => {
                                        {
                                          *ptr0.add(9+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                        }
                                      },
                                    };match strip_index_format8 {
                                      Some(e) => {
                                        *ptr0.add(11+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                        *ptr0.add(12+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (e.clone() as i32) as u8;
                                      },
                                      None => {
                                        {
                                          *ptr0.add(11+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                        }
                                      },
                                    };match front_face8 {
                                      Some(e) => {
                                        *ptr0.add(13+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                        *ptr0.add(14+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (e.clone() as i32) as u8;
                                      },
                                      None => {
                                        {
                                          *ptr0.add(13+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                        }
                                      },
                                    };match cull_mode8 {
                                      Some(e) => {
                                        *ptr0.add(15+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                        *ptr0.add(16+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (e.clone() as i32) as u8;
                                      },
                                      None => {
                                        {
                                          *ptr0.add(15+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                        }
                                      },
                                    };match unclipped_depth8 {
                                      Some(e) => {
                                        *ptr0.add(17+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                        *ptr0.add(18+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (match e { true => 1, false => 0 }) as u8;
                                      },
                                      None => {
                                        {
                                          *ptr0.add(17+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                        }
                                      },
                                    };},
                                    None => {
                                      {
                                        *ptr0.add(8+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                      }
                                    },
                                  };match depth_stencil1 {
                                    Some(e) => {
                                      *ptr0.add(20+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                      let GpuDepthStencilState{ format:format9, depth_write_enabled:depth_write_enabled9, depth_compare:depth_compare9, stencil_front:stencil_front9, stencil_back:stencil_back9, stencil_read_mask:stencil_read_mask9, stencil_write_mask:stencil_write_mask9, depth_bias:depth_bias9, depth_bias_slope_scale:depth_bias_slope_scale9, depth_bias_clamp:depth_bias_clamp9, } = e;
                                      *ptr0.add(24+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (format9.clone() as i32) as u8;
                                      match depth_write_enabled9 {
                                        Some(e) => {
                                          *ptr0.add(25+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                          *ptr0.add(26+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (match e { true => 1, false => 0 }) as u8;
                                        },
                                        None => {
                                          {
                                            *ptr0.add(25+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                          }
                                        },
                                      };match depth_compare9 {
                                        Some(e) => {
                                          *ptr0.add(27+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                          *ptr0.add(28+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (e.clone() as i32) as u8;
                                        },
                                        None => {
                                          {
                                            *ptr0.add(27+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                          }
                                        },
                                      };match stencil_front9 {
                                        Some(e) => {
                                          *ptr0.add(29+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                          let GpuStencilFaceState{ compare:compare10, fail_op:fail_op10, depth_fail_op:depth_fail_op10, pass_op:pass_op10, } = e;
                                          match compare10 {
                                            Some(e) => {
                                              *ptr0.add(30+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                              *ptr0.add(31+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (e.clone() as i32) as u8;
                                            },
                                            None => {
                                              {
                                                *ptr0.add(30+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                              }
                                            },
                                          };match fail_op10 {
                                            Some(e) => {
                                              *ptr0.add(32+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                              *ptr0.add(33+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (e.clone() as i32) as u8;
                                            },
                                            None => {
                                              {
                                                *ptr0.add(32+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                              }
                                            },
                                          };match depth_fail_op10 {
                                            Some(e) => {
                                              *ptr0.add(34+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                              *ptr0.add(35+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (e.clone() as i32) as u8;
                                            },
                                            None => {
                                              {
                                                *ptr0.add(34+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                              }
                                            },
                                          };match pass_op10 {
                                            Some(e) => {
                                              *ptr0.add(36+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                              *ptr0.add(37+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (e.clone() as i32) as u8;
                                            },
                                            None => {
                                              {
                                                *ptr0.add(36+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                              }
                                            },
                                          };},
                                          None => {
                                            {
                                              *ptr0.add(29+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                            }
                                          },
                                        };match stencil_back9 {
                                          Some(e) => {
                                            *ptr0.add(38+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                            let GpuStencilFaceState{ compare:compare11, fail_op:fail_op11, depth_fail_op:depth_fail_op11, pass_op:pass_op11, } = e;
                                            match compare11 {
                                              Some(e) => {
                                                *ptr0.add(39+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                                *ptr0.add(40+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (e.clone() as i32) as u8;
                                              },
                                              None => {
                                                {
                                                  *ptr0.add(39+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                                }
                                              },
                                            };match fail_op11 {
                                              Some(e) => {
                                                *ptr0.add(41+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                                *ptr0.add(42+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (e.clone() as i32) as u8;
                                              },
                                              None => {
                                                {
                                                  *ptr0.add(41+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                                }
                                              },
                                            };match depth_fail_op11 {
                                              Some(e) => {
                                                *ptr0.add(43+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                                *ptr0.add(44+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (e.clone() as i32) as u8;
                                              },
                                              None => {
                                                {
                                                  *ptr0.add(43+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                                }
                                              },
                                            };match pass_op11 {
                                              Some(e) => {
                                                *ptr0.add(45+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                                *ptr0.add(46+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (e.clone() as i32) as u8;
                                              },
                                              None => {
                                                {
                                                  *ptr0.add(45+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                                }
                                              },
                                            };},
                                            None => {
                                              {
                                                *ptr0.add(38+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                              }
                                            },
                                          };match stencil_read_mask9 {
                                            Some(e) => {
                                              *ptr0.add(48+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                              *ptr0.add(52+8*::core::mem::size_of::<*const u8>()).cast::<i32>() = _rt::as_i32(e);
                                            },
                                            None => {
                                              {
                                                *ptr0.add(48+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                              }
                                            },
                                          };match stencil_write_mask9 {
                                            Some(e) => {
                                              *ptr0.add(56+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                              *ptr0.add(60+8*::core::mem::size_of::<*const u8>()).cast::<i32>() = _rt::as_i32(e);
                                            },
                                            None => {
                                              {
                                                *ptr0.add(56+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                              }
                                            },
                                          };match depth_bias9 {
                                            Some(e) => {
                                              *ptr0.add(64+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                              *ptr0.add(68+8*::core::mem::size_of::<*const u8>()).cast::<i32>() = _rt::as_i32(e);
                                            },
                                            None => {
                                              {
                                                *ptr0.add(64+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                              }
                                            },
                                          };match depth_bias_slope_scale9 {
                                            Some(e) => {
                                              *ptr0.add(72+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                              *ptr0.add(76+8*::core::mem::size_of::<*const u8>()).cast::<f32>() = _rt::as_f32(e);
                                            },
                                            None => {
                                              {
                                                *ptr0.add(72+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                              }
                                            },
                                          };match depth_bias_clamp9 {
                                            Some(e) => {
                                              *ptr0.add(80+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                              *ptr0.add(84+8*::core::mem::size_of::<*const u8>()).cast::<f32>() = _rt::as_f32(e);
                                            },
                                            None => {
                                              {
                                                *ptr0.add(80+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                              }
                                            },
                                          };},
                                          None => {
                                            {
                                              *ptr0.add(20+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                            }
                                          },
                                        };match multisample1 {
                                          Some(e) => {
                                            *ptr0.add(88+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                            let GpuMultisampleState{ count:count12, mask:mask12, alpha_to_coverage_enabled:alpha_to_coverage_enabled12, } = e;
                                            match count12 {
                                              Some(e) => {
                                                *ptr0.add(92+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                                *ptr0.add(96+8*::core::mem::size_of::<*const u8>()).cast::<i32>() = _rt::as_i32(e);
                                              },
                                              None => {
                                                {
                                                  *ptr0.add(92+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                                }
                                              },
                                            };match mask12 {
                                              Some(e) => {
                                                *ptr0.add(100+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                                *ptr0.add(104+8*::core::mem::size_of::<*const u8>()).cast::<i32>() = _rt::as_i32(e);
                                              },
                                              None => {
                                                {
                                                  *ptr0.add(100+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                                }
                                              },
                                            };match alpha_to_coverage_enabled12 {
                                              Some(e) => {
                                                *ptr0.add(108+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                                *ptr0.add(109+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (match e { true => 1, false => 0 }) as u8;
                                              },
                                              None => {
                                                {
                                                  *ptr0.add(108+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                                }
                                              },
                                            };},
                                            None => {
                                              {
                                                *ptr0.add(88+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                              }
                                            },
                                          };match fragment1 {
                                            Some(e) => {
                                              *ptr0.add(112+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                              let GpuFragmentState{ targets:targets13, module:module13, entry_point:entry_point13, constants:constants13, } = e;
                                              let vec18 = targets13;
                                              let len18 = vec18.len();
                                              let layout18 = _rt::alloc::Layout::from_size_align(vec18.len() * 28, 4).unwrap();
                                              let (result18, _cleanup18) = wit_bindgen::rt::Cleanup::new(layout18);cleanup_list.extend(_cleanup18);
                                              for (i, e) in vec18.into_iter().enumerate() {
                                                let base = result18.add(i * 28);
                                                {
                                                  match e {
                                                    Some(e) => {
                                                      *base.add(0).cast::<u8>() = (1i32) as u8;
                                                      let GpuColorTargetState{ format:format14, blend:blend14, write_mask:write_mask14, } = e;
                                                      *base.add(4).cast::<u8>() = (format14.clone() as i32) as u8;
                                                      match blend14 {
                                                        Some(e) => {
                                                          *base.add(5).cast::<u8>() = (1i32) as u8;
                                                          let GpuBlendState{ color:color15, alpha:alpha15, } = e;
                                                          let GpuBlendComponent{ operation:operation16, src_factor:src_factor16, dst_factor:dst_factor16, } = color15;
                                                          match operation16 {
                                                            Some(e) => {
                                                              *base.add(6).cast::<u8>() = (1i32) as u8;
                                                              *base.add(7).cast::<u8>() = (e.clone() as i32) as u8;
                                                            },
                                                            None => {
                                                              {
                                                                *base.add(6).cast::<u8>() = (0i32) as u8;
                                                              }
                                                            },
                                                          };match src_factor16 {
                                                            Some(e) => {
                                                              *base.add(8).cast::<u8>() = (1i32) as u8;
                                                              *base.add(9).cast::<u8>() = (e.clone() as i32) as u8;
                                                            },
                                                            None => {
                                                              {
                                                                *base.add(8).cast::<u8>() = (0i32) as u8;
                                                              }
                                                            },
                                                          };match dst_factor16 {
                                                            Some(e) => {
                                                              *base.add(10).cast::<u8>() = (1i32) as u8;
                                                              *base.add(11).cast::<u8>() = (e.clone() as i32) as u8;
                                                            },
                                                            None => {
                                                              {
                                                                *base.add(10).cast::<u8>() = (0i32) as u8;
                                                              }
                                                            },
                                                          };let GpuBlendComponent{ operation:operation17, src_factor:src_factor17, dst_factor:dst_factor17, } = alpha15;
                                                          match operation17 {
                                                            Some(e) => {
                                                              *base.add(12).cast::<u8>() = (1i32) as u8;
                                                              *base.add(13).cast::<u8>() = (e.clone() as i32) as u8;
                                                            },
                                                            None => {
                                                              {
                                                                *base.add(12).cast::<u8>() = (0i32) as u8;
                                                              }
                                                            },
                                                          };match src_factor17 {
                                                            Some(e) => {
                                                              *base.add(14).cast::<u8>() = (1i32) as u8;
                                                              *base.add(15).cast::<u8>() = (e.clone() as i32) as u8;
                                                            },
                                                            None => {
                                                              {
                                                                *base.add(14).cast::<u8>() = (0i32) as u8;
                                                              }
                                                            },
                                                          };match dst_factor17 {
                                                            Some(e) => {
                                                              *base.add(16).cast::<u8>() = (1i32) as u8;
                                                              *base.add(17).cast::<u8>() = (e.clone() as i32) as u8;
                                                            },
                                                            None => {
                                                              {
                                                                *base.add(16).cast::<u8>() = (0i32) as u8;
                                                              }
                                                            },
                                                          };},
                                                          None => {
                                                            {
                                                              *base.add(5).cast::<u8>() = (0i32) as u8;
                                                            }
                                                          },
                                                        };match write_mask14 {
                                                          Some(e) => {
                                                            *base.add(20).cast::<u8>() = (1i32) as u8;
                                                            *base.add(24).cast::<i32>() = _rt::as_i32(e);
                                                          },
                                                          None => {
                                                            {
                                                              *base.add(20).cast::<u8>() = (0i32) as u8;
                                                            }
                                                          },
                                                        };},
                                                        None => {
                                                          {
                                                            *base.add(0).cast::<u8>() = (0i32) as u8;
                                                          }
                                                        },
                                                      };}
                                                    }
                                                    *ptr0.add(112+10*::core::mem::size_of::<*const u8>()).cast::<usize>() = len18;
                                                    *ptr0.add(112+9*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = result18;
                                                    *ptr0.add(112+11*::core::mem::size_of::<*const u8>()).cast::<i32>() = (module13).handle() as i32;
                                                    match entry_point13 {
                                                      Some(e) => {
                                                        *ptr0.add(112+12*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                                        let vec19 = e;
                                                        let ptr19 = vec19.as_ptr().cast::<u8>();
                                                        let len19 = vec19.len();
                                                        *ptr0.add(112+14*::core::mem::size_of::<*const u8>()).cast::<usize>() = len19;
                                                        *ptr0.add(112+13*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr19.cast_mut();
                                                      },
                                                      None => {
                                                        {
                                                          *ptr0.add(112+12*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                                        }
                                                      },
                                                    };match constants13 {
                                                      Some(e) => {
                                                        *ptr0.add(112+15*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                                        *ptr0.add(116+15*::core::mem::size_of::<*const u8>()).cast::<i32>() = (e).take_handle() as i32;
                                                      },
                                                      None => {
                                                        {
                                                          *ptr0.add(112+15*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                                        }
                                                      },
                                                    };},
                                                    None => {
                                                      {
                                                        *ptr0.add(112+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                                      }
                                                    },
                                                  };match layout1 {
                                                    GpuLayoutMode::Specific(e) => {
                                                      *ptr0.add(120+15*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                                      *ptr0.add(124+15*::core::mem::size_of::<*const u8>()).cast::<i32>() = (e).handle() as i32;
                                                    },
                                                    GpuLayoutMode::Auto=> {
                                                      {
                                                        *ptr0.add(120+15*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                                      }
                                                    }
                                                  }
                                                  match label1 {
                                                    Some(e) => {
                                                      *ptr0.add(128+15*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                                      let vec20 = e;
                                                      let ptr20 = vec20.as_ptr().cast::<u8>();
                                                      let len20 = vec20.len();
                                                      *ptr0.add(128+17*::core::mem::size_of::<*const u8>()).cast::<usize>() = len20;
                                                      *ptr0.add(128+16*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr20.cast_mut();
                                                    },
                                                    None => {
                                                      {
                                                        *ptr0.add(128+15*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                                      }
                                                    },
                                                  };
                                                  #[cfg(target_arch = "wasm32")]
                                                  #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                  unsafe extern "C" {
                                                    #[link_name = "[method]gpu-device.create-render-pipeline"]
                                                    fn wit_import21(_: *mut u8, ) -> i32;
                                                  }

                                                  #[cfg(not(target_arch = "wasm32"))]
                                                  unsafe extern "C" fn wit_import21(_: *mut u8, ) -> i32 { unreachable!() }
                                                  let ret = wit_import21(ptr0);
                                                  GpuRenderPipeline::from_handle(ret as u32)
                                                }
                                              }
                                            }
                                            impl GpuDevice {
                                              #[allow(unused_unsafe, clippy::all)]
                                              #[allow(async_fn_in_trait)]
                                              pub fn create_compute_pipeline_async(&self,descriptor: GpuComputePipelineDescriptor<'_,>,) -> Result<GpuComputePipeline,CreatePipelineError>{
                                                unsafe {

                                                  #[cfg_attr(target_pointer_width="64", repr(align(8)))]
                                                  #[cfg_attr(target_pointer_width="32", repr(align(4)))]
                                                  struct RetArea([::core::mem::MaybeUninit::<u8>; 4*::core::mem::size_of::<*const u8>()]);
                                                  let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 4*::core::mem::size_of::<*const u8>()]);
                                                  let GpuComputePipelineDescriptor{ compute:compute0, layout:layout0, label:label0, } = &descriptor;
                                                  let GpuProgrammableStage{ module:module1, entry_point:entry_point1, constants:constants1, } = compute0;
                                                  let (result3_0,result3_1,result3_2,) = match entry_point1 {
                                                    Some(e) => {
                                                      let vec2 = e;
                                                      let ptr2 = vec2.as_ptr().cast::<u8>();
                                                      let len2 = vec2.len();

                                                      (1i32, ptr2.cast_mut(), len2)
                                                    },
                                                    None => {
                                                      (0i32, ::core::ptr::null_mut(), 0usize)
                                                    },
                                                  };let (result4_0,result4_1,) = match constants1 {
                                                    Some(e) => (1i32, (e).take_handle() as i32),
                                                    None => {
                                                      (0i32, 0i32)
                                                    },
                                                  };let (result5_0,result5_1,) = match layout0 {
                                                    GpuLayoutMode::Specific(e) => (0i32, (e).handle() as i32),
                                                    GpuLayoutMode::Auto=> {
                                                      (1i32, 0i32)
                                                    }
                                                  };
                                                  let (result7_0,result7_1,result7_2,) = match label0 {
                                                    Some(e) => {
                                                      let vec6 = e;
                                                      let ptr6 = vec6.as_ptr().cast::<u8>();
                                                      let len6 = vec6.len();

                                                      (1i32, ptr6.cast_mut(), len6)
                                                    },
                                                    None => {
                                                      (0i32, ::core::ptr::null_mut(), 0usize)
                                                    },
                                                  };let ptr8 = ret_area.0.as_mut_ptr().cast::<u8>();
                                                  #[cfg(target_arch = "wasm32")]
                                                  #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                  unsafe extern "C" {
                                                    #[link_name = "[method]gpu-device.create-compute-pipeline-async"]
                                                    fn wit_import9(_: i32, _: i32, _: i32, _: *mut u8, _: usize, _: i32, _: i32, _: i32, _: i32, _: i32, _: *mut u8, _: usize, _: *mut u8, );
                                                  }

                                                  #[cfg(not(target_arch = "wasm32"))]
                                                  unsafe extern "C" fn wit_import9(_: i32, _: i32, _: i32, _: *mut u8, _: usize, _: i32, _: i32, _: i32, _: i32, _: i32, _: *mut u8, _: usize, _: *mut u8, ) { unreachable!() }
                                                  wit_import9((self).handle() as i32, (module1).handle() as i32, result3_0, result3_1, result3_2, result4_0, result4_1, result5_0, result5_1, result7_0, result7_1, result7_2, ptr8);
                                                  let l10 = i32::from(*ptr8.add(0).cast::<u8>());
                                                  let result18 = match l10 {
                                                    0 => {
                                                      let e = {
                                                        let l11 = *ptr8.add(::core::mem::size_of::<*const u8>()).cast::<i32>();

                                                        GpuComputePipeline::from_handle(l11 as u32)
                                                      };
                                                      Ok(e)
                                                    }
                                                    1 => {
                                                      let e = {
                                                        let l12 = i32::from(*ptr8.add(::core::mem::size_of::<*const u8>()).cast::<u8>());
                                                        let v14 = match l12 {
                                                          n => {
                                                            debug_assert_eq!(n, 0, "invalid enum discriminant");
                                                            let e14 = {
                                                              let l13 = i32::from(*ptr8.add(1+1*::core::mem::size_of::<*const u8>()).cast::<u8>());

                                                              GpuPipelineErrorReason::_lift(l13 as u8)
                                                            };
                                                            CreatePipelineErrorKind::GpuPipelineError(e14)
                                                          }
                                                        };
                                                        let l15 = *ptr8.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                                                        let l16 = *ptr8.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>();
                                                        let len17 = l16;
                                                        let bytes17 = _rt::Vec::from_raw_parts(l15.cast(), len17, len17);

                                                        CreatePipelineError{
                                                          kind: v14,
                                                          message: _rt::string_lift(bytes17),
                                                        }
                                                      };
                                                      Err(e)
                                                    }
                                                    _ => _rt::invalid_enum_discriminant(),
                                                  };
                                                  result18
                                                }
                                              }
                                            }
                                            impl GpuDevice {
                                              #[allow(unused_unsafe, clippy::all)]
                                              #[allow(async_fn_in_trait)]
                                              pub fn create_render_pipeline_async(&self,descriptor: GpuRenderPipelineDescriptor<'_,>,) -> Result<GpuRenderPipeline,CreatePipelineError>{
                                                unsafe {
                                                  let mut cleanup_list = _rt::Vec::new();

                                                  #[cfg_attr(target_pointer_width="64", repr(align(8)))]
                                                  #[cfg_attr(target_pointer_width="32", repr(align(4)))]
                                                  struct RetArea([::core::mem::MaybeUninit::<u8>; 128+18*::core::mem::size_of::<*const u8>()]);
                                                  let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 128+18*::core::mem::size_of::<*const u8>()]);
                                                  let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();*ptr0.add(0).cast::<i32>() = (self).handle() as i32;
                                                  let GpuRenderPipelineDescriptor{ vertex:vertex1, primitive:primitive1, depth_stencil:depth_stencil1, multisample:multisample1, fragment:fragment1, layout:layout1, label:label1, } = &descriptor;
                                                  let GpuVertexState{ buffers:buffers2, module:module2, entry_point:entry_point2, constants:constants2, } = vertex1;
                                                  match buffers2 {
                                                    Some(e) => {
                                                      *ptr0.add(::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                                      let vec6 = e;
                                                      let len6 = vec6.len();
                                                      let layout6 = _rt::alloc::Layout::from_size_align(vec6.len() * (24+2*::core::mem::size_of::<*const u8>()), 8).unwrap();
                                                      let (result6, _cleanup6) = wit_bindgen::rt::Cleanup::new(layout6);cleanup_list.extend(_cleanup6);
                                                      for (i, e) in vec6.into_iter().enumerate() {
                                                        let base = result6.add(i * (24+2*::core::mem::size_of::<*const u8>()));
                                                        {
                                                          match e {
                                                            Some(e) => {
                                                              *base.add(0).cast::<u8>() = (1i32) as u8;
                                                              let GpuVertexBufferLayout{ array_stride:array_stride3, step_mode:step_mode3, attributes:attributes3, } = e;
                                                              *base.add(8).cast::<i64>() = _rt::as_i64(array_stride3);
                                                              match step_mode3 {
                                                                Some(e) => {
                                                                  *base.add(16).cast::<u8>() = (1i32) as u8;
                                                                  *base.add(17).cast::<u8>() = (e.clone() as i32) as u8;
                                                                },
                                                                None => {
                                                                  {
                                                                    *base.add(16).cast::<u8>() = (0i32) as u8;
                                                                  }
                                                                },
                                                              };let vec5 = attributes3;
                                                              let len5 = vec5.len();
                                                              let layout5 = _rt::alloc::Layout::from_size_align(vec5.len() * 24, 8).unwrap();
                                                              let (result5, _cleanup5) = wit_bindgen::rt::Cleanup::new(layout5);cleanup_list.extend(_cleanup5);
                                                              for (i, e) in vec5.into_iter().enumerate() {
                                                                let base = result5.add(i * 24);
                                                                {
                                                                  let GpuVertexAttribute{ format:format4, offset:offset4, shader_location:shader_location4, } = e;
                                                                  *base.add(0).cast::<u8>() = (format4.clone() as i32) as u8;
                                                                  *base.add(8).cast::<i64>() = _rt::as_i64(offset4);
                                                                  *base.add(16).cast::<i32>() = _rt::as_i32(shader_location4);
                                                                }
                                                              }
                                                              *base.add(16+2*::core::mem::size_of::<*const u8>()).cast::<usize>() = len5;
                                                              *base.add(16+1*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = result5;
                                                            },
                                                            None => {
                                                              {
                                                                *base.add(0).cast::<u8>() = (0i32) as u8;
                                                              }
                                                            },
                                                          };}
                                                        }
                                                        *ptr0.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>() = len6;
                                                        *ptr0.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = result6;
                                                      },
                                                      None => {
                                                        {
                                                          *ptr0.add(::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                                        }
                                                      },
                                                    };*ptr0.add(4*::core::mem::size_of::<*const u8>()).cast::<i32>() = (module2).handle() as i32;
                                                    match entry_point2 {
                                                      Some(e) => {
                                                        *ptr0.add(5*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                                        let vec7 = e;
                                                        let ptr7 = vec7.as_ptr().cast::<u8>();
                                                        let len7 = vec7.len();
                                                        *ptr0.add(7*::core::mem::size_of::<*const u8>()).cast::<usize>() = len7;
                                                        *ptr0.add(6*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr7.cast_mut();
                                                      },
                                                      None => {
                                                        {
                                                          *ptr0.add(5*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                                        }
                                                      },
                                                    };match constants2 {
                                                      Some(e) => {
                                                        *ptr0.add(8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                                        *ptr0.add(4+8*::core::mem::size_of::<*const u8>()).cast::<i32>() = (e).take_handle() as i32;
                                                      },
                                                      None => {
                                                        {
                                                          *ptr0.add(8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                                        }
                                                      },
                                                    };match primitive1 {
                                                      Some(e) => {
                                                        *ptr0.add(8+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                                        let GpuPrimitiveState{ topology:topology8, strip_index_format:strip_index_format8, front_face:front_face8, cull_mode:cull_mode8, unclipped_depth:unclipped_depth8, } = e;
                                                        match topology8 {
                                                          Some(e) => {
                                                            *ptr0.add(9+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                                            *ptr0.add(10+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (e.clone() as i32) as u8;
                                                          },
                                                          None => {
                                                            {
                                                              *ptr0.add(9+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                                            }
                                                          },
                                                        };match strip_index_format8 {
                                                          Some(e) => {
                                                            *ptr0.add(11+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                                            *ptr0.add(12+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (e.clone() as i32) as u8;
                                                          },
                                                          None => {
                                                            {
                                                              *ptr0.add(11+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                                            }
                                                          },
                                                        };match front_face8 {
                                                          Some(e) => {
                                                            *ptr0.add(13+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                                            *ptr0.add(14+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (e.clone() as i32) as u8;
                                                          },
                                                          None => {
                                                            {
                                                              *ptr0.add(13+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                                            }
                                                          },
                                                        };match cull_mode8 {
                                                          Some(e) => {
                                                            *ptr0.add(15+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                                            *ptr0.add(16+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (e.clone() as i32) as u8;
                                                          },
                                                          None => {
                                                            {
                                                              *ptr0.add(15+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                                            }
                                                          },
                                                        };match unclipped_depth8 {
                                                          Some(e) => {
                                                            *ptr0.add(17+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                                            *ptr0.add(18+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (match e { true => 1, false => 0 }) as u8;
                                                          },
                                                          None => {
                                                            {
                                                              *ptr0.add(17+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                                            }
                                                          },
                                                        };},
                                                        None => {
                                                          {
                                                            *ptr0.add(8+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                                          }
                                                        },
                                                      };match depth_stencil1 {
                                                        Some(e) => {
                                                          *ptr0.add(20+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                                          let GpuDepthStencilState{ format:format9, depth_write_enabled:depth_write_enabled9, depth_compare:depth_compare9, stencil_front:stencil_front9, stencil_back:stencil_back9, stencil_read_mask:stencil_read_mask9, stencil_write_mask:stencil_write_mask9, depth_bias:depth_bias9, depth_bias_slope_scale:depth_bias_slope_scale9, depth_bias_clamp:depth_bias_clamp9, } = e;
                                                          *ptr0.add(24+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (format9.clone() as i32) as u8;
                                                          match depth_write_enabled9 {
                                                            Some(e) => {
                                                              *ptr0.add(25+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                                              *ptr0.add(26+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (match e { true => 1, false => 0 }) as u8;
                                                            },
                                                            None => {
                                                              {
                                                                *ptr0.add(25+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                                              }
                                                            },
                                                          };match depth_compare9 {
                                                            Some(e) => {
                                                              *ptr0.add(27+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                                              *ptr0.add(28+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (e.clone() as i32) as u8;
                                                            },
                                                            None => {
                                                              {
                                                                *ptr0.add(27+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                                              }
                                                            },
                                                          };match stencil_front9 {
                                                            Some(e) => {
                                                              *ptr0.add(29+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                                              let GpuStencilFaceState{ compare:compare10, fail_op:fail_op10, depth_fail_op:depth_fail_op10, pass_op:pass_op10, } = e;
                                                              match compare10 {
                                                                Some(e) => {
                                                                  *ptr0.add(30+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                                                  *ptr0.add(31+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (e.clone() as i32) as u8;
                                                                },
                                                                None => {
                                                                  {
                                                                    *ptr0.add(30+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                                                  }
                                                                },
                                                              };match fail_op10 {
                                                                Some(e) => {
                                                                  *ptr0.add(32+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                                                  *ptr0.add(33+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (e.clone() as i32) as u8;
                                                                },
                                                                None => {
                                                                  {
                                                                    *ptr0.add(32+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                                                  }
                                                                },
                                                              };match depth_fail_op10 {
                                                                Some(e) => {
                                                                  *ptr0.add(34+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                                                  *ptr0.add(35+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (e.clone() as i32) as u8;
                                                                },
                                                                None => {
                                                                  {
                                                                    *ptr0.add(34+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                                                  }
                                                                },
                                                              };match pass_op10 {
                                                                Some(e) => {
                                                                  *ptr0.add(36+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                                                  *ptr0.add(37+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (e.clone() as i32) as u8;
                                                                },
                                                                None => {
                                                                  {
                                                                    *ptr0.add(36+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                                                  }
                                                                },
                                                              };},
                                                              None => {
                                                                {
                                                                  *ptr0.add(29+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                                                }
                                                              },
                                                            };match stencil_back9 {
                                                              Some(e) => {
                                                                *ptr0.add(38+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                                                let GpuStencilFaceState{ compare:compare11, fail_op:fail_op11, depth_fail_op:depth_fail_op11, pass_op:pass_op11, } = e;
                                                                match compare11 {
                                                                  Some(e) => {
                                                                    *ptr0.add(39+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                                                    *ptr0.add(40+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (e.clone() as i32) as u8;
                                                                  },
                                                                  None => {
                                                                    {
                                                                      *ptr0.add(39+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                                                    }
                                                                  },
                                                                };match fail_op11 {
                                                                  Some(e) => {
                                                                    *ptr0.add(41+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                                                    *ptr0.add(42+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (e.clone() as i32) as u8;
                                                                  },
                                                                  None => {
                                                                    {
                                                                      *ptr0.add(41+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                                                    }
                                                                  },
                                                                };match depth_fail_op11 {
                                                                  Some(e) => {
                                                                    *ptr0.add(43+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                                                    *ptr0.add(44+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (e.clone() as i32) as u8;
                                                                  },
                                                                  None => {
                                                                    {
                                                                      *ptr0.add(43+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                                                    }
                                                                  },
                                                                };match pass_op11 {
                                                                  Some(e) => {
                                                                    *ptr0.add(45+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                                                    *ptr0.add(46+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (e.clone() as i32) as u8;
                                                                  },
                                                                  None => {
                                                                    {
                                                                      *ptr0.add(45+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                                                    }
                                                                  },
                                                                };},
                                                                None => {
                                                                  {
                                                                    *ptr0.add(38+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                                                  }
                                                                },
                                                              };match stencil_read_mask9 {
                                                                Some(e) => {
                                                                  *ptr0.add(48+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                                                  *ptr0.add(52+8*::core::mem::size_of::<*const u8>()).cast::<i32>() = _rt::as_i32(e);
                                                                },
                                                                None => {
                                                                  {
                                                                    *ptr0.add(48+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                                                  }
                                                                },
                                                              };match stencil_write_mask9 {
                                                                Some(e) => {
                                                                  *ptr0.add(56+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                                                  *ptr0.add(60+8*::core::mem::size_of::<*const u8>()).cast::<i32>() = _rt::as_i32(e);
                                                                },
                                                                None => {
                                                                  {
                                                                    *ptr0.add(56+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                                                  }
                                                                },
                                                              };match depth_bias9 {
                                                                Some(e) => {
                                                                  *ptr0.add(64+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                                                  *ptr0.add(68+8*::core::mem::size_of::<*const u8>()).cast::<i32>() = _rt::as_i32(e);
                                                                },
                                                                None => {
                                                                  {
                                                                    *ptr0.add(64+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                                                  }
                                                                },
                                                              };match depth_bias_slope_scale9 {
                                                                Some(e) => {
                                                                  *ptr0.add(72+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                                                  *ptr0.add(76+8*::core::mem::size_of::<*const u8>()).cast::<f32>() = _rt::as_f32(e);
                                                                },
                                                                None => {
                                                                  {
                                                                    *ptr0.add(72+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                                                  }
                                                                },
                                                              };match depth_bias_clamp9 {
                                                                Some(e) => {
                                                                  *ptr0.add(80+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                                                  *ptr0.add(84+8*::core::mem::size_of::<*const u8>()).cast::<f32>() = _rt::as_f32(e);
                                                                },
                                                                None => {
                                                                  {
                                                                    *ptr0.add(80+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                                                  }
                                                                },
                                                              };},
                                                              None => {
                                                                {
                                                                  *ptr0.add(20+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                                                }
                                                              },
                                                            };match multisample1 {
                                                              Some(e) => {
                                                                *ptr0.add(88+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                                                let GpuMultisampleState{ count:count12, mask:mask12, alpha_to_coverage_enabled:alpha_to_coverage_enabled12, } = e;
                                                                match count12 {
                                                                  Some(e) => {
                                                                    *ptr0.add(92+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                                                    *ptr0.add(96+8*::core::mem::size_of::<*const u8>()).cast::<i32>() = _rt::as_i32(e);
                                                                  },
                                                                  None => {
                                                                    {
                                                                      *ptr0.add(92+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                                                    }
                                                                  },
                                                                };match mask12 {
                                                                  Some(e) => {
                                                                    *ptr0.add(100+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                                                    *ptr0.add(104+8*::core::mem::size_of::<*const u8>()).cast::<i32>() = _rt::as_i32(e);
                                                                  },
                                                                  None => {
                                                                    {
                                                                      *ptr0.add(100+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                                                    }
                                                                  },
                                                                };match alpha_to_coverage_enabled12 {
                                                                  Some(e) => {
                                                                    *ptr0.add(108+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                                                    *ptr0.add(109+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (match e { true => 1, false => 0 }) as u8;
                                                                  },
                                                                  None => {
                                                                    {
                                                                      *ptr0.add(108+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                                                    }
                                                                  },
                                                                };},
                                                                None => {
                                                                  {
                                                                    *ptr0.add(88+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                                                  }
                                                                },
                                                              };match fragment1 {
                                                                Some(e) => {
                                                                  *ptr0.add(112+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                                                  let GpuFragmentState{ targets:targets13, module:module13, entry_point:entry_point13, constants:constants13, } = e;
                                                                  let vec18 = targets13;
                                                                  let len18 = vec18.len();
                                                                  let layout18 = _rt::alloc::Layout::from_size_align(vec18.len() * 28, 4).unwrap();
                                                                  let (result18, _cleanup18) = wit_bindgen::rt::Cleanup::new(layout18);cleanup_list.extend(_cleanup18);
                                                                  for (i, e) in vec18.into_iter().enumerate() {
                                                                    let base = result18.add(i * 28);
                                                                    {
                                                                      match e {
                                                                        Some(e) => {
                                                                          *base.add(0).cast::<u8>() = (1i32) as u8;
                                                                          let GpuColorTargetState{ format:format14, blend:blend14, write_mask:write_mask14, } = e;
                                                                          *base.add(4).cast::<u8>() = (format14.clone() as i32) as u8;
                                                                          match blend14 {
                                                                            Some(e) => {
                                                                              *base.add(5).cast::<u8>() = (1i32) as u8;
                                                                              let GpuBlendState{ color:color15, alpha:alpha15, } = e;
                                                                              let GpuBlendComponent{ operation:operation16, src_factor:src_factor16, dst_factor:dst_factor16, } = color15;
                                                                              match operation16 {
                                                                                Some(e) => {
                                                                                  *base.add(6).cast::<u8>() = (1i32) as u8;
                                                                                  *base.add(7).cast::<u8>() = (e.clone() as i32) as u8;
                                                                                },
                                                                                None => {
                                                                                  {
                                                                                    *base.add(6).cast::<u8>() = (0i32) as u8;
                                                                                  }
                                                                                },
                                                                              };match src_factor16 {
                                                                                Some(e) => {
                                                                                  *base.add(8).cast::<u8>() = (1i32) as u8;
                                                                                  *base.add(9).cast::<u8>() = (e.clone() as i32) as u8;
                                                                                },
                                                                                None => {
                                                                                  {
                                                                                    *base.add(8).cast::<u8>() = (0i32) as u8;
                                                                                  }
                                                                                },
                                                                              };match dst_factor16 {
                                                                                Some(e) => {
                                                                                  *base.add(10).cast::<u8>() = (1i32) as u8;
                                                                                  *base.add(11).cast::<u8>() = (e.clone() as i32) as u8;
                                                                                },
                                                                                None => {
                                                                                  {
                                                                                    *base.add(10).cast::<u8>() = (0i32) as u8;
                                                                                  }
                                                                                },
                                                                              };let GpuBlendComponent{ operation:operation17, src_factor:src_factor17, dst_factor:dst_factor17, } = alpha15;
                                                                              match operation17 {
                                                                                Some(e) => {
                                                                                  *base.add(12).cast::<u8>() = (1i32) as u8;
                                                                                  *base.add(13).cast::<u8>() = (e.clone() as i32) as u8;
                                                                                },
                                                                                None => {
                                                                                  {
                                                                                    *base.add(12).cast::<u8>() = (0i32) as u8;
                                                                                  }
                                                                                },
                                                                              };match src_factor17 {
                                                                                Some(e) => {
                                                                                  *base.add(14).cast::<u8>() = (1i32) as u8;
                                                                                  *base.add(15).cast::<u8>() = (e.clone() as i32) as u8;
                                                                                },
                                                                                None => {
                                                                                  {
                                                                                    *base.add(14).cast::<u8>() = (0i32) as u8;
                                                                                  }
                                                                                },
                                                                              };match dst_factor17 {
                                                                                Some(e) => {
                                                                                  *base.add(16).cast::<u8>() = (1i32) as u8;
                                                                                  *base.add(17).cast::<u8>() = (e.clone() as i32) as u8;
                                                                                },
                                                                                None => {
                                                                                  {
                                                                                    *base.add(16).cast::<u8>() = (0i32) as u8;
                                                                                  }
                                                                                },
                                                                              };},
                                                                              None => {
                                                                                {
                                                                                  *base.add(5).cast::<u8>() = (0i32) as u8;
                                                                                }
                                                                              },
                                                                            };match write_mask14 {
                                                                              Some(e) => {
                                                                                *base.add(20).cast::<u8>() = (1i32) as u8;
                                                                                *base.add(24).cast::<i32>() = _rt::as_i32(e);
                                                                              },
                                                                              None => {
                                                                                {
                                                                                  *base.add(20).cast::<u8>() = (0i32) as u8;
                                                                                }
                                                                              },
                                                                            };},
                                                                            None => {
                                                                              {
                                                                                *base.add(0).cast::<u8>() = (0i32) as u8;
                                                                              }
                                                                            },
                                                                          };}
                                                                        }
                                                                        *ptr0.add(112+10*::core::mem::size_of::<*const u8>()).cast::<usize>() = len18;
                                                                        *ptr0.add(112+9*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = result18;
                                                                        *ptr0.add(112+11*::core::mem::size_of::<*const u8>()).cast::<i32>() = (module13).handle() as i32;
                                                                        match entry_point13 {
                                                                          Some(e) => {
                                                                            *ptr0.add(112+12*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                                                            let vec19 = e;
                                                                            let ptr19 = vec19.as_ptr().cast::<u8>();
                                                                            let len19 = vec19.len();
                                                                            *ptr0.add(112+14*::core::mem::size_of::<*const u8>()).cast::<usize>() = len19;
                                                                            *ptr0.add(112+13*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr19.cast_mut();
                                                                          },
                                                                          None => {
                                                                            {
                                                                              *ptr0.add(112+12*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                                                            }
                                                                          },
                                                                        };match constants13 {
                                                                          Some(e) => {
                                                                            *ptr0.add(112+15*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                                                            *ptr0.add(116+15*::core::mem::size_of::<*const u8>()).cast::<i32>() = (e).take_handle() as i32;
                                                                          },
                                                                          None => {
                                                                            {
                                                                              *ptr0.add(112+15*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                                                            }
                                                                          },
                                                                        };},
                                                                        None => {
                                                                          {
                                                                            *ptr0.add(112+8*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                                                          }
                                                                        },
                                                                      };match layout1 {
                                                                        GpuLayoutMode::Specific(e) => {
                                                                          *ptr0.add(120+15*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                                                          *ptr0.add(124+15*::core::mem::size_of::<*const u8>()).cast::<i32>() = (e).handle() as i32;
                                                                        },
                                                                        GpuLayoutMode::Auto=> {
                                                                          {
                                                                            *ptr0.add(120+15*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                                                          }
                                                                        }
                                                                      }
                                                                      match label1 {
                                                                        Some(e) => {
                                                                          *ptr0.add(128+15*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                                                          let vec20 = e;
                                                                          let ptr20 = vec20.as_ptr().cast::<u8>();
                                                                          let len20 = vec20.len();
                                                                          *ptr0.add(128+17*::core::mem::size_of::<*const u8>()).cast::<usize>() = len20;
                                                                          *ptr0.add(128+16*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr20.cast_mut();
                                                                        },
                                                                        None => {
                                                                          {
                                                                            *ptr0.add(128+15*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                                                          }
                                                                        },
                                                                      };let ptr21 = ret_area.0.as_mut_ptr().cast::<u8>();
                                                                      #[cfg(target_arch = "wasm32")]
                                                                      #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                      unsafe extern "C" {
                                                                        #[link_name = "[method]gpu-device.create-render-pipeline-async"]
                                                                        fn wit_import22(_: *mut u8, _: *mut u8, );
                                                                      }

                                                                      #[cfg(not(target_arch = "wasm32"))]
                                                                      unsafe extern "C" fn wit_import22(_: *mut u8, _: *mut u8, ) { unreachable!() }
                                                                      wit_import22(ptr0, ptr21);
                                                                      let l23 = i32::from(*ptr21.add(0).cast::<u8>());
                                                                      let result31 = match l23 {
                                                                        0 => {
                                                                          let e = {
                                                                            let l24 = *ptr21.add(::core::mem::size_of::<*const u8>()).cast::<i32>();

                                                                            GpuRenderPipeline::from_handle(l24 as u32)
                                                                          };
                                                                          Ok(e)
                                                                        }
                                                                        1 => {
                                                                          let e = {
                                                                            let l25 = i32::from(*ptr21.add(::core::mem::size_of::<*const u8>()).cast::<u8>());
                                                                            let v27 = match l25 {
                                                                              n => {
                                                                                debug_assert_eq!(n, 0, "invalid enum discriminant");
                                                                                let e27 = {
                                                                                  let l26 = i32::from(*ptr21.add(1+1*::core::mem::size_of::<*const u8>()).cast::<u8>());

                                                                                  GpuPipelineErrorReason::_lift(l26 as u8)
                                                                                };
                                                                                CreatePipelineErrorKind::GpuPipelineError(e27)
                                                                              }
                                                                            };
                                                                            let l28 = *ptr21.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                                                                            let l29 = *ptr21.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>();
                                                                            let len30 = l29;
                                                                            let bytes30 = _rt::Vec::from_raw_parts(l28.cast(), len30, len30);

                                                                            CreatePipelineError{
                                                                              kind: v27,
                                                                              message: _rt::string_lift(bytes30),
                                                                            }
                                                                          };
                                                                          Err(e)
                                                                        }
                                                                        _ => _rt::invalid_enum_discriminant(),
                                                                      };
                                                                      result31
                                                                    }
                                                                  }
                                                                }
                                                                impl GpuDevice {
                                                                  #[allow(unused_unsafe, clippy::all)]
                                                                  #[allow(async_fn_in_trait)]
                                                                  pub fn create_command_encoder(&self,descriptor: Option<&GpuCommandEncoderDescriptor>,) -> GpuCommandEncoder{
                                                                    unsafe {
                                                                      let (result3_0,result3_1,result3_2,result3_3,) = match descriptor {
                                                                        Some(e) => {
                                                                          let GpuCommandEncoderDescriptor{ label:label0, } = e;
                                                                          let (result2_0,result2_1,result2_2,) = match label0 {
                                                                            Some(e) => {
                                                                              let vec1 = e;
                                                                              let ptr1 = vec1.as_ptr().cast::<u8>();
                                                                              let len1 = vec1.len();

                                                                              (1i32, ptr1.cast_mut(), len1)
                                                                            },
                                                                            None => {
                                                                              (0i32, ::core::ptr::null_mut(), 0usize)
                                                                            },
                                                                          };
                                                                          (1i32, result2_0, result2_1, result2_2)
                                                                        },
                                                                        None => {
                                                                          (0i32, 0i32, ::core::ptr::null_mut(), 0usize)
                                                                        },
                                                                      };
                                                                      #[cfg(target_arch = "wasm32")]
                                                                      #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                      unsafe extern "C" {
                                                                        #[link_name = "[method]gpu-device.create-command-encoder"]
                                                                        fn wit_import4(_: i32, _: i32, _: i32, _: *mut u8, _: usize, ) -> i32;
                                                                      }

                                                                      #[cfg(not(target_arch = "wasm32"))]
                                                                      unsafe extern "C" fn wit_import4(_: i32, _: i32, _: i32, _: *mut u8, _: usize, ) -> i32 { unreachable!() }
                                                                      let ret = wit_import4((self).handle() as i32, result3_0, result3_1, result3_2, result3_3);
                                                                      GpuCommandEncoder::from_handle(ret as u32)
                                                                    }
                                                                  }
                                                                }
                                                                impl GpuDevice {
                                                                  #[allow(unused_unsafe, clippy::all)]
                                                                  #[allow(async_fn_in_trait)]
                                                                  pub fn create_render_bundle_encoder(&self,descriptor: &GpuRenderBundleEncoderDescriptor,) -> GpuRenderBundleEncoder{
                                                                    unsafe {
                                                                      let GpuRenderBundleEncoderDescriptor{ depth_read_only:depth_read_only0, stencil_read_only:stencil_read_only0, color_formats:color_formats0, depth_stencil_format:depth_stencil_format0, sample_count:sample_count0, label:label0, } = descriptor;
                                                                      let (result1_0,result1_1,) = match depth_read_only0 {
                                                                        Some(e) => (1i32, match e { true => 1, false => 0 }),
                                                                        None => {
                                                                          (0i32, 0i32)
                                                                        },
                                                                      };let (result2_0,result2_1,) = match stencil_read_only0 {
                                                                        Some(e) => (1i32, match e { true => 1, false => 0 }),
                                                                        None => {
                                                                          (0i32, 0i32)
                                                                        },
                                                                      };let vec3 = color_formats0;
                                                                      let len3 = vec3.len();
                                                                      let layout3 = _rt::alloc::Layout::from_size_align(vec3.len() * 2, 1).unwrap();
                                                                      let (result3, _cleanup3) = wit_bindgen::rt::Cleanup::new(layout3);for (i, e) in vec3.into_iter().enumerate() {
                                                                        let base = result3.add(i * 2);
                                                                        {
                                                                          match e {
                                                                            Some(e) => {
                                                                              *base.add(0).cast::<u8>() = (1i32) as u8;
                                                                              *base.add(1).cast::<u8>() = (e.clone() as i32) as u8;
                                                                            },
                                                                            None => {
                                                                              {
                                                                                *base.add(0).cast::<u8>() = (0i32) as u8;
                                                                              }
                                                                            },
                                                                          };}
                                                                        }
                                                                        let (result4_0,result4_1,) = match depth_stencil_format0 {
                                                                          Some(e) => (1i32, e.clone() as i32),
                                                                          None => {
                                                                            (0i32, 0i32)
                                                                          },
                                                                        };let (result5_0,result5_1,) = match sample_count0 {
                                                                          Some(e) => (1i32, _rt::as_i32(e)),
                                                                          None => {
                                                                            (0i32, 0i32)
                                                                          },
                                                                        };let (result7_0,result7_1,result7_2,) = match label0 {
                                                                          Some(e) => {
                                                                            let vec6 = e;
                                                                            let ptr6 = vec6.as_ptr().cast::<u8>();
                                                                            let len6 = vec6.len();

                                                                            (1i32, ptr6.cast_mut(), len6)
                                                                          },
                                                                          None => {
                                                                            (0i32, ::core::ptr::null_mut(), 0usize)
                                                                          },
                                                                        };
                                                                        #[cfg(target_arch = "wasm32")]
                                                                        #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                        unsafe extern "C" {
                                                                          #[link_name = "[method]gpu-device.create-render-bundle-encoder"]
                                                                          fn wit_import8(_: i32, _: i32, _: i32, _: i32, _: i32, _: *mut u8, _: usize, _: i32, _: i32, _: i32, _: i32, _: i32, _: *mut u8, _: usize, ) -> i32;
                                                                        }

                                                                        #[cfg(not(target_arch = "wasm32"))]
                                                                        unsafe extern "C" fn wit_import8(_: i32, _: i32, _: i32, _: i32, _: i32, _: *mut u8, _: usize, _: i32, _: i32, _: i32, _: i32, _: i32, _: *mut u8, _: usize, ) -> i32 { unreachable!() }
                                                                        let ret = wit_import8((self).handle() as i32, result1_0, result1_1, result2_0, result2_1, result3, len3, result4_0, result4_1, result5_0, result5_1, result7_0, result7_1, result7_2);
                                                                        GpuRenderBundleEncoder::from_handle(ret as u32)
                                                                      }
                                                                    }
                                                                  }
                                                                  impl GpuDevice {
                                                                    #[allow(unused_unsafe, clippy::all)]
                                                                    #[allow(async_fn_in_trait)]
                                                                    pub fn create_query_set(&self,descriptor: &GpuQuerySetDescriptor,) -> Result<GpuQuerySet,CreateQuerySetError>{
                                                                      unsafe {

                                                                        #[cfg_attr(target_pointer_width="64", repr(align(8)))]
                                                                        #[cfg_attr(target_pointer_width="32", repr(align(4)))]
                                                                        struct RetArea([::core::mem::MaybeUninit::<u8>; 4*::core::mem::size_of::<*const u8>()]);
                                                                        let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 4*::core::mem::size_of::<*const u8>()]);
                                                                        let GpuQuerySetDescriptor{ type_:type_0, count:count0, label:label0, } = descriptor;
                                                                        let (result2_0,result2_1,result2_2,) = match label0 {
                                                                          Some(e) => {
                                                                            let vec1 = e;
                                                                            let ptr1 = vec1.as_ptr().cast::<u8>();
                                                                            let len1 = vec1.len();

                                                                            (1i32, ptr1.cast_mut(), len1)
                                                                          },
                                                                          None => {
                                                                            (0i32, ::core::ptr::null_mut(), 0usize)
                                                                          },
                                                                        };let ptr3 = ret_area.0.as_mut_ptr().cast::<u8>();
                                                                        #[cfg(target_arch = "wasm32")]
                                                                        #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                        unsafe extern "C" {
                                                                          #[link_name = "[method]gpu-device.create-query-set"]
                                                                          fn wit_import4(_: i32, _: i32, _: i32, _: i32, _: *mut u8, _: usize, _: *mut u8, );
                                                                        }

                                                                        #[cfg(not(target_arch = "wasm32"))]
                                                                        unsafe extern "C" fn wit_import4(_: i32, _: i32, _: i32, _: i32, _: *mut u8, _: usize, _: *mut u8, ) { unreachable!() }
                                                                        wit_import4((self).handle() as i32, type_0.clone() as i32, _rt::as_i32(count0), result2_0, result2_1, result2_2, ptr3);
                                                                        let l5 = i32::from(*ptr3.add(0).cast::<u8>());
                                                                        let result12 = match l5 {
                                                                          0 => {
                                                                            let e = {
                                                                              let l6 = *ptr3.add(::core::mem::size_of::<*const u8>()).cast::<i32>();

                                                                              GpuQuerySet::from_handle(l6 as u32)
                                                                            };
                                                                            Ok(e)
                                                                          }
                                                                          1 => {
                                                                            let e = {
                                                                              let l7 = i32::from(*ptr3.add(::core::mem::size_of::<*const u8>()).cast::<u8>());
                                                                              let v8 = match l7 {
                                                                                n => {
                                                                                  debug_assert_eq!(n, 0, "invalid enum discriminant");
                                                                                  CreateQuerySetErrorKind::TypeError
                                                                                }
                                                                              };
                                                                              let l9 = *ptr3.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                                                                              let l10 = *ptr3.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>();
                                                                              let len11 = l10;
                                                                              let bytes11 = _rt::Vec::from_raw_parts(l9.cast(), len11, len11);

                                                                              CreateQuerySetError{
                                                                                kind: v8,
                                                                                message: _rt::string_lift(bytes11),
                                                                              }
                                                                            };
                                                                            Err(e)
                                                                          }
                                                                          _ => _rt::invalid_enum_discriminant(),
                                                                        };
                                                                        result12
                                                                      }
                                                                    }
                                                                  }
                                                                  impl GpuDevice {
                                                                    #[allow(unused_unsafe, clippy::all)]
                                                                    #[allow(async_fn_in_trait)]
                                                                    pub fn label(&self,) -> _rt::String{
                                                                      unsafe {

                                                                        #[cfg_attr(target_pointer_width="64", repr(align(8)))]
                                                                        #[cfg_attr(target_pointer_width="32", repr(align(4)))]
                                                                        struct RetArea([::core::mem::MaybeUninit::<u8>; 2*::core::mem::size_of::<*const u8>()]);
                                                                        let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2*::core::mem::size_of::<*const u8>()]);
                                                                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                                                                        #[cfg(target_arch = "wasm32")]
                                                                        #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                        unsafe extern "C" {
                                                                          #[link_name = "[method]gpu-device.label"]
                                                                          fn wit_import1(_: i32, _: *mut u8, );
                                                                        }

                                                                        #[cfg(not(target_arch = "wasm32"))]
                                                                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, ) { unreachable!() }
                                                                        wit_import1((self).handle() as i32, ptr0);
                                                                        let l2 = *ptr0.add(0).cast::<*mut u8>();
                                                                        let l3 = *ptr0.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
                                                                        let len4 = l3;
                                                                        let bytes4 = _rt::Vec::from_raw_parts(l2.cast(), len4, len4);
                                                                        let result5 = _rt::string_lift(bytes4);
                                                                        result5
                                                                      }
                                                                    }
                                                                  }
                                                                  impl GpuDevice {
                                                                    #[allow(unused_unsafe, clippy::all)]
                                                                    #[allow(async_fn_in_trait)]
                                                                    pub fn set_label(&self,label: &str,) -> (){
                                                                      unsafe {
                                                                        let vec0 = label;
                                                                        let ptr0 = vec0.as_ptr().cast::<u8>();
                                                                        let len0 = vec0.len();

                                                                        #[cfg(target_arch = "wasm32")]
                                                                        #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                        unsafe extern "C" {
                                                                          #[link_name = "[method]gpu-device.set-label"]
                                                                          fn wit_import1(_: i32, _: *mut u8, _: usize, );
                                                                        }

                                                                        #[cfg(not(target_arch = "wasm32"))]
                                                                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, _: usize, ) { unreachable!() }
                                                                        wit_import1((self).handle() as i32, ptr0.cast_mut(), len0);
                                                                      }
                                                                    }
                                                                  }
                                                                  impl GpuDevice {
                                                                    #[allow(unused_unsafe, clippy::all)]
                                                                    #[allow(async_fn_in_trait)]
                                                                    pub fn lost(&self,) -> GpuDeviceLostInfo{
                                                                      unsafe {

                                                                        #[cfg(target_arch = "wasm32")]
                                                                        #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                        unsafe extern "C" {
                                                                          #[link_name = "[method]gpu-device.lost"]
                                                                          fn wit_import0(_: i32, ) -> i32;
                                                                        }

                                                                        #[cfg(not(target_arch = "wasm32"))]
                                                                        unsafe extern "C" fn wit_import0(_: i32, ) -> i32 { unreachable!() }
                                                                        let ret = wit_import0((self).handle() as i32);
                                                                        GpuDeviceLostInfo::from_handle(ret as u32)
                                                                      }
                                                                    }
                                                                  }
                                                                  impl GpuDevice {
                                                                    #[allow(unused_unsafe, clippy::all)]
                                                                    #[allow(async_fn_in_trait)]
                                                                    pub fn push_error_scope(&self,filter: GpuErrorFilter,) -> (){
                                                                      unsafe {

                                                                        #[cfg(target_arch = "wasm32")]
                                                                        #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                        unsafe extern "C" {
                                                                          #[link_name = "[method]gpu-device.push-error-scope"]
                                                                          fn wit_import0(_: i32, _: i32, );
                                                                        }

                                                                        #[cfg(not(target_arch = "wasm32"))]
                                                                        unsafe extern "C" fn wit_import0(_: i32, _: i32, ) { unreachable!() }
                                                                        wit_import0((self).handle() as i32, filter.clone() as i32);
                                                                      }
                                                                    }
                                                                  }
                                                                  impl GpuDevice {
                                                                    #[allow(unused_unsafe, clippy::all)]
                                                                    #[allow(async_fn_in_trait)]
                                                                    pub fn pop_error_scope(&self,) -> Result<Option<GpuError>,PopErrorScopeError>{
                                                                      unsafe {

                                                                        #[cfg_attr(target_pointer_width="64", repr(align(8)))]
                                                                        #[cfg_attr(target_pointer_width="32", repr(align(4)))]
                                                                        struct RetArea([::core::mem::MaybeUninit::<u8>; 4*::core::mem::size_of::<*const u8>()]);
                                                                        let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 4*::core::mem::size_of::<*const u8>()]);
                                                                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                                                                        #[cfg(target_arch = "wasm32")]
                                                                        #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                        unsafe extern "C" {
                                                                          #[link_name = "[method]gpu-device.pop-error-scope"]
                                                                          fn wit_import1(_: i32, _: *mut u8, );
                                                                        }

                                                                        #[cfg(not(target_arch = "wasm32"))]
                                                                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, ) { unreachable!() }
                                                                        wit_import1((self).handle() as i32, ptr0);
                                                                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                                                                        let result10 = match l2 {
                                                                          0 => {
                                                                            let e = {
                                                                              let l3 = i32::from(*ptr0.add(::core::mem::size_of::<*const u8>()).cast::<u8>());

                                                                              match l3 {
                                                                                0 => None,
                                                                                1 => {
                                                                                  let e = {
                                                                                    let l4 = *ptr0.add(4+1*::core::mem::size_of::<*const u8>()).cast::<i32>();

                                                                                    GpuError::from_handle(l4 as u32)
                                                                                  };
                                                                                  Some(e)
                                                                                }
                                                                                _ => _rt::invalid_enum_discriminant(),
                                                                              }
                                                                            };
                                                                            Ok(e)
                                                                          }
                                                                          1 => {
                                                                            let e = {
                                                                              let l5 = i32::from(*ptr0.add(::core::mem::size_of::<*const u8>()).cast::<u8>());
                                                                              let v6 = match l5 {
                                                                                n => {
                                                                                  debug_assert_eq!(n, 0, "invalid enum discriminant");
                                                                                  PopErrorScopeErrorKind::OperationError
                                                                                }
                                                                              };
                                                                              let l7 = *ptr0.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                                                                              let l8 = *ptr0.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>();
                                                                              let len9 = l8;
                                                                              let bytes9 = _rt::Vec::from_raw_parts(l7.cast(), len9, len9);

                                                                              PopErrorScopeError{
                                                                                kind: v6,
                                                                                message: _rt::string_lift(bytes9),
                                                                              }
                                                                            };
                                                                            Err(e)
                                                                          }
                                                                          _ => _rt::invalid_enum_discriminant(),
                                                                        };
                                                                        result10
                                                                      }
                                                                    }
                                                                  }
                                                                  impl GpuDevice {
                                                                    #[allow(unused_unsafe, clippy::all)]
                                                                    #[allow(async_fn_in_trait)]
                                                                    pub fn onuncapturederror_subscribe(&self,) -> Pollable{
                                                                      unsafe {

                                                                        #[cfg(target_arch = "wasm32")]
                                                                        #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                        unsafe extern "C" {
                                                                          #[link_name = "[method]gpu-device.onuncapturederror-subscribe"]
                                                                          fn wit_import0(_: i32, ) -> i32;
                                                                        }

                                                                        #[cfg(not(target_arch = "wasm32"))]
                                                                        unsafe extern "C" fn wit_import0(_: i32, ) -> i32 { unreachable!() }
                                                                        let ret = wit_import0((self).handle() as i32);
                                                                        super::super::super::wasi::io::poll::Pollable::from_handle(ret as u32)
                                                                      }
                                                                    }
                                                                  }
                                                                  impl GpuDevice {
                                                                    #[allow(unused_unsafe, clippy::all)]
                                                                    #[allow(async_fn_in_trait)]
                                                                    pub fn connect_graphics_context(&self,context: &Context,) -> (){
                                                                      unsafe {

                                                                        #[cfg(target_arch = "wasm32")]
                                                                        #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                        unsafe extern "C" {
                                                                          #[link_name = "[method]gpu-device.connect-graphics-context"]
                                                                          fn wit_import0(_: i32, _: i32, );
                                                                        }

                                                                        #[cfg(not(target_arch = "wasm32"))]
                                                                        unsafe extern "C" fn wit_import0(_: i32, _: i32, ) { unreachable!() }
                                                                        wit_import0((self).handle() as i32, (context).handle() as i32);
                                                                      }
                                                                    }
                                                                  }
                                                                  impl GpuBuffer {
                                                                    #[allow(unused_unsafe, clippy::all)]
                                                                    #[allow(async_fn_in_trait)]
                                                                    pub fn size(&self,) -> GpuSize64Out{
                                                                      unsafe {

                                                                        #[cfg(target_arch = "wasm32")]
                                                                        #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                        unsafe extern "C" {
                                                                          #[link_name = "[method]gpu-buffer.size"]
                                                                          fn wit_import0(_: i32, ) -> i64;
                                                                        }

                                                                        #[cfg(not(target_arch = "wasm32"))]
                                                                        unsafe extern "C" fn wit_import0(_: i32, ) -> i64 { unreachable!() }
                                                                        let ret = wit_import0((self).handle() as i32);
                                                                        ret as u64
                                                                      }
                                                                    }
                                                                  }
                                                                  impl GpuBuffer {
                                                                    #[allow(unused_unsafe, clippy::all)]
                                                                    #[allow(async_fn_in_trait)]
                                                                    pub fn usage(&self,) -> GpuFlagsConstant{
                                                                      unsafe {

                                                                        #[cfg(target_arch = "wasm32")]
                                                                        #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                        unsafe extern "C" {
                                                                          #[link_name = "[method]gpu-buffer.usage"]
                                                                          fn wit_import0(_: i32, ) -> i32;
                                                                        }

                                                                        #[cfg(not(target_arch = "wasm32"))]
                                                                        unsafe extern "C" fn wit_import0(_: i32, ) -> i32 { unreachable!() }
                                                                        let ret = wit_import0((self).handle() as i32);
                                                                        ret as u32
                                                                      }
                                                                    }
                                                                  }
                                                                  impl GpuBuffer {
                                                                    #[allow(unused_unsafe, clippy::all)]
                                                                    #[allow(async_fn_in_trait)]
                                                                    pub fn map_state(&self,) -> GpuBufferMapState{
                                                                      unsafe {

                                                                        #[cfg(target_arch = "wasm32")]
                                                                        #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                        unsafe extern "C" {
                                                                          #[link_name = "[method]gpu-buffer.map-state"]
                                                                          fn wit_import0(_: i32, ) -> i32;
                                                                        }

                                                                        #[cfg(not(target_arch = "wasm32"))]
                                                                        unsafe extern "C" fn wit_import0(_: i32, ) -> i32 { unreachable!() }
                                                                        let ret = wit_import0((self).handle() as i32);
                                                                        GpuBufferMapState::_lift(ret as u8)
                                                                      }
                                                                    }
                                                                  }
                                                                  impl GpuBuffer {
                                                                    #[allow(unused_unsafe, clippy::all)]
                                                                    #[allow(async_fn_in_trait)]
                                                                    pub fn map_async(&self,mode: GpuMapModeFlags,offset: Option<GpuSize64>,size: Option<GpuSize64>,) -> Result<(),MapAsyncError>{
                                                                      unsafe {

                                                                        #[cfg_attr(target_pointer_width="64", repr(align(8)))]
                                                                        #[cfg_attr(target_pointer_width="32", repr(align(4)))]
                                                                        struct RetArea([::core::mem::MaybeUninit::<u8>; 4*::core::mem::size_of::<*const u8>()]);
                                                                        let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 4*::core::mem::size_of::<*const u8>()]);
                                                                        let (result0_0,result0_1,) = match offset {
                                                                          Some(e) => (1i32, _rt::as_i64(e)),
                                                                          None => {
                                                                            (0i32, 0i64)
                                                                          },
                                                                        };let (result1_0,result1_1,) = match size {
                                                                          Some(e) => (1i32, _rt::as_i64(e)),
                                                                          None => {
                                                                            (0i32, 0i64)
                                                                          },
                                                                        };let ptr2 = ret_area.0.as_mut_ptr().cast::<u8>();
                                                                        #[cfg(target_arch = "wasm32")]
                                                                        #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                        unsafe extern "C" {
                                                                          #[link_name = "[method]gpu-buffer.map-async"]
                                                                          fn wit_import3(_: i32, _: i32, _: i32, _: i64, _: i32, _: i64, _: *mut u8, );
                                                                        }

                                                                        #[cfg(not(target_arch = "wasm32"))]
                                                                        unsafe extern "C" fn wit_import3(_: i32, _: i32, _: i32, _: i64, _: i32, _: i64, _: *mut u8, ) { unreachable!() }
                                                                        wit_import3((self).handle() as i32, _rt::as_i32(mode), result0_0, result0_1, result1_0, result1_1, ptr2);
                                                                        let l4 = i32::from(*ptr2.add(0).cast::<u8>());
                                                                        let result10 = match l4 {
                                                                          0 => {
                                                                            let e = ();
                                                                            Ok(e)
                                                                          }
                                                                          1 => {
                                                                            let e = {
                                                                              let l5 = i32::from(*ptr2.add(::core::mem::size_of::<*const u8>()).cast::<u8>());
                                                                              let v6 = match l5 {
                                                                                0 => {
                                                                                  MapAsyncErrorKind::OperationError
                                                                                }
                                                                                1 => {
                                                                                  MapAsyncErrorKind::RangeError
                                                                                }
                                                                                n => {
                                                                                  debug_assert_eq!(n, 2, "invalid enum discriminant");
                                                                                  MapAsyncErrorKind::AbortError
                                                                                }
                                                                              };
                                                                              let l7 = *ptr2.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                                                                              let l8 = *ptr2.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>();
                                                                              let len9 = l8;
                                                                              let bytes9 = _rt::Vec::from_raw_parts(l7.cast(), len9, len9);

                                                                              MapAsyncError{
                                                                                kind: v6,
                                                                                message: _rt::string_lift(bytes9),
                                                                              }
                                                                            };
                                                                            Err(e)
                                                                          }
                                                                          _ => _rt::invalid_enum_discriminant(),
                                                                        };
                                                                        result10
                                                                      }
                                                                    }
                                                                  }
                                                                  impl GpuBuffer {
                                                                    #[allow(unused_unsafe, clippy::all)]
                                                                    #[allow(async_fn_in_trait)]
                                                                    pub fn get_mapped_range_get_with_copy(&self,offset: Option<GpuSize64>,size: Option<GpuSize64>,) -> Result<_rt::Vec::<u8>,GetMappedRangeError>{
                                                                      unsafe {

                                                                        #[cfg_attr(target_pointer_width="64", repr(align(8)))]
                                                                        #[cfg_attr(target_pointer_width="32", repr(align(4)))]
                                                                        struct RetArea([::core::mem::MaybeUninit::<u8>; 4*::core::mem::size_of::<*const u8>()]);
                                                                        let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 4*::core::mem::size_of::<*const u8>()]);
                                                                        let (result0_0,result0_1,) = match offset {
                                                                          Some(e) => (1i32, _rt::as_i64(e)),
                                                                          None => {
                                                                            (0i32, 0i64)
                                                                          },
                                                                        };let (result1_0,result1_1,) = match size {
                                                                          Some(e) => (1i32, _rt::as_i64(e)),
                                                                          None => {
                                                                            (0i32, 0i64)
                                                                          },
                                                                        };let ptr2 = ret_area.0.as_mut_ptr().cast::<u8>();
                                                                        #[cfg(target_arch = "wasm32")]
                                                                        #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                        unsafe extern "C" {
                                                                          #[link_name = "[method]gpu-buffer.get-mapped-range-get-with-copy"]
                                                                          fn wit_import3(_: i32, _: i32, _: i64, _: i32, _: i64, _: *mut u8, );
                                                                        }

                                                                        #[cfg(not(target_arch = "wasm32"))]
                                                                        unsafe extern "C" fn wit_import3(_: i32, _: i32, _: i64, _: i32, _: i64, _: *mut u8, ) { unreachable!() }
                                                                        wit_import3((self).handle() as i32, result0_0, result0_1, result1_0, result1_1, ptr2);
                                                                        let l4 = i32::from(*ptr2.add(0).cast::<u8>());
                                                                        let result13 = match l4 {
                                                                          0 => {
                                                                            let e = {
                                                                              let l5 = *ptr2.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                                                                              let l6 = *ptr2.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>();
                                                                              let len7 = l6;

                                                                              <_ as From<_rt::Vec<_>>>::from(_rt::Vec::from_raw_parts(l5.cast(), len7, len7))
                                                                            };
                                                                            Ok(e)
                                                                          }
                                                                          1 => {
                                                                            let e = {
                                                                              let l8 = i32::from(*ptr2.add(::core::mem::size_of::<*const u8>()).cast::<u8>());
                                                                              let v9 = match l8 {
                                                                                0 => {
                                                                                  GetMappedRangeErrorKind::OperationError
                                                                                }
                                                                                1 => {
                                                                                  GetMappedRangeErrorKind::RangeError
                                                                                }
                                                                                n => {
                                                                                  debug_assert_eq!(n, 2, "invalid enum discriminant");
                                                                                  GetMappedRangeErrorKind::TypeError
                                                                                }
                                                                              };
                                                                              let l10 = *ptr2.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                                                                              let l11 = *ptr2.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>();
                                                                              let len12 = l11;
                                                                              let bytes12 = _rt::Vec::from_raw_parts(l10.cast(), len12, len12);

                                                                              GetMappedRangeError{
                                                                                kind: v9,
                                                                                message: _rt::string_lift(bytes12),
                                                                              }
                                                                            };
                                                                            Err(e)
                                                                          }
                                                                          _ => _rt::invalid_enum_discriminant(),
                                                                        };
                                                                        result13
                                                                      }
                                                                    }
                                                                  }
                                                                  impl GpuBuffer {
                                                                    #[allow(unused_unsafe, clippy::all)]
                                                                    #[allow(async_fn_in_trait)]
                                                                    pub fn unmap(&self,) -> Result<(),UnmapError>{
                                                                      unsafe {

                                                                        #[cfg_attr(target_pointer_width="64", repr(align(8)))]
                                                                        #[cfg_attr(target_pointer_width="32", repr(align(4)))]
                                                                        struct RetArea([::core::mem::MaybeUninit::<u8>; 4*::core::mem::size_of::<*const u8>()]);
                                                                        let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 4*::core::mem::size_of::<*const u8>()]);
                                                                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                                                                        #[cfg(target_arch = "wasm32")]
                                                                        #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                        unsafe extern "C" {
                                                                          #[link_name = "[method]gpu-buffer.unmap"]
                                                                          fn wit_import1(_: i32, _: *mut u8, );
                                                                        }

                                                                        #[cfg(not(target_arch = "wasm32"))]
                                                                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, ) { unreachable!() }
                                                                        wit_import1((self).handle() as i32, ptr0);
                                                                        let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                                                                        let result8 = match l2 {
                                                                          0 => {
                                                                            let e = ();
                                                                            Ok(e)
                                                                          }
                                                                          1 => {
                                                                            let e = {
                                                                              let l3 = i32::from(*ptr0.add(::core::mem::size_of::<*const u8>()).cast::<u8>());
                                                                              let v4 = match l3 {
                                                                                n => {
                                                                                  debug_assert_eq!(n, 0, "invalid enum discriminant");
                                                                                  UnmapErrorKind::AbortError
                                                                                }
                                                                              };
                                                                              let l5 = *ptr0.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                                                                              let l6 = *ptr0.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>();
                                                                              let len7 = l6;
                                                                              let bytes7 = _rt::Vec::from_raw_parts(l5.cast(), len7, len7);

                                                                              UnmapError{
                                                                                kind: v4,
                                                                                message: _rt::string_lift(bytes7),
                                                                              }
                                                                            };
                                                                            Err(e)
                                                                          }
                                                                          _ => _rt::invalid_enum_discriminant(),
                                                                        };
                                                                        result8
                                                                      }
                                                                    }
                                                                  }
                                                                  impl GpuBuffer {
                                                                    #[allow(unused_unsafe, clippy::all)]
                                                                    #[allow(async_fn_in_trait)]
                                                                    pub fn destroy(&self,) -> (){
                                                                      unsafe {

                                                                        #[cfg(target_arch = "wasm32")]
                                                                        #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                        unsafe extern "C" {
                                                                          #[link_name = "[method]gpu-buffer.destroy"]
                                                                          fn wit_import0(_: i32, );
                                                                        }

                                                                        #[cfg(not(target_arch = "wasm32"))]
                                                                        unsafe extern "C" fn wit_import0(_: i32, ) { unreachable!() }
                                                                        wit_import0((self).handle() as i32);
                                                                      }
                                                                    }
                                                                  }
                                                                  impl GpuBuffer {
                                                                    #[allow(unused_unsafe, clippy::all)]
                                                                    #[allow(async_fn_in_trait)]
                                                                    pub fn label(&self,) -> _rt::String{
                                                                      unsafe {

                                                                        #[cfg_attr(target_pointer_width="64", repr(align(8)))]
                                                                        #[cfg_attr(target_pointer_width="32", repr(align(4)))]
                                                                        struct RetArea([::core::mem::MaybeUninit::<u8>; 2*::core::mem::size_of::<*const u8>()]);
                                                                        let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2*::core::mem::size_of::<*const u8>()]);
                                                                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                                                                        #[cfg(target_arch = "wasm32")]
                                                                        #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                        unsafe extern "C" {
                                                                          #[link_name = "[method]gpu-buffer.label"]
                                                                          fn wit_import1(_: i32, _: *mut u8, );
                                                                        }

                                                                        #[cfg(not(target_arch = "wasm32"))]
                                                                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, ) { unreachable!() }
                                                                        wit_import1((self).handle() as i32, ptr0);
                                                                        let l2 = *ptr0.add(0).cast::<*mut u8>();
                                                                        let l3 = *ptr0.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
                                                                        let len4 = l3;
                                                                        let bytes4 = _rt::Vec::from_raw_parts(l2.cast(), len4, len4);
                                                                        let result5 = _rt::string_lift(bytes4);
                                                                        result5
                                                                      }
                                                                    }
                                                                  }
                                                                  impl GpuBuffer {
                                                                    #[allow(unused_unsafe, clippy::all)]
                                                                    #[allow(async_fn_in_trait)]
                                                                    pub fn set_label(&self,label: &str,) -> (){
                                                                      unsafe {
                                                                        let vec0 = label;
                                                                        let ptr0 = vec0.as_ptr().cast::<u8>();
                                                                        let len0 = vec0.len();

                                                                        #[cfg(target_arch = "wasm32")]
                                                                        #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                        unsafe extern "C" {
                                                                          #[link_name = "[method]gpu-buffer.set-label"]
                                                                          fn wit_import1(_: i32, _: *mut u8, _: usize, );
                                                                        }

                                                                        #[cfg(not(target_arch = "wasm32"))]
                                                                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, _: usize, ) { unreachable!() }
                                                                        wit_import1((self).handle() as i32, ptr0.cast_mut(), len0);
                                                                      }
                                                                    }
                                                                  }
                                                                  impl GpuBuffer {
                                                                    #[allow(unused_unsafe, clippy::all)]
                                                                    #[allow(async_fn_in_trait)]
                                                                    pub fn get_mapped_range_set_with_copy(&self,data: &[u8],offset: Option<GpuSize64>,size: Option<GpuSize64>,) -> Result<(),GetMappedRangeError>{
                                                                      unsafe {

                                                                        #[cfg_attr(target_pointer_width="64", repr(align(8)))]
                                                                        #[cfg_attr(target_pointer_width="32", repr(align(4)))]
                                                                        struct RetArea([::core::mem::MaybeUninit::<u8>; 4*::core::mem::size_of::<*const u8>()]);
                                                                        let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 4*::core::mem::size_of::<*const u8>()]);
                                                                        let vec0 = data;
                                                                        let ptr0 = vec0.as_ptr().cast::<u8>();
                                                                        let len0 = vec0.len();
                                                                        let (result1_0,result1_1,) = match offset {
                                                                          Some(e) => (1i32, _rt::as_i64(e)),
                                                                          None => {
                                                                            (0i32, 0i64)
                                                                          },
                                                                        };let (result2_0,result2_1,) = match size {
                                                                          Some(e) => (1i32, _rt::as_i64(e)),
                                                                          None => {
                                                                            (0i32, 0i64)
                                                                          },
                                                                        };let ptr3 = ret_area.0.as_mut_ptr().cast::<u8>();
                                                                        #[cfg(target_arch = "wasm32")]
                                                                        #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                        unsafe extern "C" {
                                                                          #[link_name = "[method]gpu-buffer.get-mapped-range-set-with-copy"]
                                                                          fn wit_import4(_: i32, _: *mut u8, _: usize, _: i32, _: i64, _: i32, _: i64, _: *mut u8, );
                                                                        }

                                                                        #[cfg(not(target_arch = "wasm32"))]
                                                                        unsafe extern "C" fn wit_import4(_: i32, _: *mut u8, _: usize, _: i32, _: i64, _: i32, _: i64, _: *mut u8, ) { unreachable!() }
                                                                        wit_import4((self).handle() as i32, ptr0.cast_mut(), len0, result1_0, result1_1, result2_0, result2_1, ptr3);
                                                                        let l5 = i32::from(*ptr3.add(0).cast::<u8>());
                                                                        let result11 = match l5 {
                                                                          0 => {
                                                                            let e = ();
                                                                            Ok(e)
                                                                          }
                                                                          1 => {
                                                                            let e = {
                                                                              let l6 = i32::from(*ptr3.add(::core::mem::size_of::<*const u8>()).cast::<u8>());
                                                                              let v7 = match l6 {
                                                                                0 => {
                                                                                  GetMappedRangeErrorKind::OperationError
                                                                                }
                                                                                1 => {
                                                                                  GetMappedRangeErrorKind::RangeError
                                                                                }
                                                                                n => {
                                                                                  debug_assert_eq!(n, 2, "invalid enum discriminant");
                                                                                  GetMappedRangeErrorKind::TypeError
                                                                                }
                                                                              };
                                                                              let l8 = *ptr3.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                                                                              let l9 = *ptr3.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>();
                                                                              let len10 = l9;
                                                                              let bytes10 = _rt::Vec::from_raw_parts(l8.cast(), len10, len10);

                                                                              GetMappedRangeError{
                                                                                kind: v7,
                                                                                message: _rt::string_lift(bytes10),
                                                                              }
                                                                            };
                                                                            Err(e)
                                                                          }
                                                                          _ => _rt::invalid_enum_discriminant(),
                                                                        };
                                                                        result11
                                                                      }
                                                                    }
                                                                  }
                                                                  impl GpuBufferUsage {
                                                                    #[allow(unused_unsafe, clippy::all)]
                                                                    #[allow(async_fn_in_trait)]
                                                                    pub fn map_read() -> GpuFlagsConstant{
                                                                      unsafe {

                                                                        #[cfg(target_arch = "wasm32")]
                                                                        #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                        unsafe extern "C" {
                                                                          #[link_name = "[static]gpu-buffer-usage.MAP-READ"]
                                                                          fn wit_import0() -> i32;
                                                                        }

                                                                        #[cfg(not(target_arch = "wasm32"))]
                                                                        unsafe extern "C" fn wit_import0() -> i32 { unreachable!() }
                                                                        let ret = wit_import0();
                                                                        ret as u32
                                                                      }
                                                                    }
                                                                  }
                                                                  impl GpuBufferUsage {
                                                                    #[allow(unused_unsafe, clippy::all)]
                                                                    #[allow(async_fn_in_trait)]
                                                                    pub fn map_write() -> GpuFlagsConstant{
                                                                      unsafe {

                                                                        #[cfg(target_arch = "wasm32")]
                                                                        #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                        unsafe extern "C" {
                                                                          #[link_name = "[static]gpu-buffer-usage.MAP-WRITE"]
                                                                          fn wit_import0() -> i32;
                                                                        }

                                                                        #[cfg(not(target_arch = "wasm32"))]
                                                                        unsafe extern "C" fn wit_import0() -> i32 { unreachable!() }
                                                                        let ret = wit_import0();
                                                                        ret as u32
                                                                      }
                                                                    }
                                                                  }
                                                                  impl GpuBufferUsage {
                                                                    #[allow(unused_unsafe, clippy::all)]
                                                                    #[allow(async_fn_in_trait)]
                                                                    pub fn copy_src() -> GpuFlagsConstant{
                                                                      unsafe {

                                                                        #[cfg(target_arch = "wasm32")]
                                                                        #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                        unsafe extern "C" {
                                                                          #[link_name = "[static]gpu-buffer-usage.COPY-SRC"]
                                                                          fn wit_import0() -> i32;
                                                                        }

                                                                        #[cfg(not(target_arch = "wasm32"))]
                                                                        unsafe extern "C" fn wit_import0() -> i32 { unreachable!() }
                                                                        let ret = wit_import0();
                                                                        ret as u32
                                                                      }
                                                                    }
                                                                  }
                                                                  impl GpuBufferUsage {
                                                                    #[allow(unused_unsafe, clippy::all)]
                                                                    #[allow(async_fn_in_trait)]
                                                                    pub fn copy_dst() -> GpuFlagsConstant{
                                                                      unsafe {

                                                                        #[cfg(target_arch = "wasm32")]
                                                                        #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                        unsafe extern "C" {
                                                                          #[link_name = "[static]gpu-buffer-usage.COPY-DST"]
                                                                          fn wit_import0() -> i32;
                                                                        }

                                                                        #[cfg(not(target_arch = "wasm32"))]
                                                                        unsafe extern "C" fn wit_import0() -> i32 { unreachable!() }
                                                                        let ret = wit_import0();
                                                                        ret as u32
                                                                      }
                                                                    }
                                                                  }
                                                                  impl GpuBufferUsage {
                                                                    #[allow(unused_unsafe, clippy::all)]
                                                                    #[allow(async_fn_in_trait)]
                                                                    pub fn index() -> GpuFlagsConstant{
                                                                      unsafe {

                                                                        #[cfg(target_arch = "wasm32")]
                                                                        #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                        unsafe extern "C" {
                                                                          #[link_name = "[static]gpu-buffer-usage.INDEX"]
                                                                          fn wit_import0() -> i32;
                                                                        }

                                                                        #[cfg(not(target_arch = "wasm32"))]
                                                                        unsafe extern "C" fn wit_import0() -> i32 { unreachable!() }
                                                                        let ret = wit_import0();
                                                                        ret as u32
                                                                      }
                                                                    }
                                                                  }
                                                                  impl GpuBufferUsage {
                                                                    #[allow(unused_unsafe, clippy::all)]
                                                                    #[allow(async_fn_in_trait)]
                                                                    pub fn vertex() -> GpuFlagsConstant{
                                                                      unsafe {

                                                                        #[cfg(target_arch = "wasm32")]
                                                                        #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                        unsafe extern "C" {
                                                                          #[link_name = "[static]gpu-buffer-usage.VERTEX"]
                                                                          fn wit_import0() -> i32;
                                                                        }

                                                                        #[cfg(not(target_arch = "wasm32"))]
                                                                        unsafe extern "C" fn wit_import0() -> i32 { unreachable!() }
                                                                        let ret = wit_import0();
                                                                        ret as u32
                                                                      }
                                                                    }
                                                                  }
                                                                  impl GpuBufferUsage {
                                                                    #[allow(unused_unsafe, clippy::all)]
                                                                    #[allow(async_fn_in_trait)]
                                                                    pub fn uniform() -> GpuFlagsConstant{
                                                                      unsafe {

                                                                        #[cfg(target_arch = "wasm32")]
                                                                        #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                        unsafe extern "C" {
                                                                          #[link_name = "[static]gpu-buffer-usage.UNIFORM"]
                                                                          fn wit_import0() -> i32;
                                                                        }

                                                                        #[cfg(not(target_arch = "wasm32"))]
                                                                        unsafe extern "C" fn wit_import0() -> i32 { unreachable!() }
                                                                        let ret = wit_import0();
                                                                        ret as u32
                                                                      }
                                                                    }
                                                                  }
                                                                  impl GpuBufferUsage {
                                                                    #[allow(unused_unsafe, clippy::all)]
                                                                    #[allow(async_fn_in_trait)]
                                                                    pub fn storage() -> GpuFlagsConstant{
                                                                      unsafe {

                                                                        #[cfg(target_arch = "wasm32")]
                                                                        #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                        unsafe extern "C" {
                                                                          #[link_name = "[static]gpu-buffer-usage.STORAGE"]
                                                                          fn wit_import0() -> i32;
                                                                        }

                                                                        #[cfg(not(target_arch = "wasm32"))]
                                                                        unsafe extern "C" fn wit_import0() -> i32 { unreachable!() }
                                                                        let ret = wit_import0();
                                                                        ret as u32
                                                                      }
                                                                    }
                                                                  }
                                                                  impl GpuBufferUsage {
                                                                    #[allow(unused_unsafe, clippy::all)]
                                                                    #[allow(async_fn_in_trait)]
                                                                    pub fn indirect() -> GpuFlagsConstant{
                                                                      unsafe {

                                                                        #[cfg(target_arch = "wasm32")]
                                                                        #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                        unsafe extern "C" {
                                                                          #[link_name = "[static]gpu-buffer-usage.INDIRECT"]
                                                                          fn wit_import0() -> i32;
                                                                        }

                                                                        #[cfg(not(target_arch = "wasm32"))]
                                                                        unsafe extern "C" fn wit_import0() -> i32 { unreachable!() }
                                                                        let ret = wit_import0();
                                                                        ret as u32
                                                                      }
                                                                    }
                                                                  }
                                                                  impl GpuBufferUsage {
                                                                    #[allow(unused_unsafe, clippy::all)]
                                                                    #[allow(async_fn_in_trait)]
                                                                    pub fn query_resolve() -> GpuFlagsConstant{
                                                                      unsafe {

                                                                        #[cfg(target_arch = "wasm32")]
                                                                        #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                        unsafe extern "C" {
                                                                          #[link_name = "[static]gpu-buffer-usage.QUERY-RESOLVE"]
                                                                          fn wit_import0() -> i32;
                                                                        }

                                                                        #[cfg(not(target_arch = "wasm32"))]
                                                                        unsafe extern "C" fn wit_import0() -> i32 { unreachable!() }
                                                                        let ret = wit_import0();
                                                                        ret as u32
                                                                      }
                                                                    }
                                                                  }
                                                                  impl GpuMapMode {
                                                                    #[allow(unused_unsafe, clippy::all)]
                                                                    #[allow(async_fn_in_trait)]
                                                                    pub fn read() -> GpuFlagsConstant{
                                                                      unsafe {

                                                                        #[cfg(target_arch = "wasm32")]
                                                                        #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                        unsafe extern "C" {
                                                                          #[link_name = "[static]gpu-map-mode.READ"]
                                                                          fn wit_import0() -> i32;
                                                                        }

                                                                        #[cfg(not(target_arch = "wasm32"))]
                                                                        unsafe extern "C" fn wit_import0() -> i32 { unreachable!() }
                                                                        let ret = wit_import0();
                                                                        ret as u32
                                                                      }
                                                                    }
                                                                  }
                                                                  impl GpuMapMode {
                                                                    #[allow(unused_unsafe, clippy::all)]
                                                                    #[allow(async_fn_in_trait)]
                                                                    pub fn write() -> GpuFlagsConstant{
                                                                      unsafe {

                                                                        #[cfg(target_arch = "wasm32")]
                                                                        #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                        unsafe extern "C" {
                                                                          #[link_name = "[static]gpu-map-mode.WRITE"]
                                                                          fn wit_import0() -> i32;
                                                                        }

                                                                        #[cfg(not(target_arch = "wasm32"))]
                                                                        unsafe extern "C" fn wit_import0() -> i32 { unreachable!() }
                                                                        let ret = wit_import0();
                                                                        ret as u32
                                                                      }
                                                                    }
                                                                  }
                                                                  impl GpuTexture {
                                                                    #[allow(unused_unsafe, clippy::all)]
                                                                    #[allow(async_fn_in_trait)]
                                                                    pub fn create_view(&self,descriptor: Option<&GpuTextureViewDescriptor>,) -> GpuTextureView{
                                                                      unsafe {

                                                                        #[cfg_attr(target_pointer_width="64", repr(align(8)))]
                                                                        #[cfg_attr(target_pointer_width="32", repr(align(4)))]
                                                                        struct RetArea([::core::mem::MaybeUninit::<u8>; 48+5*::core::mem::size_of::<*const u8>()]);
                                                                        let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 48+5*::core::mem::size_of::<*const u8>()]);
                                                                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();*ptr0.add(0).cast::<i32>() = (self).handle() as i32;
                                                                        match descriptor {
                                                                          Some(e) => {
                                                                            *ptr0.add(::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                                                            let GpuTextureViewDescriptor{ format:format1, dimension:dimension1, usage:usage1, aspect:aspect1, base_mip_level:base_mip_level1, mip_level_count:mip_level_count1, base_array_layer:base_array_layer1, array_layer_count:array_layer_count1, label:label1, } = e;
                                                                            match format1 {
                                                                              Some(e) => {
                                                                                *ptr0.add(2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                                                                *ptr0.add(1+2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (e.clone() as i32) as u8;
                                                                              },
                                                                              None => {
                                                                                {
                                                                                  *ptr0.add(2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                                                                }
                                                                              },
                                                                            };match dimension1 {
                                                                              Some(e) => {
                                                                                *ptr0.add(2+2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                                                                *ptr0.add(3+2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (e.clone() as i32) as u8;
                                                                              },
                                                                              None => {
                                                                                {
                                                                                  *ptr0.add(2+2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                                                                }
                                                                              },
                                                                            };match usage1 {
                                                                              Some(e) => {
                                                                                *ptr0.add(4+2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                                                                *ptr0.add(8+2*::core::mem::size_of::<*const u8>()).cast::<i32>() = _rt::as_i32(e);
                                                                              },
                                                                              None => {
                                                                                {
                                                                                  *ptr0.add(4+2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                                                                }
                                                                              },
                                                                            };match aspect1 {
                                                                              Some(e) => {
                                                                                *ptr0.add(12+2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                                                                *ptr0.add(13+2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (e.clone() as i32) as u8;
                                                                              },
                                                                              None => {
                                                                                {
                                                                                  *ptr0.add(12+2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                                                                }
                                                                              },
                                                                            };match base_mip_level1 {
                                                                              Some(e) => {
                                                                                *ptr0.add(16+2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                                                                *ptr0.add(20+2*::core::mem::size_of::<*const u8>()).cast::<i32>() = _rt::as_i32(e);
                                                                              },
                                                                              None => {
                                                                                {
                                                                                  *ptr0.add(16+2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                                                                }
                                                                              },
                                                                            };match mip_level_count1 {
                                                                              Some(e) => {
                                                                                *ptr0.add(24+2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                                                                *ptr0.add(28+2*::core::mem::size_of::<*const u8>()).cast::<i32>() = _rt::as_i32(e);
                                                                              },
                                                                              None => {
                                                                                {
                                                                                  *ptr0.add(24+2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                                                                }
                                                                              },
                                                                            };match base_array_layer1 {
                                                                              Some(e) => {
                                                                                *ptr0.add(32+2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                                                                *ptr0.add(36+2*::core::mem::size_of::<*const u8>()).cast::<i32>() = _rt::as_i32(e);
                                                                              },
                                                                              None => {
                                                                                {
                                                                                  *ptr0.add(32+2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                                                                }
                                                                              },
                                                                            };match array_layer_count1 {
                                                                              Some(e) => {
                                                                                *ptr0.add(40+2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                                                                *ptr0.add(44+2*::core::mem::size_of::<*const u8>()).cast::<i32>() = _rt::as_i32(e);
                                                                              },
                                                                              None => {
                                                                                {
                                                                                  *ptr0.add(40+2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                                                                }
                                                                              },
                                                                            };match label1 {
                                                                              Some(e) => {
                                                                                *ptr0.add(48+2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                                                                let vec2 = e;
                                                                                let ptr2 = vec2.as_ptr().cast::<u8>();
                                                                                let len2 = vec2.len();
                                                                                *ptr0.add(48+4*::core::mem::size_of::<*const u8>()).cast::<usize>() = len2;
                                                                                *ptr0.add(48+3*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr2.cast_mut();
                                                                              },
                                                                              None => {
                                                                                {
                                                                                  *ptr0.add(48+2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                                                                }
                                                                              },
                                                                            };},
                                                                            None => {
                                                                              {
                                                                                *ptr0.add(::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                                                              }
                                                                            },
                                                                          };
                                                                          #[cfg(target_arch = "wasm32")]
                                                                          #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                          unsafe extern "C" {
                                                                            #[link_name = "[method]gpu-texture.create-view"]
                                                                            fn wit_import3(_: *mut u8, ) -> i32;
                                                                          }

                                                                          #[cfg(not(target_arch = "wasm32"))]
                                                                          unsafe extern "C" fn wit_import3(_: *mut u8, ) -> i32 { unreachable!() }
                                                                          let ret = wit_import3(ptr0);
                                                                          GpuTextureView::from_handle(ret as u32)
                                                                        }
                                                                      }
                                                                    }
                                                                    impl GpuTexture {
                                                                      #[allow(unused_unsafe, clippy::all)]
                                                                      #[allow(async_fn_in_trait)]
                                                                      pub fn destroy(&self,) -> (){
                                                                        unsafe {

                                                                          #[cfg(target_arch = "wasm32")]
                                                                          #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                          unsafe extern "C" {
                                                                            #[link_name = "[method]gpu-texture.destroy"]
                                                                            fn wit_import0(_: i32, );
                                                                          }

                                                                          #[cfg(not(target_arch = "wasm32"))]
                                                                          unsafe extern "C" fn wit_import0(_: i32, ) { unreachable!() }
                                                                          wit_import0((self).handle() as i32);
                                                                        }
                                                                      }
                                                                    }
                                                                    impl GpuTexture {
                                                                      #[allow(unused_unsafe, clippy::all)]
                                                                      #[allow(async_fn_in_trait)]
                                                                      pub fn width(&self,) -> GpuIntegerCoordinateOut{
                                                                        unsafe {

                                                                          #[cfg(target_arch = "wasm32")]
                                                                          #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                          unsafe extern "C" {
                                                                            #[link_name = "[method]gpu-texture.width"]
                                                                            fn wit_import0(_: i32, ) -> i32;
                                                                          }

                                                                          #[cfg(not(target_arch = "wasm32"))]
                                                                          unsafe extern "C" fn wit_import0(_: i32, ) -> i32 { unreachable!() }
                                                                          let ret = wit_import0((self).handle() as i32);
                                                                          ret as u32
                                                                        }
                                                                      }
                                                                    }
                                                                    impl GpuTexture {
                                                                      #[allow(unused_unsafe, clippy::all)]
                                                                      #[allow(async_fn_in_trait)]
                                                                      pub fn height(&self,) -> GpuIntegerCoordinateOut{
                                                                        unsafe {

                                                                          #[cfg(target_arch = "wasm32")]
                                                                          #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                          unsafe extern "C" {
                                                                            #[link_name = "[method]gpu-texture.height"]
                                                                            fn wit_import0(_: i32, ) -> i32;
                                                                          }

                                                                          #[cfg(not(target_arch = "wasm32"))]
                                                                          unsafe extern "C" fn wit_import0(_: i32, ) -> i32 { unreachable!() }
                                                                          let ret = wit_import0((self).handle() as i32);
                                                                          ret as u32
                                                                        }
                                                                      }
                                                                    }
                                                                    impl GpuTexture {
                                                                      #[allow(unused_unsafe, clippy::all)]
                                                                      #[allow(async_fn_in_trait)]
                                                                      pub fn depth_or_array_layers(&self,) -> GpuIntegerCoordinateOut{
                                                                        unsafe {

                                                                          #[cfg(target_arch = "wasm32")]
                                                                          #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                          unsafe extern "C" {
                                                                            #[link_name = "[method]gpu-texture.depth-or-array-layers"]
                                                                            fn wit_import0(_: i32, ) -> i32;
                                                                          }

                                                                          #[cfg(not(target_arch = "wasm32"))]
                                                                          unsafe extern "C" fn wit_import0(_: i32, ) -> i32 { unreachable!() }
                                                                          let ret = wit_import0((self).handle() as i32);
                                                                          ret as u32
                                                                        }
                                                                      }
                                                                    }
                                                                    impl GpuTexture {
                                                                      #[allow(unused_unsafe, clippy::all)]
                                                                      #[allow(async_fn_in_trait)]
                                                                      pub fn mip_level_count(&self,) -> GpuIntegerCoordinateOut{
                                                                        unsafe {

                                                                          #[cfg(target_arch = "wasm32")]
                                                                          #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                          unsafe extern "C" {
                                                                            #[link_name = "[method]gpu-texture.mip-level-count"]
                                                                            fn wit_import0(_: i32, ) -> i32;
                                                                          }

                                                                          #[cfg(not(target_arch = "wasm32"))]
                                                                          unsafe extern "C" fn wit_import0(_: i32, ) -> i32 { unreachable!() }
                                                                          let ret = wit_import0((self).handle() as i32);
                                                                          ret as u32
                                                                        }
                                                                      }
                                                                    }
                                                                    impl GpuTexture {
                                                                      #[allow(unused_unsafe, clippy::all)]
                                                                      #[allow(async_fn_in_trait)]
                                                                      pub fn sample_count(&self,) -> GpuSize32Out{
                                                                        unsafe {

                                                                          #[cfg(target_arch = "wasm32")]
                                                                          #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                          unsafe extern "C" {
                                                                            #[link_name = "[method]gpu-texture.sample-count"]
                                                                            fn wit_import0(_: i32, ) -> i32;
                                                                          }

                                                                          #[cfg(not(target_arch = "wasm32"))]
                                                                          unsafe extern "C" fn wit_import0(_: i32, ) -> i32 { unreachable!() }
                                                                          let ret = wit_import0((self).handle() as i32);
                                                                          ret as u32
                                                                        }
                                                                      }
                                                                    }
                                                                    impl GpuTexture {
                                                                      #[allow(unused_unsafe, clippy::all)]
                                                                      #[allow(async_fn_in_trait)]
                                                                      pub fn dimension(&self,) -> GpuTextureDimension{
                                                                        unsafe {

                                                                          #[cfg(target_arch = "wasm32")]
                                                                          #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                          unsafe extern "C" {
                                                                            #[link_name = "[method]gpu-texture.dimension"]
                                                                            fn wit_import0(_: i32, ) -> i32;
                                                                          }

                                                                          #[cfg(not(target_arch = "wasm32"))]
                                                                          unsafe extern "C" fn wit_import0(_: i32, ) -> i32 { unreachable!() }
                                                                          let ret = wit_import0((self).handle() as i32);
                                                                          GpuTextureDimension::_lift(ret as u8)
                                                                        }
                                                                      }
                                                                    }
                                                                    impl GpuTexture {
                                                                      #[allow(unused_unsafe, clippy::all)]
                                                                      #[allow(async_fn_in_trait)]
                                                                      pub fn format(&self,) -> GpuTextureFormat{
                                                                        unsafe {

                                                                          #[cfg(target_arch = "wasm32")]
                                                                          #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                          unsafe extern "C" {
                                                                            #[link_name = "[method]gpu-texture.format"]
                                                                            fn wit_import0(_: i32, ) -> i32;
                                                                          }

                                                                          #[cfg(not(target_arch = "wasm32"))]
                                                                          unsafe extern "C" fn wit_import0(_: i32, ) -> i32 { unreachable!() }
                                                                          let ret = wit_import0((self).handle() as i32);
                                                                          GpuTextureFormat::_lift(ret as u8)
                                                                        }
                                                                      }
                                                                    }
                                                                    impl GpuTexture {
                                                                      #[allow(unused_unsafe, clippy::all)]
                                                                      #[allow(async_fn_in_trait)]
                                                                      pub fn usage(&self,) -> GpuFlagsConstant{
                                                                        unsafe {

                                                                          #[cfg(target_arch = "wasm32")]
                                                                          #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                          unsafe extern "C" {
                                                                            #[link_name = "[method]gpu-texture.usage"]
                                                                            fn wit_import0(_: i32, ) -> i32;
                                                                          }

                                                                          #[cfg(not(target_arch = "wasm32"))]
                                                                          unsafe extern "C" fn wit_import0(_: i32, ) -> i32 { unreachable!() }
                                                                          let ret = wit_import0((self).handle() as i32);
                                                                          ret as u32
                                                                        }
                                                                      }
                                                                    }
                                                                    impl GpuTexture {
                                                                      #[allow(unused_unsafe, clippy::all)]
                                                                      #[allow(async_fn_in_trait)]
                                                                      pub fn label(&self,) -> _rt::String{
                                                                        unsafe {

                                                                          #[cfg_attr(target_pointer_width="64", repr(align(8)))]
                                                                          #[cfg_attr(target_pointer_width="32", repr(align(4)))]
                                                                          struct RetArea([::core::mem::MaybeUninit::<u8>; 2*::core::mem::size_of::<*const u8>()]);
                                                                          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2*::core::mem::size_of::<*const u8>()]);
                                                                          let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                                                                          #[cfg(target_arch = "wasm32")]
                                                                          #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                          unsafe extern "C" {
                                                                            #[link_name = "[method]gpu-texture.label"]
                                                                            fn wit_import1(_: i32, _: *mut u8, );
                                                                          }

                                                                          #[cfg(not(target_arch = "wasm32"))]
                                                                          unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, ) { unreachable!() }
                                                                          wit_import1((self).handle() as i32, ptr0);
                                                                          let l2 = *ptr0.add(0).cast::<*mut u8>();
                                                                          let l3 = *ptr0.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
                                                                          let len4 = l3;
                                                                          let bytes4 = _rt::Vec::from_raw_parts(l2.cast(), len4, len4);
                                                                          let result5 = _rt::string_lift(bytes4);
                                                                          result5
                                                                        }
                                                                      }
                                                                    }
                                                                    impl GpuTexture {
                                                                      #[allow(unused_unsafe, clippy::all)]
                                                                      #[allow(async_fn_in_trait)]
                                                                      pub fn set_label(&self,label: &str,) -> (){
                                                                        unsafe {
                                                                          let vec0 = label;
                                                                          let ptr0 = vec0.as_ptr().cast::<u8>();
                                                                          let len0 = vec0.len();

                                                                          #[cfg(target_arch = "wasm32")]
                                                                          #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                          unsafe extern "C" {
                                                                            #[link_name = "[method]gpu-texture.set-label"]
                                                                            fn wit_import1(_: i32, _: *mut u8, _: usize, );
                                                                          }

                                                                          #[cfg(not(target_arch = "wasm32"))]
                                                                          unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, _: usize, ) { unreachable!() }
                                                                          wit_import1((self).handle() as i32, ptr0.cast_mut(), len0);
                                                                        }
                                                                      }
                                                                    }
                                                                    impl GpuTexture {
                                                                      #[allow(unused_unsafe, clippy::all)]
                                                                      #[allow(async_fn_in_trait)]
                                                                      pub fn from_graphics_buffer(buffer: AbstractBuffer,) -> GpuTexture{
                                                                        unsafe {

                                                                          #[cfg(target_arch = "wasm32")]
                                                                          #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                          unsafe extern "C" {
                                                                            #[link_name = "[static]gpu-texture.from-graphics-buffer"]
                                                                            fn wit_import0(_: i32, ) -> i32;
                                                                          }

                                                                          #[cfg(not(target_arch = "wasm32"))]
                                                                          unsafe extern "C" fn wit_import0(_: i32, ) -> i32 { unreachable!() }
                                                                          let ret = wit_import0((&buffer).take_handle() as i32);
                                                                          GpuTexture::from_handle(ret as u32)
                                                                        }
                                                                      }
                                                                    }
                                                                    impl GpuTextureUsage {
                                                                      #[allow(unused_unsafe, clippy::all)]
                                                                      #[allow(async_fn_in_trait)]
                                                                      pub fn copy_src() -> GpuFlagsConstant{
                                                                        unsafe {

                                                                          #[cfg(target_arch = "wasm32")]
                                                                          #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                          unsafe extern "C" {
                                                                            #[link_name = "[static]gpu-texture-usage.COPY-SRC"]
                                                                            fn wit_import0() -> i32;
                                                                          }

                                                                          #[cfg(not(target_arch = "wasm32"))]
                                                                          unsafe extern "C" fn wit_import0() -> i32 { unreachable!() }
                                                                          let ret = wit_import0();
                                                                          ret as u32
                                                                        }
                                                                      }
                                                                    }
                                                                    impl GpuTextureUsage {
                                                                      #[allow(unused_unsafe, clippy::all)]
                                                                      #[allow(async_fn_in_trait)]
                                                                      pub fn copy_dst() -> GpuFlagsConstant{
                                                                        unsafe {

                                                                          #[cfg(target_arch = "wasm32")]
                                                                          #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                          unsafe extern "C" {
                                                                            #[link_name = "[static]gpu-texture-usage.COPY-DST"]
                                                                            fn wit_import0() -> i32;
                                                                          }

                                                                          #[cfg(not(target_arch = "wasm32"))]
                                                                          unsafe extern "C" fn wit_import0() -> i32 { unreachable!() }
                                                                          let ret = wit_import0();
                                                                          ret as u32
                                                                        }
                                                                      }
                                                                    }
                                                                    impl GpuTextureUsage {
                                                                      #[allow(unused_unsafe, clippy::all)]
                                                                      #[allow(async_fn_in_trait)]
                                                                      pub fn texture_binding() -> GpuFlagsConstant{
                                                                        unsafe {

                                                                          #[cfg(target_arch = "wasm32")]
                                                                          #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                          unsafe extern "C" {
                                                                            #[link_name = "[static]gpu-texture-usage.TEXTURE-BINDING"]
                                                                            fn wit_import0() -> i32;
                                                                          }

                                                                          #[cfg(not(target_arch = "wasm32"))]
                                                                          unsafe extern "C" fn wit_import0() -> i32 { unreachable!() }
                                                                          let ret = wit_import0();
                                                                          ret as u32
                                                                        }
                                                                      }
                                                                    }
                                                                    impl GpuTextureUsage {
                                                                      #[allow(unused_unsafe, clippy::all)]
                                                                      #[allow(async_fn_in_trait)]
                                                                      pub fn storage_binding() -> GpuFlagsConstant{
                                                                        unsafe {

                                                                          #[cfg(target_arch = "wasm32")]
                                                                          #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                          unsafe extern "C" {
                                                                            #[link_name = "[static]gpu-texture-usage.STORAGE-BINDING"]
                                                                            fn wit_import0() -> i32;
                                                                          }

                                                                          #[cfg(not(target_arch = "wasm32"))]
                                                                          unsafe extern "C" fn wit_import0() -> i32 { unreachable!() }
                                                                          let ret = wit_import0();
                                                                          ret as u32
                                                                        }
                                                                      }
                                                                    }
                                                                    impl GpuTextureUsage {
                                                                      #[allow(unused_unsafe, clippy::all)]
                                                                      #[allow(async_fn_in_trait)]
                                                                      pub fn render_attachment() -> GpuFlagsConstant{
                                                                        unsafe {

                                                                          #[cfg(target_arch = "wasm32")]
                                                                          #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                          unsafe extern "C" {
                                                                            #[link_name = "[static]gpu-texture-usage.RENDER-ATTACHMENT"]
                                                                            fn wit_import0() -> i32;
                                                                          }

                                                                          #[cfg(not(target_arch = "wasm32"))]
                                                                          unsafe extern "C" fn wit_import0() -> i32 { unreachable!() }
                                                                          let ret = wit_import0();
                                                                          ret as u32
                                                                        }
                                                                      }
                                                                    }
                                                                    impl GpuTextureView {
                                                                      #[allow(unused_unsafe, clippy::all)]
                                                                      #[allow(async_fn_in_trait)]
                                                                      pub fn label(&self,) -> _rt::String{
                                                                        unsafe {

                                                                          #[cfg_attr(target_pointer_width="64", repr(align(8)))]
                                                                          #[cfg_attr(target_pointer_width="32", repr(align(4)))]
                                                                          struct RetArea([::core::mem::MaybeUninit::<u8>; 2*::core::mem::size_of::<*const u8>()]);
                                                                          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2*::core::mem::size_of::<*const u8>()]);
                                                                          let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                                                                          #[cfg(target_arch = "wasm32")]
                                                                          #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                          unsafe extern "C" {
                                                                            #[link_name = "[method]gpu-texture-view.label"]
                                                                            fn wit_import1(_: i32, _: *mut u8, );
                                                                          }

                                                                          #[cfg(not(target_arch = "wasm32"))]
                                                                          unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, ) { unreachable!() }
                                                                          wit_import1((self).handle() as i32, ptr0);
                                                                          let l2 = *ptr0.add(0).cast::<*mut u8>();
                                                                          let l3 = *ptr0.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
                                                                          let len4 = l3;
                                                                          let bytes4 = _rt::Vec::from_raw_parts(l2.cast(), len4, len4);
                                                                          let result5 = _rt::string_lift(bytes4);
                                                                          result5
                                                                        }
                                                                      }
                                                                    }
                                                                    impl GpuTextureView {
                                                                      #[allow(unused_unsafe, clippy::all)]
                                                                      #[allow(async_fn_in_trait)]
                                                                      pub fn set_label(&self,label: &str,) -> (){
                                                                        unsafe {
                                                                          let vec0 = label;
                                                                          let ptr0 = vec0.as_ptr().cast::<u8>();
                                                                          let len0 = vec0.len();

                                                                          #[cfg(target_arch = "wasm32")]
                                                                          #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                          unsafe extern "C" {
                                                                            #[link_name = "[method]gpu-texture-view.set-label"]
                                                                            fn wit_import1(_: i32, _: *mut u8, _: usize, );
                                                                          }

                                                                          #[cfg(not(target_arch = "wasm32"))]
                                                                          unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, _: usize, ) { unreachable!() }
                                                                          wit_import1((self).handle() as i32, ptr0.cast_mut(), len0);
                                                                        }
                                                                      }
                                                                    }
                                                                    impl GpuSampler {
                                                                      #[allow(unused_unsafe, clippy::all)]
                                                                      #[allow(async_fn_in_trait)]
                                                                      pub fn label(&self,) -> _rt::String{
                                                                        unsafe {

                                                                          #[cfg_attr(target_pointer_width="64", repr(align(8)))]
                                                                          #[cfg_attr(target_pointer_width="32", repr(align(4)))]
                                                                          struct RetArea([::core::mem::MaybeUninit::<u8>; 2*::core::mem::size_of::<*const u8>()]);
                                                                          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2*::core::mem::size_of::<*const u8>()]);
                                                                          let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                                                                          #[cfg(target_arch = "wasm32")]
                                                                          #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                          unsafe extern "C" {
                                                                            #[link_name = "[method]gpu-sampler.label"]
                                                                            fn wit_import1(_: i32, _: *mut u8, );
                                                                          }

                                                                          #[cfg(not(target_arch = "wasm32"))]
                                                                          unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, ) { unreachable!() }
                                                                          wit_import1((self).handle() as i32, ptr0);
                                                                          let l2 = *ptr0.add(0).cast::<*mut u8>();
                                                                          let l3 = *ptr0.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
                                                                          let len4 = l3;
                                                                          let bytes4 = _rt::Vec::from_raw_parts(l2.cast(), len4, len4);
                                                                          let result5 = _rt::string_lift(bytes4);
                                                                          result5
                                                                        }
                                                                      }
                                                                    }
                                                                    impl GpuSampler {
                                                                      #[allow(unused_unsafe, clippy::all)]
                                                                      #[allow(async_fn_in_trait)]
                                                                      pub fn set_label(&self,label: &str,) -> (){
                                                                        unsafe {
                                                                          let vec0 = label;
                                                                          let ptr0 = vec0.as_ptr().cast::<u8>();
                                                                          let len0 = vec0.len();

                                                                          #[cfg(target_arch = "wasm32")]
                                                                          #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                          unsafe extern "C" {
                                                                            #[link_name = "[method]gpu-sampler.set-label"]
                                                                            fn wit_import1(_: i32, _: *mut u8, _: usize, );
                                                                          }

                                                                          #[cfg(not(target_arch = "wasm32"))]
                                                                          unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, _: usize, ) { unreachable!() }
                                                                          wit_import1((self).handle() as i32, ptr0.cast_mut(), len0);
                                                                        }
                                                                      }
                                                                    }
                                                                    impl GpuBindGroupLayout {
                                                                      #[allow(unused_unsafe, clippy::all)]
                                                                      #[allow(async_fn_in_trait)]
                                                                      pub fn label(&self,) -> _rt::String{
                                                                        unsafe {

                                                                          #[cfg_attr(target_pointer_width="64", repr(align(8)))]
                                                                          #[cfg_attr(target_pointer_width="32", repr(align(4)))]
                                                                          struct RetArea([::core::mem::MaybeUninit::<u8>; 2*::core::mem::size_of::<*const u8>()]);
                                                                          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2*::core::mem::size_of::<*const u8>()]);
                                                                          let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                                                                          #[cfg(target_arch = "wasm32")]
                                                                          #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                          unsafe extern "C" {
                                                                            #[link_name = "[method]gpu-bind-group-layout.label"]
                                                                            fn wit_import1(_: i32, _: *mut u8, );
                                                                          }

                                                                          #[cfg(not(target_arch = "wasm32"))]
                                                                          unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, ) { unreachable!() }
                                                                          wit_import1((self).handle() as i32, ptr0);
                                                                          let l2 = *ptr0.add(0).cast::<*mut u8>();
                                                                          let l3 = *ptr0.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
                                                                          let len4 = l3;
                                                                          let bytes4 = _rt::Vec::from_raw_parts(l2.cast(), len4, len4);
                                                                          let result5 = _rt::string_lift(bytes4);
                                                                          result5
                                                                        }
                                                                      }
                                                                    }
                                                                    impl GpuBindGroupLayout {
                                                                      #[allow(unused_unsafe, clippy::all)]
                                                                      #[allow(async_fn_in_trait)]
                                                                      pub fn set_label(&self,label: &str,) -> (){
                                                                        unsafe {
                                                                          let vec0 = label;
                                                                          let ptr0 = vec0.as_ptr().cast::<u8>();
                                                                          let len0 = vec0.len();

                                                                          #[cfg(target_arch = "wasm32")]
                                                                          #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                          unsafe extern "C" {
                                                                            #[link_name = "[method]gpu-bind-group-layout.set-label"]
                                                                            fn wit_import1(_: i32, _: *mut u8, _: usize, );
                                                                          }

                                                                          #[cfg(not(target_arch = "wasm32"))]
                                                                          unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, _: usize, ) { unreachable!() }
                                                                          wit_import1((self).handle() as i32, ptr0.cast_mut(), len0);
                                                                        }
                                                                      }
                                                                    }
                                                                    impl GpuShaderStage {
                                                                      #[allow(unused_unsafe, clippy::all)]
                                                                      #[allow(async_fn_in_trait)]
                                                                      pub fn vertex() -> GpuFlagsConstant{
                                                                        unsafe {

                                                                          #[cfg(target_arch = "wasm32")]
                                                                          #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                          unsafe extern "C" {
                                                                            #[link_name = "[static]gpu-shader-stage.VERTEX"]
                                                                            fn wit_import0() -> i32;
                                                                          }

                                                                          #[cfg(not(target_arch = "wasm32"))]
                                                                          unsafe extern "C" fn wit_import0() -> i32 { unreachable!() }
                                                                          let ret = wit_import0();
                                                                          ret as u32
                                                                        }
                                                                      }
                                                                    }
                                                                    impl GpuShaderStage {
                                                                      #[allow(unused_unsafe, clippy::all)]
                                                                      #[allow(async_fn_in_trait)]
                                                                      pub fn fragment() -> GpuFlagsConstant{
                                                                        unsafe {

                                                                          #[cfg(target_arch = "wasm32")]
                                                                          #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                          unsafe extern "C" {
                                                                            #[link_name = "[static]gpu-shader-stage.FRAGMENT"]
                                                                            fn wit_import0() -> i32;
                                                                          }

                                                                          #[cfg(not(target_arch = "wasm32"))]
                                                                          unsafe extern "C" fn wit_import0() -> i32 { unreachable!() }
                                                                          let ret = wit_import0();
                                                                          ret as u32
                                                                        }
                                                                      }
                                                                    }
                                                                    impl GpuShaderStage {
                                                                      #[allow(unused_unsafe, clippy::all)]
                                                                      #[allow(async_fn_in_trait)]
                                                                      pub fn compute() -> GpuFlagsConstant{
                                                                        unsafe {

                                                                          #[cfg(target_arch = "wasm32")]
                                                                          #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                          unsafe extern "C" {
                                                                            #[link_name = "[static]gpu-shader-stage.COMPUTE"]
                                                                            fn wit_import0() -> i32;
                                                                          }

                                                                          #[cfg(not(target_arch = "wasm32"))]
                                                                          unsafe extern "C" fn wit_import0() -> i32 { unreachable!() }
                                                                          let ret = wit_import0();
                                                                          ret as u32
                                                                        }
                                                                      }
                                                                    }
                                                                    impl GpuBindGroup {
                                                                      #[allow(unused_unsafe, clippy::all)]
                                                                      #[allow(async_fn_in_trait)]
                                                                      pub fn label(&self,) -> _rt::String{
                                                                        unsafe {

                                                                          #[cfg_attr(target_pointer_width="64", repr(align(8)))]
                                                                          #[cfg_attr(target_pointer_width="32", repr(align(4)))]
                                                                          struct RetArea([::core::mem::MaybeUninit::<u8>; 2*::core::mem::size_of::<*const u8>()]);
                                                                          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2*::core::mem::size_of::<*const u8>()]);
                                                                          let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                                                                          #[cfg(target_arch = "wasm32")]
                                                                          #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                          unsafe extern "C" {
                                                                            #[link_name = "[method]gpu-bind-group.label"]
                                                                            fn wit_import1(_: i32, _: *mut u8, );
                                                                          }

                                                                          #[cfg(not(target_arch = "wasm32"))]
                                                                          unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, ) { unreachable!() }
                                                                          wit_import1((self).handle() as i32, ptr0);
                                                                          let l2 = *ptr0.add(0).cast::<*mut u8>();
                                                                          let l3 = *ptr0.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
                                                                          let len4 = l3;
                                                                          let bytes4 = _rt::Vec::from_raw_parts(l2.cast(), len4, len4);
                                                                          let result5 = _rt::string_lift(bytes4);
                                                                          result5
                                                                        }
                                                                      }
                                                                    }
                                                                    impl GpuBindGroup {
                                                                      #[allow(unused_unsafe, clippy::all)]
                                                                      #[allow(async_fn_in_trait)]
                                                                      pub fn set_label(&self,label: &str,) -> (){
                                                                        unsafe {
                                                                          let vec0 = label;
                                                                          let ptr0 = vec0.as_ptr().cast::<u8>();
                                                                          let len0 = vec0.len();

                                                                          #[cfg(target_arch = "wasm32")]
                                                                          #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                          unsafe extern "C" {
                                                                            #[link_name = "[method]gpu-bind-group.set-label"]
                                                                            fn wit_import1(_: i32, _: *mut u8, _: usize, );
                                                                          }

                                                                          #[cfg(not(target_arch = "wasm32"))]
                                                                          unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, _: usize, ) { unreachable!() }
                                                                          wit_import1((self).handle() as i32, ptr0.cast_mut(), len0);
                                                                        }
                                                                      }
                                                                    }
                                                                    impl GpuPipelineLayout {
                                                                      #[allow(unused_unsafe, clippy::all)]
                                                                      #[allow(async_fn_in_trait)]
                                                                      pub fn label(&self,) -> _rt::String{
                                                                        unsafe {

                                                                          #[cfg_attr(target_pointer_width="64", repr(align(8)))]
                                                                          #[cfg_attr(target_pointer_width="32", repr(align(4)))]
                                                                          struct RetArea([::core::mem::MaybeUninit::<u8>; 2*::core::mem::size_of::<*const u8>()]);
                                                                          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2*::core::mem::size_of::<*const u8>()]);
                                                                          let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                                                                          #[cfg(target_arch = "wasm32")]
                                                                          #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                          unsafe extern "C" {
                                                                            #[link_name = "[method]gpu-pipeline-layout.label"]
                                                                            fn wit_import1(_: i32, _: *mut u8, );
                                                                          }

                                                                          #[cfg(not(target_arch = "wasm32"))]
                                                                          unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, ) { unreachable!() }
                                                                          wit_import1((self).handle() as i32, ptr0);
                                                                          let l2 = *ptr0.add(0).cast::<*mut u8>();
                                                                          let l3 = *ptr0.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
                                                                          let len4 = l3;
                                                                          let bytes4 = _rt::Vec::from_raw_parts(l2.cast(), len4, len4);
                                                                          let result5 = _rt::string_lift(bytes4);
                                                                          result5
                                                                        }
                                                                      }
                                                                    }
                                                                    impl GpuPipelineLayout {
                                                                      #[allow(unused_unsafe, clippy::all)]
                                                                      #[allow(async_fn_in_trait)]
                                                                      pub fn set_label(&self,label: &str,) -> (){
                                                                        unsafe {
                                                                          let vec0 = label;
                                                                          let ptr0 = vec0.as_ptr().cast::<u8>();
                                                                          let len0 = vec0.len();

                                                                          #[cfg(target_arch = "wasm32")]
                                                                          #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                          unsafe extern "C" {
                                                                            #[link_name = "[method]gpu-pipeline-layout.set-label"]
                                                                            fn wit_import1(_: i32, _: *mut u8, _: usize, );
                                                                          }

                                                                          #[cfg(not(target_arch = "wasm32"))]
                                                                          unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, _: usize, ) { unreachable!() }
                                                                          wit_import1((self).handle() as i32, ptr0.cast_mut(), len0);
                                                                        }
                                                                      }
                                                                    }
                                                                    impl GpuShaderModule {
                                                                      #[allow(unused_unsafe, clippy::all)]
                                                                      #[allow(async_fn_in_trait)]
                                                                      pub fn get_compilation_info(&self,) -> GpuCompilationInfo{
                                                                        unsafe {

                                                                          #[cfg(target_arch = "wasm32")]
                                                                          #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                          unsafe extern "C" {
                                                                            #[link_name = "[method]gpu-shader-module.get-compilation-info"]
                                                                            fn wit_import0(_: i32, ) -> i32;
                                                                          }

                                                                          #[cfg(not(target_arch = "wasm32"))]
                                                                          unsafe extern "C" fn wit_import0(_: i32, ) -> i32 { unreachable!() }
                                                                          let ret = wit_import0((self).handle() as i32);
                                                                          GpuCompilationInfo::from_handle(ret as u32)
                                                                        }
                                                                      }
                                                                    }
                                                                    impl GpuShaderModule {
                                                                      #[allow(unused_unsafe, clippy::all)]
                                                                      #[allow(async_fn_in_trait)]
                                                                      pub fn label(&self,) -> _rt::String{
                                                                        unsafe {

                                                                          #[cfg_attr(target_pointer_width="64", repr(align(8)))]
                                                                          #[cfg_attr(target_pointer_width="32", repr(align(4)))]
                                                                          struct RetArea([::core::mem::MaybeUninit::<u8>; 2*::core::mem::size_of::<*const u8>()]);
                                                                          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2*::core::mem::size_of::<*const u8>()]);
                                                                          let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                                                                          #[cfg(target_arch = "wasm32")]
                                                                          #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                          unsafe extern "C" {
                                                                            #[link_name = "[method]gpu-shader-module.label"]
                                                                            fn wit_import1(_: i32, _: *mut u8, );
                                                                          }

                                                                          #[cfg(not(target_arch = "wasm32"))]
                                                                          unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, ) { unreachable!() }
                                                                          wit_import1((self).handle() as i32, ptr0);
                                                                          let l2 = *ptr0.add(0).cast::<*mut u8>();
                                                                          let l3 = *ptr0.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
                                                                          let len4 = l3;
                                                                          let bytes4 = _rt::Vec::from_raw_parts(l2.cast(), len4, len4);
                                                                          let result5 = _rt::string_lift(bytes4);
                                                                          result5
                                                                        }
                                                                      }
                                                                    }
                                                                    impl GpuShaderModule {
                                                                      #[allow(unused_unsafe, clippy::all)]
                                                                      #[allow(async_fn_in_trait)]
                                                                      pub fn set_label(&self,label: &str,) -> (){
                                                                        unsafe {
                                                                          let vec0 = label;
                                                                          let ptr0 = vec0.as_ptr().cast::<u8>();
                                                                          let len0 = vec0.len();

                                                                          #[cfg(target_arch = "wasm32")]
                                                                          #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                          unsafe extern "C" {
                                                                            #[link_name = "[method]gpu-shader-module.set-label"]
                                                                            fn wit_import1(_: i32, _: *mut u8, _: usize, );
                                                                          }

                                                                          #[cfg(not(target_arch = "wasm32"))]
                                                                          unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, _: usize, ) { unreachable!() }
                                                                          wit_import1((self).handle() as i32, ptr0.cast_mut(), len0);
                                                                        }
                                                                      }
                                                                    }
                                                                    impl GpuCompilationMessage {
                                                                      #[allow(unused_unsafe, clippy::all)]
                                                                      #[allow(async_fn_in_trait)]
                                                                      pub fn message(&self,) -> _rt::String{
                                                                        unsafe {

                                                                          #[cfg_attr(target_pointer_width="64", repr(align(8)))]
                                                                          #[cfg_attr(target_pointer_width="32", repr(align(4)))]
                                                                          struct RetArea([::core::mem::MaybeUninit::<u8>; 2*::core::mem::size_of::<*const u8>()]);
                                                                          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2*::core::mem::size_of::<*const u8>()]);
                                                                          let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                                                                          #[cfg(target_arch = "wasm32")]
                                                                          #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                          unsafe extern "C" {
                                                                            #[link_name = "[method]gpu-compilation-message.message"]
                                                                            fn wit_import1(_: i32, _: *mut u8, );
                                                                          }

                                                                          #[cfg(not(target_arch = "wasm32"))]
                                                                          unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, ) { unreachable!() }
                                                                          wit_import1((self).handle() as i32, ptr0);
                                                                          let l2 = *ptr0.add(0).cast::<*mut u8>();
                                                                          let l3 = *ptr0.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
                                                                          let len4 = l3;
                                                                          let bytes4 = _rt::Vec::from_raw_parts(l2.cast(), len4, len4);
                                                                          let result5 = _rt::string_lift(bytes4);
                                                                          result5
                                                                        }
                                                                      }
                                                                    }
                                                                    impl GpuCompilationMessage {
                                                                      #[allow(unused_unsafe, clippy::all)]
                                                                      #[allow(async_fn_in_trait)]
                                                                      pub fn type_(&self,) -> GpuCompilationMessageType{
                                                                        unsafe {

                                                                          #[cfg(target_arch = "wasm32")]
                                                                          #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                          unsafe extern "C" {
                                                                            #[link_name = "[method]gpu-compilation-message.type"]
                                                                            fn wit_import0(_: i32, ) -> i32;
                                                                          }

                                                                          #[cfg(not(target_arch = "wasm32"))]
                                                                          unsafe extern "C" fn wit_import0(_: i32, ) -> i32 { unreachable!() }
                                                                          let ret = wit_import0((self).handle() as i32);
                                                                          GpuCompilationMessageType::_lift(ret as u8)
                                                                        }
                                                                      }
                                                                    }
                                                                    impl GpuCompilationMessage {
                                                                      #[allow(unused_unsafe, clippy::all)]
                                                                      #[allow(async_fn_in_trait)]
                                                                      pub fn line_num(&self,) -> u64{
                                                                        unsafe {

                                                                          #[cfg(target_arch = "wasm32")]
                                                                          #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                          unsafe extern "C" {
                                                                            #[link_name = "[method]gpu-compilation-message.line-num"]
                                                                            fn wit_import0(_: i32, ) -> i64;
                                                                          }

                                                                          #[cfg(not(target_arch = "wasm32"))]
                                                                          unsafe extern "C" fn wit_import0(_: i32, ) -> i64 { unreachable!() }
                                                                          let ret = wit_import0((self).handle() as i32);
                                                                          ret as u64
                                                                        }
                                                                      }
                                                                    }
                                                                    impl GpuCompilationMessage {
                                                                      #[allow(unused_unsafe, clippy::all)]
                                                                      #[allow(async_fn_in_trait)]
                                                                      pub fn line_pos(&self,) -> u64{
                                                                        unsafe {

                                                                          #[cfg(target_arch = "wasm32")]
                                                                          #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                          unsafe extern "C" {
                                                                            #[link_name = "[method]gpu-compilation-message.line-pos"]
                                                                            fn wit_import0(_: i32, ) -> i64;
                                                                          }

                                                                          #[cfg(not(target_arch = "wasm32"))]
                                                                          unsafe extern "C" fn wit_import0(_: i32, ) -> i64 { unreachable!() }
                                                                          let ret = wit_import0((self).handle() as i32);
                                                                          ret as u64
                                                                        }
                                                                      }
                                                                    }
                                                                    impl GpuCompilationMessage {
                                                                      #[allow(unused_unsafe, clippy::all)]
                                                                      #[allow(async_fn_in_trait)]
                                                                      pub fn offset(&self,) -> u64{
                                                                        unsafe {

                                                                          #[cfg(target_arch = "wasm32")]
                                                                          #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                          unsafe extern "C" {
                                                                            #[link_name = "[method]gpu-compilation-message.offset"]
                                                                            fn wit_import0(_: i32, ) -> i64;
                                                                          }

                                                                          #[cfg(not(target_arch = "wasm32"))]
                                                                          unsafe extern "C" fn wit_import0(_: i32, ) -> i64 { unreachable!() }
                                                                          let ret = wit_import0((self).handle() as i32);
                                                                          ret as u64
                                                                        }
                                                                      }
                                                                    }
                                                                    impl GpuCompilationMessage {
                                                                      #[allow(unused_unsafe, clippy::all)]
                                                                      #[allow(async_fn_in_trait)]
                                                                      pub fn length(&self,) -> u64{
                                                                        unsafe {

                                                                          #[cfg(target_arch = "wasm32")]
                                                                          #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                          unsafe extern "C" {
                                                                            #[link_name = "[method]gpu-compilation-message.length"]
                                                                            fn wit_import0(_: i32, ) -> i64;
                                                                          }

                                                                          #[cfg(not(target_arch = "wasm32"))]
                                                                          unsafe extern "C" fn wit_import0(_: i32, ) -> i64 { unreachable!() }
                                                                          let ret = wit_import0((self).handle() as i32);
                                                                          ret as u64
                                                                        }
                                                                      }
                                                                    }
                                                                    impl GpuCompilationInfo {
                                                                      #[allow(unused_unsafe, clippy::all)]
                                                                      #[allow(async_fn_in_trait)]
                                                                      pub fn messages(&self,) -> _rt::Vec::<GpuCompilationMessage>{
                                                                        unsafe {

                                                                          #[cfg_attr(target_pointer_width="64", repr(align(8)))]
                                                                          #[cfg_attr(target_pointer_width="32", repr(align(4)))]
                                                                          struct RetArea([::core::mem::MaybeUninit::<u8>; 2*::core::mem::size_of::<*const u8>()]);
                                                                          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2*::core::mem::size_of::<*const u8>()]);
                                                                          let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                                                                          #[cfg(target_arch = "wasm32")]
                                                                          #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                          unsafe extern "C" {
                                                                            #[link_name = "[method]gpu-compilation-info.messages"]
                                                                            fn wit_import1(_: i32, _: *mut u8, );
                                                                          }

                                                                          #[cfg(not(target_arch = "wasm32"))]
                                                                          unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, ) { unreachable!() }
                                                                          wit_import1((self).handle() as i32, ptr0);
                                                                          let l2 = *ptr0.add(0).cast::<*mut u8>();
                                                                          let l3 = *ptr0.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
                                                                          let base5 = l2;
                                                                          let len5 = l3;
                                                                          let mut result5 = _rt::Vec::with_capacity(len5);
                                                                          for i in 0..len5 {
                                                                            let base = base5.add(i * 4);
                                                                            let e5 = {
                                                                              let l4 = *base.add(0).cast::<i32>();

                                                                              GpuCompilationMessage::from_handle(l4 as u32)
                                                                            };
                                                                            result5.push(e5);
                                                                          }
                                                                          _rt::cabi_dealloc(base5, len5 * 4, 4);
                                                                          let result6 = result5;
                                                                          result6
                                                                        }
                                                                      }
                                                                    }
                                                                    impl RecordGpuPipelineConstantValue {
                                                                      #[allow(unused_unsafe, clippy::all)]
                                                                      #[allow(async_fn_in_trait)]
                                                                      pub fn new() -> Self{
                                                                        unsafe {

                                                                          #[cfg(target_arch = "wasm32")]
                                                                          #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                          unsafe extern "C" {
                                                                            #[link_name = "[constructor]record-gpu-pipeline-constant-value"]
                                                                            fn wit_import0() -> i32;
                                                                          }

                                                                          #[cfg(not(target_arch = "wasm32"))]
                                                                          unsafe extern "C" fn wit_import0() -> i32 { unreachable!() }
                                                                          let ret = wit_import0();
                                                                          RecordGpuPipelineConstantValue::from_handle(ret as u32)
                                                                        }
                                                                      }
                                                                    }
                                                                    impl RecordGpuPipelineConstantValue {
                                                                      #[allow(unused_unsafe, clippy::all)]
                                                                      #[allow(async_fn_in_trait)]
                                                                      pub fn add(&self,key: &str,value: GpuPipelineConstantValue,) -> (){
                                                                        unsafe {
                                                                          let vec0 = key;
                                                                          let ptr0 = vec0.as_ptr().cast::<u8>();
                                                                          let len0 = vec0.len();

                                                                          #[cfg(target_arch = "wasm32")]
                                                                          #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                          unsafe extern "C" {
                                                                            #[link_name = "[method]record-gpu-pipeline-constant-value.add"]
                                                                            fn wit_import1(_: i32, _: *mut u8, _: usize, _: f64, );
                                                                          }

                                                                          #[cfg(not(target_arch = "wasm32"))]
                                                                          unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, _: usize, _: f64, ) { unreachable!() }
                                                                          wit_import1((self).handle() as i32, ptr0.cast_mut(), len0, _rt::as_f64(value));
                                                                        }
                                                                      }
                                                                    }
                                                                    impl RecordGpuPipelineConstantValue {
                                                                      #[allow(unused_unsafe, clippy::all)]
                                                                      #[allow(async_fn_in_trait)]
                                                                      pub fn get(&self,key: &str,) -> Option<GpuPipelineConstantValue>{
                                                                        unsafe {

                                                                          #[repr(align(8))]
                                                                          struct RetArea([::core::mem::MaybeUninit::<u8>; 16]);
                                                                          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 16]);
                                                                          let vec0 = key;
                                                                          let ptr0 = vec0.as_ptr().cast::<u8>();
                                                                          let len0 = vec0.len();
                                                                          let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
                                                                          #[cfg(target_arch = "wasm32")]
                                                                          #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                          unsafe extern "C" {
                                                                            #[link_name = "[method]record-gpu-pipeline-constant-value.get"]
                                                                            fn wit_import2(_: i32, _: *mut u8, _: usize, _: *mut u8, );
                                                                          }

                                                                          #[cfg(not(target_arch = "wasm32"))]
                                                                          unsafe extern "C" fn wit_import2(_: i32, _: *mut u8, _: usize, _: *mut u8, ) { unreachable!() }
                                                                          wit_import2((self).handle() as i32, ptr0.cast_mut(), len0, ptr1);
                                                                          let l3 = i32::from(*ptr1.add(0).cast::<u8>());
                                                                          let result5 = match l3 {
                                                                            0 => None,
                                                                            1 => {
                                                                              let e = {
                                                                                let l4 = *ptr1.add(8).cast::<f64>();

                                                                                l4
                                                                              };
                                                                              Some(e)
                                                                            }
                                                                            _ => _rt::invalid_enum_discriminant(),
                                                                          };
                                                                          result5
                                                                        }
                                                                      }
                                                                    }
                                                                    impl RecordGpuPipelineConstantValue {
                                                                      #[allow(unused_unsafe, clippy::all)]
                                                                      #[allow(async_fn_in_trait)]
                                                                      pub fn has(&self,key: &str,) -> bool{
                                                                        unsafe {
                                                                          let vec0 = key;
                                                                          let ptr0 = vec0.as_ptr().cast::<u8>();
                                                                          let len0 = vec0.len();

                                                                          #[cfg(target_arch = "wasm32")]
                                                                          #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                          unsafe extern "C" {
                                                                            #[link_name = "[method]record-gpu-pipeline-constant-value.has"]
                                                                            fn wit_import1(_: i32, _: *mut u8, _: usize, ) -> i32;
                                                                          }

                                                                          #[cfg(not(target_arch = "wasm32"))]
                                                                          unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, _: usize, ) -> i32 { unreachable!() }
                                                                          let ret = wit_import1((self).handle() as i32, ptr0.cast_mut(), len0);
                                                                          _rt::bool_lift(ret as u8)
                                                                        }
                                                                      }
                                                                    }
                                                                    impl RecordGpuPipelineConstantValue {
                                                                      #[allow(unused_unsafe, clippy::all)]
                                                                      #[allow(async_fn_in_trait)]
                                                                      pub fn remove(&self,key: &str,) -> (){
                                                                        unsafe {
                                                                          let vec0 = key;
                                                                          let ptr0 = vec0.as_ptr().cast::<u8>();
                                                                          let len0 = vec0.len();

                                                                          #[cfg(target_arch = "wasm32")]
                                                                          #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                          unsafe extern "C" {
                                                                            #[link_name = "[method]record-gpu-pipeline-constant-value.remove"]
                                                                            fn wit_import1(_: i32, _: *mut u8, _: usize, );
                                                                          }

                                                                          #[cfg(not(target_arch = "wasm32"))]
                                                                          unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, _: usize, ) { unreachable!() }
                                                                          wit_import1((self).handle() as i32, ptr0.cast_mut(), len0);
                                                                        }
                                                                      }
                                                                    }
                                                                    impl RecordGpuPipelineConstantValue {
                                                                      #[allow(unused_unsafe, clippy::all)]
                                                                      #[allow(async_fn_in_trait)]
                                                                      pub fn keys(&self,) -> _rt::Vec::<_rt::String>{
                                                                        unsafe {

                                                                          #[cfg_attr(target_pointer_width="64", repr(align(8)))]
                                                                          #[cfg_attr(target_pointer_width="32", repr(align(4)))]
                                                                          struct RetArea([::core::mem::MaybeUninit::<u8>; 2*::core::mem::size_of::<*const u8>()]);
                                                                          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2*::core::mem::size_of::<*const u8>()]);
                                                                          let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                                                                          #[cfg(target_arch = "wasm32")]
                                                                          #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                          unsafe extern "C" {
                                                                            #[link_name = "[method]record-gpu-pipeline-constant-value.keys"]
                                                                            fn wit_import1(_: i32, _: *mut u8, );
                                                                          }

                                                                          #[cfg(not(target_arch = "wasm32"))]
                                                                          unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, ) { unreachable!() }
                                                                          wit_import1((self).handle() as i32, ptr0);
                                                                          let l2 = *ptr0.add(0).cast::<*mut u8>();
                                                                          let l3 = *ptr0.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
                                                                          let base7 = l2;
                                                                          let len7 = l3;
                                                                          let mut result7 = _rt::Vec::with_capacity(len7);
                                                                          for i in 0..len7 {
                                                                            let base = base7.add(i * (2*::core::mem::size_of::<*const u8>()));
                                                                            let e7 = {
                                                                              let l4 = *base.add(0).cast::<*mut u8>();
                                                                              let l5 = *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
                                                                              let len6 = l5;
                                                                              let bytes6 = _rt::Vec::from_raw_parts(l4.cast(), len6, len6);

                                                                              _rt::string_lift(bytes6)
                                                                            };
                                                                            result7.push(e7);
                                                                          }
                                                                          _rt::cabi_dealloc(base7, len7 * (2*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>());
                                                                          let result8 = result7;
                                                                          result8
                                                                        }
                                                                      }
                                                                    }
                                                                    impl RecordGpuPipelineConstantValue {
                                                                      #[allow(unused_unsafe, clippy::all)]
                                                                      #[allow(async_fn_in_trait)]
                                                                      pub fn values(&self,) -> _rt::Vec::<GpuPipelineConstantValue>{
                                                                        unsafe {

                                                                          #[cfg_attr(target_pointer_width="64", repr(align(8)))]
                                                                          #[cfg_attr(target_pointer_width="32", repr(align(4)))]
                                                                          struct RetArea([::core::mem::MaybeUninit::<u8>; 2*::core::mem::size_of::<*const u8>()]);
                                                                          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2*::core::mem::size_of::<*const u8>()]);
                                                                          let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                                                                          #[cfg(target_arch = "wasm32")]
                                                                          #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                          unsafe extern "C" {
                                                                            #[link_name = "[method]record-gpu-pipeline-constant-value.values"]
                                                                            fn wit_import1(_: i32, _: *mut u8, );
                                                                          }

                                                                          #[cfg(not(target_arch = "wasm32"))]
                                                                          unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, ) { unreachable!() }
                                                                          wit_import1((self).handle() as i32, ptr0);
                                                                          let l2 = *ptr0.add(0).cast::<*mut u8>();
                                                                          let l3 = *ptr0.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
                                                                          let len4 = l3;
                                                                          let result5 = <_ as From<_rt::Vec<_>>>::from(_rt::Vec::from_raw_parts(l2.cast(), len4, len4));
                                                                          result5
                                                                        }
                                                                      }
                                                                    }
                                                                    impl RecordGpuPipelineConstantValue {
                                                                      #[allow(unused_unsafe, clippy::all)]
                                                                      #[allow(async_fn_in_trait)]
                                                                      pub fn entries(&self,) -> _rt::Vec::<(_rt::String,GpuPipelineConstantValue,)>{
                                                                        unsafe {

                                                                          #[cfg_attr(target_pointer_width="64", repr(align(8)))]
                                                                          #[cfg_attr(target_pointer_width="32", repr(align(4)))]
                                                                          struct RetArea([::core::mem::MaybeUninit::<u8>; 2*::core::mem::size_of::<*const u8>()]);
                                                                          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2*::core::mem::size_of::<*const u8>()]);
                                                                          let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                                                                          #[cfg(target_arch = "wasm32")]
                                                                          #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                          unsafe extern "C" {
                                                                            #[link_name = "[method]record-gpu-pipeline-constant-value.entries"]
                                                                            fn wit_import1(_: i32, _: *mut u8, );
                                                                          }

                                                                          #[cfg(not(target_arch = "wasm32"))]
                                                                          unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, ) { unreachable!() }
                                                                          wit_import1((self).handle() as i32, ptr0);
                                                                          let l2 = *ptr0.add(0).cast::<*mut u8>();
                                                                          let l3 = *ptr0.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
                                                                          let base8 = l2;
                                                                          let len8 = l3;
                                                                          let mut result8 = _rt::Vec::with_capacity(len8);
                                                                          for i in 0..len8 {
                                                                            let base = base8.add(i * (8+2*::core::mem::size_of::<*const u8>()));
                                                                            let e8 = {
                                                                              let l4 = *base.add(0).cast::<*mut u8>();
                                                                              let l5 = *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
                                                                              let len6 = l5;
                                                                              let bytes6 = _rt::Vec::from_raw_parts(l4.cast(), len6, len6);
                                                                              let l7 = *base.add(2*::core::mem::size_of::<*const u8>()).cast::<f64>();

                                                                              (_rt::string_lift(bytes6), l7)
                                                                            };
                                                                            result8.push(e8);
                                                                          }
                                                                          _rt::cabi_dealloc(base8, len8 * (8+2*::core::mem::size_of::<*const u8>()), 8);
                                                                          let result9 = result8;
                                                                          result9
                                                                        }
                                                                      }
                                                                    }
                                                                    impl GpuComputePipeline {
                                                                      #[allow(unused_unsafe, clippy::all)]
                                                                      #[allow(async_fn_in_trait)]
                                                                      pub fn label(&self,) -> _rt::String{
                                                                        unsafe {

                                                                          #[cfg_attr(target_pointer_width="64", repr(align(8)))]
                                                                          #[cfg_attr(target_pointer_width="32", repr(align(4)))]
                                                                          struct RetArea([::core::mem::MaybeUninit::<u8>; 2*::core::mem::size_of::<*const u8>()]);
                                                                          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2*::core::mem::size_of::<*const u8>()]);
                                                                          let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                                                                          #[cfg(target_arch = "wasm32")]
                                                                          #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                          unsafe extern "C" {
                                                                            #[link_name = "[method]gpu-compute-pipeline.label"]
                                                                            fn wit_import1(_: i32, _: *mut u8, );
                                                                          }

                                                                          #[cfg(not(target_arch = "wasm32"))]
                                                                          unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, ) { unreachable!() }
                                                                          wit_import1((self).handle() as i32, ptr0);
                                                                          let l2 = *ptr0.add(0).cast::<*mut u8>();
                                                                          let l3 = *ptr0.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
                                                                          let len4 = l3;
                                                                          let bytes4 = _rt::Vec::from_raw_parts(l2.cast(), len4, len4);
                                                                          let result5 = _rt::string_lift(bytes4);
                                                                          result5
                                                                        }
                                                                      }
                                                                    }
                                                                    impl GpuComputePipeline {
                                                                      #[allow(unused_unsafe, clippy::all)]
                                                                      #[allow(async_fn_in_trait)]
                                                                      pub fn set_label(&self,label: &str,) -> (){
                                                                        unsafe {
                                                                          let vec0 = label;
                                                                          let ptr0 = vec0.as_ptr().cast::<u8>();
                                                                          let len0 = vec0.len();

                                                                          #[cfg(target_arch = "wasm32")]
                                                                          #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                          unsafe extern "C" {
                                                                            #[link_name = "[method]gpu-compute-pipeline.set-label"]
                                                                            fn wit_import1(_: i32, _: *mut u8, _: usize, );
                                                                          }

                                                                          #[cfg(not(target_arch = "wasm32"))]
                                                                          unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, _: usize, ) { unreachable!() }
                                                                          wit_import1((self).handle() as i32, ptr0.cast_mut(), len0);
                                                                        }
                                                                      }
                                                                    }
                                                                    impl GpuComputePipeline {
                                                                      #[allow(unused_unsafe, clippy::all)]
                                                                      #[allow(async_fn_in_trait)]
                                                                      pub fn get_bind_group_layout(&self,index: u32,) -> GpuBindGroupLayout{
                                                                        unsafe {

                                                                          #[cfg(target_arch = "wasm32")]
                                                                          #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                          unsafe extern "C" {
                                                                            #[link_name = "[method]gpu-compute-pipeline.get-bind-group-layout"]
                                                                            fn wit_import0(_: i32, _: i32, ) -> i32;
                                                                          }

                                                                          #[cfg(not(target_arch = "wasm32"))]
                                                                          unsafe extern "C" fn wit_import0(_: i32, _: i32, ) -> i32 { unreachable!() }
                                                                          let ret = wit_import0((self).handle() as i32, _rt::as_i32(&index));
                                                                          GpuBindGroupLayout::from_handle(ret as u32)
                                                                        }
                                                                      }
                                                                    }
                                                                    impl GpuRenderPipeline {
                                                                      #[allow(unused_unsafe, clippy::all)]
                                                                      #[allow(async_fn_in_trait)]
                                                                      pub fn label(&self,) -> _rt::String{
                                                                        unsafe {

                                                                          #[cfg_attr(target_pointer_width="64", repr(align(8)))]
                                                                          #[cfg_attr(target_pointer_width="32", repr(align(4)))]
                                                                          struct RetArea([::core::mem::MaybeUninit::<u8>; 2*::core::mem::size_of::<*const u8>()]);
                                                                          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2*::core::mem::size_of::<*const u8>()]);
                                                                          let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                                                                          #[cfg(target_arch = "wasm32")]
                                                                          #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                          unsafe extern "C" {
                                                                            #[link_name = "[method]gpu-render-pipeline.label"]
                                                                            fn wit_import1(_: i32, _: *mut u8, );
                                                                          }

                                                                          #[cfg(not(target_arch = "wasm32"))]
                                                                          unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, ) { unreachable!() }
                                                                          wit_import1((self).handle() as i32, ptr0);
                                                                          let l2 = *ptr0.add(0).cast::<*mut u8>();
                                                                          let l3 = *ptr0.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
                                                                          let len4 = l3;
                                                                          let bytes4 = _rt::Vec::from_raw_parts(l2.cast(), len4, len4);
                                                                          let result5 = _rt::string_lift(bytes4);
                                                                          result5
                                                                        }
                                                                      }
                                                                    }
                                                                    impl GpuRenderPipeline {
                                                                      #[allow(unused_unsafe, clippy::all)]
                                                                      #[allow(async_fn_in_trait)]
                                                                      pub fn set_label(&self,label: &str,) -> (){
                                                                        unsafe {
                                                                          let vec0 = label;
                                                                          let ptr0 = vec0.as_ptr().cast::<u8>();
                                                                          let len0 = vec0.len();

                                                                          #[cfg(target_arch = "wasm32")]
                                                                          #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                          unsafe extern "C" {
                                                                            #[link_name = "[method]gpu-render-pipeline.set-label"]
                                                                            fn wit_import1(_: i32, _: *mut u8, _: usize, );
                                                                          }

                                                                          #[cfg(not(target_arch = "wasm32"))]
                                                                          unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, _: usize, ) { unreachable!() }
                                                                          wit_import1((self).handle() as i32, ptr0.cast_mut(), len0);
                                                                        }
                                                                      }
                                                                    }
                                                                    impl GpuRenderPipeline {
                                                                      #[allow(unused_unsafe, clippy::all)]
                                                                      #[allow(async_fn_in_trait)]
                                                                      pub fn get_bind_group_layout(&self,index: u32,) -> GpuBindGroupLayout{
                                                                        unsafe {

                                                                          #[cfg(target_arch = "wasm32")]
                                                                          #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                          unsafe extern "C" {
                                                                            #[link_name = "[method]gpu-render-pipeline.get-bind-group-layout"]
                                                                            fn wit_import0(_: i32, _: i32, ) -> i32;
                                                                          }

                                                                          #[cfg(not(target_arch = "wasm32"))]
                                                                          unsafe extern "C" fn wit_import0(_: i32, _: i32, ) -> i32 { unreachable!() }
                                                                          let ret = wit_import0((self).handle() as i32, _rt::as_i32(&index));
                                                                          GpuBindGroupLayout::from_handle(ret as u32)
                                                                        }
                                                                      }
                                                                    }
                                                                    impl GpuColorWrite {
                                                                      #[allow(unused_unsafe, clippy::all)]
                                                                      #[allow(async_fn_in_trait)]
                                                                      pub fn red() -> GpuFlagsConstant{
                                                                        unsafe {

                                                                          #[cfg(target_arch = "wasm32")]
                                                                          #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                          unsafe extern "C" {
                                                                            #[link_name = "[static]gpu-color-write.RED"]
                                                                            fn wit_import0() -> i32;
                                                                          }

                                                                          #[cfg(not(target_arch = "wasm32"))]
                                                                          unsafe extern "C" fn wit_import0() -> i32 { unreachable!() }
                                                                          let ret = wit_import0();
                                                                          ret as u32
                                                                        }
                                                                      }
                                                                    }
                                                                    impl GpuColorWrite {
                                                                      #[allow(unused_unsafe, clippy::all)]
                                                                      #[allow(async_fn_in_trait)]
                                                                      pub fn green() -> GpuFlagsConstant{
                                                                        unsafe {

                                                                          #[cfg(target_arch = "wasm32")]
                                                                          #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                          unsafe extern "C" {
                                                                            #[link_name = "[static]gpu-color-write.GREEN"]
                                                                            fn wit_import0() -> i32;
                                                                          }

                                                                          #[cfg(not(target_arch = "wasm32"))]
                                                                          unsafe extern "C" fn wit_import0() -> i32 { unreachable!() }
                                                                          let ret = wit_import0();
                                                                          ret as u32
                                                                        }
                                                                      }
                                                                    }
                                                                    impl GpuColorWrite {
                                                                      #[allow(unused_unsafe, clippy::all)]
                                                                      #[allow(async_fn_in_trait)]
                                                                      pub fn blue() -> GpuFlagsConstant{
                                                                        unsafe {

                                                                          #[cfg(target_arch = "wasm32")]
                                                                          #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                          unsafe extern "C" {
                                                                            #[link_name = "[static]gpu-color-write.BLUE"]
                                                                            fn wit_import0() -> i32;
                                                                          }

                                                                          #[cfg(not(target_arch = "wasm32"))]
                                                                          unsafe extern "C" fn wit_import0() -> i32 { unreachable!() }
                                                                          let ret = wit_import0();
                                                                          ret as u32
                                                                        }
                                                                      }
                                                                    }
                                                                    impl GpuColorWrite {
                                                                      #[allow(unused_unsafe, clippy::all)]
                                                                      #[allow(async_fn_in_trait)]
                                                                      pub fn alpha() -> GpuFlagsConstant{
                                                                        unsafe {

                                                                          #[cfg(target_arch = "wasm32")]
                                                                          #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                          unsafe extern "C" {
                                                                            #[link_name = "[static]gpu-color-write.ALPHA"]
                                                                            fn wit_import0() -> i32;
                                                                          }

                                                                          #[cfg(not(target_arch = "wasm32"))]
                                                                          unsafe extern "C" fn wit_import0() -> i32 { unreachable!() }
                                                                          let ret = wit_import0();
                                                                          ret as u32
                                                                        }
                                                                      }
                                                                    }
                                                                    impl GpuColorWrite {
                                                                      #[allow(unused_unsafe, clippy::all)]
                                                                      #[allow(async_fn_in_trait)]
                                                                      pub fn all() -> GpuFlagsConstant{
                                                                        unsafe {

                                                                          #[cfg(target_arch = "wasm32")]
                                                                          #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                          unsafe extern "C" {
                                                                            #[link_name = "[static]gpu-color-write.ALL"]
                                                                            fn wit_import0() -> i32;
                                                                          }

                                                                          #[cfg(not(target_arch = "wasm32"))]
                                                                          unsafe extern "C" fn wit_import0() -> i32 { unreachable!() }
                                                                          let ret = wit_import0();
                                                                          ret as u32
                                                                        }
                                                                      }
                                                                    }
                                                                    impl GpuCommandBuffer {
                                                                      #[allow(unused_unsafe, clippy::all)]
                                                                      #[allow(async_fn_in_trait)]
                                                                      pub fn label(&self,) -> _rt::String{
                                                                        unsafe {

                                                                          #[cfg_attr(target_pointer_width="64", repr(align(8)))]
                                                                          #[cfg_attr(target_pointer_width="32", repr(align(4)))]
                                                                          struct RetArea([::core::mem::MaybeUninit::<u8>; 2*::core::mem::size_of::<*const u8>()]);
                                                                          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2*::core::mem::size_of::<*const u8>()]);
                                                                          let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                                                                          #[cfg(target_arch = "wasm32")]
                                                                          #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                          unsafe extern "C" {
                                                                            #[link_name = "[method]gpu-command-buffer.label"]
                                                                            fn wit_import1(_: i32, _: *mut u8, );
                                                                          }

                                                                          #[cfg(not(target_arch = "wasm32"))]
                                                                          unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, ) { unreachable!() }
                                                                          wit_import1((self).handle() as i32, ptr0);
                                                                          let l2 = *ptr0.add(0).cast::<*mut u8>();
                                                                          let l3 = *ptr0.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
                                                                          let len4 = l3;
                                                                          let bytes4 = _rt::Vec::from_raw_parts(l2.cast(), len4, len4);
                                                                          let result5 = _rt::string_lift(bytes4);
                                                                          result5
                                                                        }
                                                                      }
                                                                    }
                                                                    impl GpuCommandBuffer {
                                                                      #[allow(unused_unsafe, clippy::all)]
                                                                      #[allow(async_fn_in_trait)]
                                                                      pub fn set_label(&self,label: &str,) -> (){
                                                                        unsafe {
                                                                          let vec0 = label;
                                                                          let ptr0 = vec0.as_ptr().cast::<u8>();
                                                                          let len0 = vec0.len();

                                                                          #[cfg(target_arch = "wasm32")]
                                                                          #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                          unsafe extern "C" {
                                                                            #[link_name = "[method]gpu-command-buffer.set-label"]
                                                                            fn wit_import1(_: i32, _: *mut u8, _: usize, );
                                                                          }

                                                                          #[cfg(not(target_arch = "wasm32"))]
                                                                          unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, _: usize, ) { unreachable!() }
                                                                          wit_import1((self).handle() as i32, ptr0.cast_mut(), len0);
                                                                        }
                                                                      }
                                                                    }
                                                                    impl GpuCommandEncoder {
                                                                      #[allow(unused_unsafe, clippy::all)]
                                                                      #[allow(async_fn_in_trait)]
                                                                      pub fn begin_render_pass(&self,descriptor: &GpuRenderPassDescriptor<'_,>,) -> GpuRenderPassEncoder{
                                                                        unsafe {

                                                                          #[repr(align(8))]
                                                                          struct RetArea([::core::mem::MaybeUninit::<u8>; 104+4*::core::mem::size_of::<*const u8>()]);
                                                                          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 104+4*::core::mem::size_of::<*const u8>()]);
                                                                          let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();*ptr0.add(0).cast::<i32>() = (self).handle() as i32;
                                                                          let GpuRenderPassDescriptor{ color_attachments:color_attachments1, depth_stencil_attachment:depth_stencil_attachment1, occlusion_query_set:occlusion_query_set1, timestamp_writes:timestamp_writes1, max_draw_count:max_draw_count1, label:label1, } = descriptor;
                                                                          let vec4 = color_attachments1;
                                                                          let len4 = vec4.len();
                                                                          let layout4 = _rt::alloc::Layout::from_size_align(vec4.len() * 80, 8).unwrap();
                                                                          let (result4, _cleanup4) = wit_bindgen::rt::Cleanup::new(layout4);for (i, e) in vec4.into_iter().enumerate() {
                                                                            let base = result4.add(i * 80);
                                                                            {
                                                                              match e {
                                                                                Some(e) => {
                                                                                  *base.add(0).cast::<u8>() = (1i32) as u8;
                                                                                  let GpuRenderPassColorAttachment{ view:view2, depth_slice:depth_slice2, resolve_target:resolve_target2, clear_value:clear_value2, load_op:load_op2, store_op:store_op2, } = e;
                                                                                  *base.add(8).cast::<i32>() = (view2).handle() as i32;
                                                                                  match depth_slice2 {
                                                                                    Some(e) => {
                                                                                      *base.add(12).cast::<u8>() = (1i32) as u8;
                                                                                      *base.add(16).cast::<i32>() = _rt::as_i32(e);
                                                                                    },
                                                                                    None => {
                                                                                      {
                                                                                        *base.add(12).cast::<u8>() = (0i32) as u8;
                                                                                      }
                                                                                    },
                                                                                  };match resolve_target2 {
                                                                                    Some(e) => {
                                                                                      *base.add(20).cast::<u8>() = (1i32) as u8;
                                                                                      *base.add(24).cast::<i32>() = (e).handle() as i32;
                                                                                    },
                                                                                    None => {
                                                                                      {
                                                                                        *base.add(20).cast::<u8>() = (0i32) as u8;
                                                                                      }
                                                                                    },
                                                                                  };match clear_value2 {
                                                                                    Some(e) => {
                                                                                      *base.add(32).cast::<u8>() = (1i32) as u8;
                                                                                      let GpuColor{ r:r3, g:g3, b:b3, a:a3, } = e;
                                                                                      *base.add(40).cast::<f64>() = _rt::as_f64(r3);
                                                                                      *base.add(48).cast::<f64>() = _rt::as_f64(g3);
                                                                                      *base.add(56).cast::<f64>() = _rt::as_f64(b3);
                                                                                      *base.add(64).cast::<f64>() = _rt::as_f64(a3);
                                                                                    },
                                                                                    None => {
                                                                                      {
                                                                                        *base.add(32).cast::<u8>() = (0i32) as u8;
                                                                                      }
                                                                                    },
                                                                                  };*base.add(72).cast::<u8>() = (load_op2.clone() as i32) as u8;
                                                                                  *base.add(73).cast::<u8>() = (store_op2.clone() as i32) as u8;
                                                                                },
                                                                                None => {
                                                                                  {
                                                                                    *base.add(0).cast::<u8>() = (0i32) as u8;
                                                                                  }
                                                                                },
                                                                              };}
                                                                            }
                                                                            *ptr0.add(8+1*::core::mem::size_of::<*const u8>()).cast::<usize>() = len4;
                                                                            *ptr0.add(8).cast::<*mut u8>() = result4;
                                                                            match depth_stencil_attachment1 {
                                                                              Some(e) => {
                                                                                *ptr0.add(8+2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                                                                let GpuRenderPassDepthStencilAttachment{ view:view5, depth_clear_value:depth_clear_value5, depth_load_op:depth_load_op5, depth_store_op:depth_store_op5, depth_read_only:depth_read_only5, stencil_clear_value:stencil_clear_value5, stencil_load_op:stencil_load_op5, stencil_store_op:stencil_store_op5, stencil_read_only:stencil_read_only5, } = e;
                                                                                *ptr0.add(12+2*::core::mem::size_of::<*const u8>()).cast::<i32>() = (view5).handle() as i32;
                                                                                match depth_clear_value5 {
                                                                                  Some(e) => {
                                                                                    *ptr0.add(16+2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                                                                    *ptr0.add(20+2*::core::mem::size_of::<*const u8>()).cast::<f32>() = _rt::as_f32(e);
                                                                                  },
                                                                                  None => {
                                                                                    {
                                                                                      *ptr0.add(16+2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                                                                    }
                                                                                  },
                                                                                };match depth_load_op5 {
                                                                                  Some(e) => {
                                                                                    *ptr0.add(24+2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                                                                    *ptr0.add(25+2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (e.clone() as i32) as u8;
                                                                                  },
                                                                                  None => {
                                                                                    {
                                                                                      *ptr0.add(24+2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                                                                    }
                                                                                  },
                                                                                };match depth_store_op5 {
                                                                                  Some(e) => {
                                                                                    *ptr0.add(26+2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                                                                    *ptr0.add(27+2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (e.clone() as i32) as u8;
                                                                                  },
                                                                                  None => {
                                                                                    {
                                                                                      *ptr0.add(26+2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                                                                    }
                                                                                  },
                                                                                };match depth_read_only5 {
                                                                                  Some(e) => {
                                                                                    *ptr0.add(28+2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                                                                    *ptr0.add(29+2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (match e { true => 1, false => 0 }) as u8;
                                                                                  },
                                                                                  None => {
                                                                                    {
                                                                                      *ptr0.add(28+2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                                                                    }
                                                                                  },
                                                                                };match stencil_clear_value5 {
                                                                                  Some(e) => {
                                                                                    *ptr0.add(32+2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                                                                    *ptr0.add(36+2*::core::mem::size_of::<*const u8>()).cast::<i32>() = _rt::as_i32(e);
                                                                                  },
                                                                                  None => {
                                                                                    {
                                                                                      *ptr0.add(32+2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                                                                    }
                                                                                  },
                                                                                };match stencil_load_op5 {
                                                                                  Some(e) => {
                                                                                    *ptr0.add(40+2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                                                                    *ptr0.add(41+2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (e.clone() as i32) as u8;
                                                                                  },
                                                                                  None => {
                                                                                    {
                                                                                      *ptr0.add(40+2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                                                                    }
                                                                                  },
                                                                                };match stencil_store_op5 {
                                                                                  Some(e) => {
                                                                                    *ptr0.add(42+2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                                                                    *ptr0.add(43+2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (e.clone() as i32) as u8;
                                                                                  },
                                                                                  None => {
                                                                                    {
                                                                                      *ptr0.add(42+2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                                                                    }
                                                                                  },
                                                                                };match stencil_read_only5 {
                                                                                  Some(e) => {
                                                                                    *ptr0.add(44+2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                                                                    *ptr0.add(45+2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (match e { true => 1, false => 0 }) as u8;
                                                                                  },
                                                                                  None => {
                                                                                    {
                                                                                      *ptr0.add(44+2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                                                                    }
                                                                                  },
                                                                                };},
                                                                                None => {
                                                                                  {
                                                                                    *ptr0.add(8+2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                                                                  }
                                                                                },
                                                                              };match occlusion_query_set1 {
                                                                                Some(e) => {
                                                                                  *ptr0.add(48+2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                                                                  *ptr0.add(52+2*::core::mem::size_of::<*const u8>()).cast::<i32>() = (e).handle() as i32;
                                                                                },
                                                                                None => {
                                                                                  {
                                                                                    *ptr0.add(48+2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                                                                  }
                                                                                },
                                                                              };match timestamp_writes1 {
                                                                                Some(e) => {
                                                                                  *ptr0.add(56+2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                                                                  let GpuRenderPassTimestampWrites{ query_set:query_set6, beginning_of_pass_write_index:beginning_of_pass_write_index6, end_of_pass_write_index:end_of_pass_write_index6, } = e;
                                                                                  *ptr0.add(60+2*::core::mem::size_of::<*const u8>()).cast::<i32>() = (query_set6).handle() as i32;
                                                                                  match beginning_of_pass_write_index6 {
                                                                                    Some(e) => {
                                                                                      *ptr0.add(64+2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                                                                      *ptr0.add(68+2*::core::mem::size_of::<*const u8>()).cast::<i32>() = _rt::as_i32(e);
                                                                                    },
                                                                                    None => {
                                                                                      {
                                                                                        *ptr0.add(64+2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                                                                      }
                                                                                    },
                                                                                  };match end_of_pass_write_index6 {
                                                                                    Some(e) => {
                                                                                      *ptr0.add(72+2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                                                                      *ptr0.add(76+2*::core::mem::size_of::<*const u8>()).cast::<i32>() = _rt::as_i32(e);
                                                                                    },
                                                                                    None => {
                                                                                      {
                                                                                        *ptr0.add(72+2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                                                                      }
                                                                                    },
                                                                                  };},
                                                                                  None => {
                                                                                    {
                                                                                      *ptr0.add(56+2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                                                                    }
                                                                                  },
                                                                                };match max_draw_count1 {
                                                                                  Some(e) => {
                                                                                    *ptr0.add(80+2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                                                                    *ptr0.add(88+2*::core::mem::size_of::<*const u8>()).cast::<i64>() = _rt::as_i64(e);
                                                                                  },
                                                                                  None => {
                                                                                    {
                                                                                      *ptr0.add(80+2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                                                                    }
                                                                                  },
                                                                                };match label1 {
                                                                                  Some(e) => {
                                                                                    *ptr0.add(96+2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                                                                    let vec7 = e;
                                                                                    let ptr7 = vec7.as_ptr().cast::<u8>();
                                                                                    let len7 = vec7.len();
                                                                                    *ptr0.add(96+4*::core::mem::size_of::<*const u8>()).cast::<usize>() = len7;
                                                                                    *ptr0.add(96+3*::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr7.cast_mut();
                                                                                  },
                                                                                  None => {
                                                                                    {
                                                                                      *ptr0.add(96+2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                                                                    }
                                                                                  },
                                                                                };
                                                                                #[cfg(target_arch = "wasm32")]
                                                                                #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                                unsafe extern "C" {
                                                                                  #[link_name = "[method]gpu-command-encoder.begin-render-pass"]
                                                                                  fn wit_import8(_: *mut u8, ) -> i32;
                                                                                }

                                                                                #[cfg(not(target_arch = "wasm32"))]
                                                                                unsafe extern "C" fn wit_import8(_: *mut u8, ) -> i32 { unreachable!() }
                                                                                let ret = wit_import8(ptr0);
                                                                                GpuRenderPassEncoder::from_handle(ret as u32)
                                                                              }
                                                                            }
                                                                          }
                                                                          impl GpuCommandEncoder {
                                                                            #[allow(unused_unsafe, clippy::all)]
                                                                            #[allow(async_fn_in_trait)]
                                                                            pub fn begin_compute_pass(&self,descriptor: Option<&GpuComputePassDescriptor<'_,>>,) -> GpuComputePassEncoder{
                                                                              unsafe {
                                                                                let (result7_0,result7_1,result7_2,result7_3,result7_4,result7_5,result7_6,result7_7,result7_8,result7_9,) = match descriptor {
                                                                                  Some(e) => {
                                                                                    let GpuComputePassDescriptor{ timestamp_writes:timestamp_writes0, label:label0, } = e;
                                                                                    let (result4_0,result4_1,result4_2,result4_3,result4_4,result4_5,) = match timestamp_writes0 {
                                                                                      Some(e) => {
                                                                                        let GpuComputePassTimestampWrites{ query_set:query_set1, beginning_of_pass_write_index:beginning_of_pass_write_index1, end_of_pass_write_index:end_of_pass_write_index1, } = e;
                                                                                        let (result2_0,result2_1,) = match beginning_of_pass_write_index1 {
                                                                                          Some(e) => (1i32, _rt::as_i32(e)),
                                                                                          None => {
                                                                                            (0i32, 0i32)
                                                                                          },
                                                                                        };let (result3_0,result3_1,) = match end_of_pass_write_index1 {
                                                                                          Some(e) => (1i32, _rt::as_i32(e)),
                                                                                          None => {
                                                                                            (0i32, 0i32)
                                                                                          },
                                                                                        };
                                                                                        (1i32, (query_set1).handle() as i32, result2_0, result2_1, result3_0, result3_1)
                                                                                      },
                                                                                      None => {
                                                                                        (0i32, 0i32, 0i32, 0i32, 0i32, 0i32)
                                                                                      },
                                                                                    };let (result6_0,result6_1,result6_2,) = match label0 {
                                                                                      Some(e) => {
                                                                                        let vec5 = e;
                                                                                        let ptr5 = vec5.as_ptr().cast::<u8>();
                                                                                        let len5 = vec5.len();

                                                                                        (1i32, ptr5.cast_mut(), len5)
                                                                                      },
                                                                                      None => {
                                                                                        (0i32, ::core::ptr::null_mut(), 0usize)
                                                                                      },
                                                                                    };
                                                                                    (1i32, result4_0, result4_1, result4_2, result4_3, result4_4, result4_5, result6_0, result6_1, result6_2)
                                                                                  },
                                                                                  None => {
                                                                                    (0i32, 0i32, 0i32, 0i32, 0i32, 0i32, 0i32, 0i32, ::core::ptr::null_mut(), 0usize)
                                                                                  },
                                                                                };
                                                                                #[cfg(target_arch = "wasm32")]
                                                                                #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                                unsafe extern "C" {
                                                                                  #[link_name = "[method]gpu-command-encoder.begin-compute-pass"]
                                                                                  fn wit_import8(_: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: *mut u8, _: usize, ) -> i32;
                                                                                }

                                                                                #[cfg(not(target_arch = "wasm32"))]
                                                                                unsafe extern "C" fn wit_import8(_: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: *mut u8, _: usize, ) -> i32 { unreachable!() }
                                                                                let ret = wit_import8((self).handle() as i32, result7_0, result7_1, result7_2, result7_3, result7_4, result7_5, result7_6, result7_7, result7_8, result7_9);
                                                                                GpuComputePassEncoder::from_handle(ret as u32)
                                                                              }
                                                                            }
                                                                          }
                                                                          impl GpuCommandEncoder {
                                                                            #[allow(unused_unsafe, clippy::all)]
                                                                            #[allow(async_fn_in_trait)]
                                                                            pub fn copy_buffer_to_buffer(&self,source: &GpuBuffer,source_offset: GpuSize64,destination: &GpuBuffer,destination_offset: GpuSize64,size: GpuSize64,) -> (){
                                                                              unsafe {

                                                                                #[cfg(target_arch = "wasm32")]
                                                                                #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                                unsafe extern "C" {
                                                                                  #[link_name = "[method]gpu-command-encoder.copy-buffer-to-buffer"]
                                                                                  fn wit_import0(_: i32, _: i32, _: i64, _: i32, _: i64, _: i64, );
                                                                                }

                                                                                #[cfg(not(target_arch = "wasm32"))]
                                                                                unsafe extern "C" fn wit_import0(_: i32, _: i32, _: i64, _: i32, _: i64, _: i64, ) { unreachable!() }
                                                                                wit_import0((self).handle() as i32, (source).handle() as i32, _rt::as_i64(source_offset), (destination).handle() as i32, _rt::as_i64(destination_offset), _rt::as_i64(size));
                                                                              }
                                                                            }
                                                                          }
                                                                          impl GpuCommandEncoder {
                                                                            #[allow(unused_unsafe, clippy::all)]
                                                                            #[allow(async_fn_in_trait)]
                                                                            pub fn copy_buffer_to_texture(&self,source: &GpuTexelCopyBufferInfo<'_,>,destination: &GpuTexelCopyTextureInfo<'_,>,copy_size: GpuExtent3D,) -> (){
                                                                              unsafe {

                                                                                #[repr(align(8))]
                                                                                struct RetArea([::core::mem::MaybeUninit::<u8>; 112]);
                                                                                let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 112]);
                                                                                let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();*ptr0.add(0).cast::<i32>() = (self).handle() as i32;
                                                                                let GpuTexelCopyBufferInfo{ buffer:buffer1, offset:offset1, bytes_per_row:bytes_per_row1, rows_per_image:rows_per_image1, } = source;
                                                                                *ptr0.add(8).cast::<i32>() = (buffer1).handle() as i32;
                                                                                match offset1 {
                                                                                  Some(e) => {
                                                                                    *ptr0.add(16).cast::<u8>() = (1i32) as u8;
                                                                                    *ptr0.add(24).cast::<i64>() = _rt::as_i64(e);
                                                                                  },
                                                                                  None => {
                                                                                    {
                                                                                      *ptr0.add(16).cast::<u8>() = (0i32) as u8;
                                                                                    }
                                                                                  },
                                                                                };match bytes_per_row1 {
                                                                                  Some(e) => {
                                                                                    *ptr0.add(32).cast::<u8>() = (1i32) as u8;
                                                                                    *ptr0.add(36).cast::<i32>() = _rt::as_i32(e);
                                                                                  },
                                                                                  None => {
                                                                                    {
                                                                                      *ptr0.add(32).cast::<u8>() = (0i32) as u8;
                                                                                    }
                                                                                  },
                                                                                };match rows_per_image1 {
                                                                                  Some(e) => {
                                                                                    *ptr0.add(40).cast::<u8>() = (1i32) as u8;
                                                                                    *ptr0.add(44).cast::<i32>() = _rt::as_i32(e);
                                                                                  },
                                                                                  None => {
                                                                                    {
                                                                                      *ptr0.add(40).cast::<u8>() = (0i32) as u8;
                                                                                    }
                                                                                  },
                                                                                };let GpuTexelCopyTextureInfo{ texture:texture2, mip_level:mip_level2, origin:origin2, aspect:aspect2, } = destination;
                                                                                *ptr0.add(48).cast::<i32>() = (texture2).handle() as i32;
                                                                                match mip_level2 {
                                                                                  Some(e) => {
                                                                                    *ptr0.add(52).cast::<u8>() = (1i32) as u8;
                                                                                    *ptr0.add(56).cast::<i32>() = _rt::as_i32(e);
                                                                                  },
                                                                                  None => {
                                                                                    {
                                                                                      *ptr0.add(52).cast::<u8>() = (0i32) as u8;
                                                                                    }
                                                                                  },
                                                                                };match origin2 {
                                                                                  Some(e) => {
                                                                                    *ptr0.add(60).cast::<u8>() = (1i32) as u8;
                                                                                    let GpuOrigin3D{ x:x3, y:y3, z:z3, } = e;
                                                                                    match x3 {
                                                                                      Some(e) => {
                                                                                        *ptr0.add(64).cast::<u8>() = (1i32) as u8;
                                                                                        *ptr0.add(68).cast::<i32>() = _rt::as_i32(e);
                                                                                      },
                                                                                      None => {
                                                                                        {
                                                                                          *ptr0.add(64).cast::<u8>() = (0i32) as u8;
                                                                                        }
                                                                                      },
                                                                                    };match y3 {
                                                                                      Some(e) => {
                                                                                        *ptr0.add(72).cast::<u8>() = (1i32) as u8;
                                                                                        *ptr0.add(76).cast::<i32>() = _rt::as_i32(e);
                                                                                      },
                                                                                      None => {
                                                                                        {
                                                                                          *ptr0.add(72).cast::<u8>() = (0i32) as u8;
                                                                                        }
                                                                                      },
                                                                                    };match z3 {
                                                                                      Some(e) => {
                                                                                        *ptr0.add(80).cast::<u8>() = (1i32) as u8;
                                                                                        *ptr0.add(84).cast::<i32>() = _rt::as_i32(e);
                                                                                      },
                                                                                      None => {
                                                                                        {
                                                                                          *ptr0.add(80).cast::<u8>() = (0i32) as u8;
                                                                                        }
                                                                                      },
                                                                                    };},
                                                                                    None => {
                                                                                      {
                                                                                        *ptr0.add(60).cast::<u8>() = (0i32) as u8;
                                                                                      }
                                                                                    },
                                                                                  };match aspect2 {
                                                                                    Some(e) => {
                                                                                      *ptr0.add(88).cast::<u8>() = (1i32) as u8;
                                                                                      *ptr0.add(89).cast::<u8>() = (e.clone() as i32) as u8;
                                                                                    },
                                                                                    None => {
                                                                                      {
                                                                                        *ptr0.add(88).cast::<u8>() = (0i32) as u8;
                                                                                      }
                                                                                    },
                                                                                  };let GpuExtent3D{ width:width4, height:height4, depth_or_array_layers:depth_or_array_layers4, } = copy_size;
                                                                                  *ptr0.add(92).cast::<i32>() = _rt::as_i32(width4);
                                                                                  match height4 {
                                                                                    Some(e) => {
                                                                                      *ptr0.add(96).cast::<u8>() = (1i32) as u8;
                                                                                      *ptr0.add(100).cast::<i32>() = _rt::as_i32(e);
                                                                                    },
                                                                                    None => {
                                                                                      {
                                                                                        *ptr0.add(96).cast::<u8>() = (0i32) as u8;
                                                                                      }
                                                                                    },
                                                                                  };match depth_or_array_layers4 {
                                                                                    Some(e) => {
                                                                                      *ptr0.add(104).cast::<u8>() = (1i32) as u8;
                                                                                      *ptr0.add(108).cast::<i32>() = _rt::as_i32(e);
                                                                                    },
                                                                                    None => {
                                                                                      {
                                                                                        *ptr0.add(104).cast::<u8>() = (0i32) as u8;
                                                                                      }
                                                                                    },
                                                                                  };
                                                                                  #[cfg(target_arch = "wasm32")]
                                                                                  #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                                  unsafe extern "C" {
                                                                                    #[link_name = "[method]gpu-command-encoder.copy-buffer-to-texture"]
                                                                                    fn wit_import5(_: *mut u8, );
                                                                                  }

                                                                                  #[cfg(not(target_arch = "wasm32"))]
                                                                                  unsafe extern "C" fn wit_import5(_: *mut u8, ) { unreachable!() }
                                                                                  wit_import5(ptr0);
                                                                                }
                                                                              }
                                                                            }
                                                                            impl GpuCommandEncoder {
                                                                              #[allow(unused_unsafe, clippy::all)]
                                                                              #[allow(async_fn_in_trait)]
                                                                              pub fn copy_texture_to_buffer(&self,source: &GpuTexelCopyTextureInfo<'_,>,destination: &GpuTexelCopyBufferInfo<'_,>,copy_size: GpuExtent3D,) -> (){
                                                                                unsafe {

                                                                                  #[repr(align(8))]
                                                                                  struct RetArea([::core::mem::MaybeUninit::<u8>; 112]);
                                                                                  let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 112]);
                                                                                  let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();*ptr0.add(0).cast::<i32>() = (self).handle() as i32;
                                                                                  let GpuTexelCopyTextureInfo{ texture:texture1, mip_level:mip_level1, origin:origin1, aspect:aspect1, } = source;
                                                                                  *ptr0.add(4).cast::<i32>() = (texture1).handle() as i32;
                                                                                  match mip_level1 {
                                                                                    Some(e) => {
                                                                                      *ptr0.add(8).cast::<u8>() = (1i32) as u8;
                                                                                      *ptr0.add(12).cast::<i32>() = _rt::as_i32(e);
                                                                                    },
                                                                                    None => {
                                                                                      {
                                                                                        *ptr0.add(8).cast::<u8>() = (0i32) as u8;
                                                                                      }
                                                                                    },
                                                                                  };match origin1 {
                                                                                    Some(e) => {
                                                                                      *ptr0.add(16).cast::<u8>() = (1i32) as u8;
                                                                                      let GpuOrigin3D{ x:x2, y:y2, z:z2, } = e;
                                                                                      match x2 {
                                                                                        Some(e) => {
                                                                                          *ptr0.add(20).cast::<u8>() = (1i32) as u8;
                                                                                          *ptr0.add(24).cast::<i32>() = _rt::as_i32(e);
                                                                                        },
                                                                                        None => {
                                                                                          {
                                                                                            *ptr0.add(20).cast::<u8>() = (0i32) as u8;
                                                                                          }
                                                                                        },
                                                                                      };match y2 {
                                                                                        Some(e) => {
                                                                                          *ptr0.add(28).cast::<u8>() = (1i32) as u8;
                                                                                          *ptr0.add(32).cast::<i32>() = _rt::as_i32(e);
                                                                                        },
                                                                                        None => {
                                                                                          {
                                                                                            *ptr0.add(28).cast::<u8>() = (0i32) as u8;
                                                                                          }
                                                                                        },
                                                                                      };match z2 {
                                                                                        Some(e) => {
                                                                                          *ptr0.add(36).cast::<u8>() = (1i32) as u8;
                                                                                          *ptr0.add(40).cast::<i32>() = _rt::as_i32(e);
                                                                                        },
                                                                                        None => {
                                                                                          {
                                                                                            *ptr0.add(36).cast::<u8>() = (0i32) as u8;
                                                                                          }
                                                                                        },
                                                                                      };},
                                                                                      None => {
                                                                                        {
                                                                                          *ptr0.add(16).cast::<u8>() = (0i32) as u8;
                                                                                        }
                                                                                      },
                                                                                    };match aspect1 {
                                                                                      Some(e) => {
                                                                                        *ptr0.add(44).cast::<u8>() = (1i32) as u8;
                                                                                        *ptr0.add(45).cast::<u8>() = (e.clone() as i32) as u8;
                                                                                      },
                                                                                      None => {
                                                                                        {
                                                                                          *ptr0.add(44).cast::<u8>() = (0i32) as u8;
                                                                                        }
                                                                                      },
                                                                                    };let GpuTexelCopyBufferInfo{ buffer:buffer3, offset:offset3, bytes_per_row:bytes_per_row3, rows_per_image:rows_per_image3, } = destination;
                                                                                    *ptr0.add(48).cast::<i32>() = (buffer3).handle() as i32;
                                                                                    match offset3 {
                                                                                      Some(e) => {
                                                                                        *ptr0.add(56).cast::<u8>() = (1i32) as u8;
                                                                                        *ptr0.add(64).cast::<i64>() = _rt::as_i64(e);
                                                                                      },
                                                                                      None => {
                                                                                        {
                                                                                          *ptr0.add(56).cast::<u8>() = (0i32) as u8;
                                                                                        }
                                                                                      },
                                                                                    };match bytes_per_row3 {
                                                                                      Some(e) => {
                                                                                        *ptr0.add(72).cast::<u8>() = (1i32) as u8;
                                                                                        *ptr0.add(76).cast::<i32>() = _rt::as_i32(e);
                                                                                      },
                                                                                      None => {
                                                                                        {
                                                                                          *ptr0.add(72).cast::<u8>() = (0i32) as u8;
                                                                                        }
                                                                                      },
                                                                                    };match rows_per_image3 {
                                                                                      Some(e) => {
                                                                                        *ptr0.add(80).cast::<u8>() = (1i32) as u8;
                                                                                        *ptr0.add(84).cast::<i32>() = _rt::as_i32(e);
                                                                                      },
                                                                                      None => {
                                                                                        {
                                                                                          *ptr0.add(80).cast::<u8>() = (0i32) as u8;
                                                                                        }
                                                                                      },
                                                                                    };let GpuExtent3D{ width:width4, height:height4, depth_or_array_layers:depth_or_array_layers4, } = copy_size;
                                                                                    *ptr0.add(88).cast::<i32>() = _rt::as_i32(width4);
                                                                                    match height4 {
                                                                                      Some(e) => {
                                                                                        *ptr0.add(92).cast::<u8>() = (1i32) as u8;
                                                                                        *ptr0.add(96).cast::<i32>() = _rt::as_i32(e);
                                                                                      },
                                                                                      None => {
                                                                                        {
                                                                                          *ptr0.add(92).cast::<u8>() = (0i32) as u8;
                                                                                        }
                                                                                      },
                                                                                    };match depth_or_array_layers4 {
                                                                                      Some(e) => {
                                                                                        *ptr0.add(100).cast::<u8>() = (1i32) as u8;
                                                                                        *ptr0.add(104).cast::<i32>() = _rt::as_i32(e);
                                                                                      },
                                                                                      None => {
                                                                                        {
                                                                                          *ptr0.add(100).cast::<u8>() = (0i32) as u8;
                                                                                        }
                                                                                      },
                                                                                    };
                                                                                    #[cfg(target_arch = "wasm32")]
                                                                                    #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                                    unsafe extern "C" {
                                                                                      #[link_name = "[method]gpu-command-encoder.copy-texture-to-buffer"]
                                                                                      fn wit_import5(_: *mut u8, );
                                                                                    }

                                                                                    #[cfg(not(target_arch = "wasm32"))]
                                                                                    unsafe extern "C" fn wit_import5(_: *mut u8, ) { unreachable!() }
                                                                                    wit_import5(ptr0);
                                                                                  }
                                                                                }
                                                                              }
                                                                              impl GpuCommandEncoder {
                                                                                #[allow(unused_unsafe, clippy::all)]
                                                                                #[allow(async_fn_in_trait)]
                                                                                pub fn copy_texture_to_texture(&self,source: &GpuTexelCopyTextureInfo<'_,>,destination: &GpuTexelCopyTextureInfo<'_,>,copy_size: GpuExtent3D,) -> (){
                                                                                  unsafe {

                                                                                    #[repr(align(4))]
                                                                                    struct RetArea([::core::mem::MaybeUninit::<u8>; 112]);
                                                                                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 112]);
                                                                                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();*ptr0.add(0).cast::<i32>() = (self).handle() as i32;
                                                                                    let GpuTexelCopyTextureInfo{ texture:texture1, mip_level:mip_level1, origin:origin1, aspect:aspect1, } = source;
                                                                                    *ptr0.add(4).cast::<i32>() = (texture1).handle() as i32;
                                                                                    match mip_level1 {
                                                                                      Some(e) => {
                                                                                        *ptr0.add(8).cast::<u8>() = (1i32) as u8;
                                                                                        *ptr0.add(12).cast::<i32>() = _rt::as_i32(e);
                                                                                      },
                                                                                      None => {
                                                                                        {
                                                                                          *ptr0.add(8).cast::<u8>() = (0i32) as u8;
                                                                                        }
                                                                                      },
                                                                                    };match origin1 {
                                                                                      Some(e) => {
                                                                                        *ptr0.add(16).cast::<u8>() = (1i32) as u8;
                                                                                        let GpuOrigin3D{ x:x2, y:y2, z:z2, } = e;
                                                                                        match x2 {
                                                                                          Some(e) => {
                                                                                            *ptr0.add(20).cast::<u8>() = (1i32) as u8;
                                                                                            *ptr0.add(24).cast::<i32>() = _rt::as_i32(e);
                                                                                          },
                                                                                          None => {
                                                                                            {
                                                                                              *ptr0.add(20).cast::<u8>() = (0i32) as u8;
                                                                                            }
                                                                                          },
                                                                                        };match y2 {
                                                                                          Some(e) => {
                                                                                            *ptr0.add(28).cast::<u8>() = (1i32) as u8;
                                                                                            *ptr0.add(32).cast::<i32>() = _rt::as_i32(e);
                                                                                          },
                                                                                          None => {
                                                                                            {
                                                                                              *ptr0.add(28).cast::<u8>() = (0i32) as u8;
                                                                                            }
                                                                                          },
                                                                                        };match z2 {
                                                                                          Some(e) => {
                                                                                            *ptr0.add(36).cast::<u8>() = (1i32) as u8;
                                                                                            *ptr0.add(40).cast::<i32>() = _rt::as_i32(e);
                                                                                          },
                                                                                          None => {
                                                                                            {
                                                                                              *ptr0.add(36).cast::<u8>() = (0i32) as u8;
                                                                                            }
                                                                                          },
                                                                                        };},
                                                                                        None => {
                                                                                          {
                                                                                            *ptr0.add(16).cast::<u8>() = (0i32) as u8;
                                                                                          }
                                                                                        },
                                                                                      };match aspect1 {
                                                                                        Some(e) => {
                                                                                          *ptr0.add(44).cast::<u8>() = (1i32) as u8;
                                                                                          *ptr0.add(45).cast::<u8>() = (e.clone() as i32) as u8;
                                                                                        },
                                                                                        None => {
                                                                                          {
                                                                                            *ptr0.add(44).cast::<u8>() = (0i32) as u8;
                                                                                          }
                                                                                        },
                                                                                      };let GpuTexelCopyTextureInfo{ texture:texture3, mip_level:mip_level3, origin:origin3, aspect:aspect3, } = destination;
                                                                                      *ptr0.add(48).cast::<i32>() = (texture3).handle() as i32;
                                                                                      match mip_level3 {
                                                                                        Some(e) => {
                                                                                          *ptr0.add(52).cast::<u8>() = (1i32) as u8;
                                                                                          *ptr0.add(56).cast::<i32>() = _rt::as_i32(e);
                                                                                        },
                                                                                        None => {
                                                                                          {
                                                                                            *ptr0.add(52).cast::<u8>() = (0i32) as u8;
                                                                                          }
                                                                                        },
                                                                                      };match origin3 {
                                                                                        Some(e) => {
                                                                                          *ptr0.add(60).cast::<u8>() = (1i32) as u8;
                                                                                          let GpuOrigin3D{ x:x4, y:y4, z:z4, } = e;
                                                                                          match x4 {
                                                                                            Some(e) => {
                                                                                              *ptr0.add(64).cast::<u8>() = (1i32) as u8;
                                                                                              *ptr0.add(68).cast::<i32>() = _rt::as_i32(e);
                                                                                            },
                                                                                            None => {
                                                                                              {
                                                                                                *ptr0.add(64).cast::<u8>() = (0i32) as u8;
                                                                                              }
                                                                                            },
                                                                                          };match y4 {
                                                                                            Some(e) => {
                                                                                              *ptr0.add(72).cast::<u8>() = (1i32) as u8;
                                                                                              *ptr0.add(76).cast::<i32>() = _rt::as_i32(e);
                                                                                            },
                                                                                            None => {
                                                                                              {
                                                                                                *ptr0.add(72).cast::<u8>() = (0i32) as u8;
                                                                                              }
                                                                                            },
                                                                                          };match z4 {
                                                                                            Some(e) => {
                                                                                              *ptr0.add(80).cast::<u8>() = (1i32) as u8;
                                                                                              *ptr0.add(84).cast::<i32>() = _rt::as_i32(e);
                                                                                            },
                                                                                            None => {
                                                                                              {
                                                                                                *ptr0.add(80).cast::<u8>() = (0i32) as u8;
                                                                                              }
                                                                                            },
                                                                                          };},
                                                                                          None => {
                                                                                            {
                                                                                              *ptr0.add(60).cast::<u8>() = (0i32) as u8;
                                                                                            }
                                                                                          },
                                                                                        };match aspect3 {
                                                                                          Some(e) => {
                                                                                            *ptr0.add(88).cast::<u8>() = (1i32) as u8;
                                                                                            *ptr0.add(89).cast::<u8>() = (e.clone() as i32) as u8;
                                                                                          },
                                                                                          None => {
                                                                                            {
                                                                                              *ptr0.add(88).cast::<u8>() = (0i32) as u8;
                                                                                            }
                                                                                          },
                                                                                        };let GpuExtent3D{ width:width5, height:height5, depth_or_array_layers:depth_or_array_layers5, } = copy_size;
                                                                                        *ptr0.add(92).cast::<i32>() = _rt::as_i32(width5);
                                                                                        match height5 {
                                                                                          Some(e) => {
                                                                                            *ptr0.add(96).cast::<u8>() = (1i32) as u8;
                                                                                            *ptr0.add(100).cast::<i32>() = _rt::as_i32(e);
                                                                                          },
                                                                                          None => {
                                                                                            {
                                                                                              *ptr0.add(96).cast::<u8>() = (0i32) as u8;
                                                                                            }
                                                                                          },
                                                                                        };match depth_or_array_layers5 {
                                                                                          Some(e) => {
                                                                                            *ptr0.add(104).cast::<u8>() = (1i32) as u8;
                                                                                            *ptr0.add(108).cast::<i32>() = _rt::as_i32(e);
                                                                                          },
                                                                                          None => {
                                                                                            {
                                                                                              *ptr0.add(104).cast::<u8>() = (0i32) as u8;
                                                                                            }
                                                                                          },
                                                                                        };
                                                                                        #[cfg(target_arch = "wasm32")]
                                                                                        #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                                        unsafe extern "C" {
                                                                                          #[link_name = "[method]gpu-command-encoder.copy-texture-to-texture"]
                                                                                          fn wit_import6(_: *mut u8, );
                                                                                        }

                                                                                        #[cfg(not(target_arch = "wasm32"))]
                                                                                        unsafe extern "C" fn wit_import6(_: *mut u8, ) { unreachable!() }
                                                                                        wit_import6(ptr0);
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                  impl GpuCommandEncoder {
                                                                                    #[allow(unused_unsafe, clippy::all)]
                                                                                    #[allow(async_fn_in_trait)]
                                                                                    pub fn clear_buffer(&self,buffer: &GpuBuffer,offset: Option<GpuSize64>,size: Option<GpuSize64>,) -> (){
                                                                                      unsafe {
                                                                                        let (result0_0,result0_1,) = match offset {
                                                                                          Some(e) => (1i32, _rt::as_i64(e)),
                                                                                          None => {
                                                                                            (0i32, 0i64)
                                                                                          },
                                                                                        };let (result1_0,result1_1,) = match size {
                                                                                          Some(e) => (1i32, _rt::as_i64(e)),
                                                                                          None => {
                                                                                            (0i32, 0i64)
                                                                                          },
                                                                                        };
                                                                                        #[cfg(target_arch = "wasm32")]
                                                                                        #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                                        unsafe extern "C" {
                                                                                          #[link_name = "[method]gpu-command-encoder.clear-buffer"]
                                                                                          fn wit_import2(_: i32, _: i32, _: i32, _: i64, _: i32, _: i64, );
                                                                                        }

                                                                                        #[cfg(not(target_arch = "wasm32"))]
                                                                                        unsafe extern "C" fn wit_import2(_: i32, _: i32, _: i32, _: i64, _: i32, _: i64, ) { unreachable!() }
                                                                                        wit_import2((self).handle() as i32, (buffer).handle() as i32, result0_0, result0_1, result1_0, result1_1);
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                  impl GpuCommandEncoder {
                                                                                    #[allow(unused_unsafe, clippy::all)]
                                                                                    #[allow(async_fn_in_trait)]
                                                                                    pub fn resolve_query_set(&self,query_set: &GpuQuerySet,first_query: GpuSize32,query_count: GpuSize32,destination: &GpuBuffer,destination_offset: GpuSize64,) -> (){
                                                                                      unsafe {

                                                                                        #[cfg(target_arch = "wasm32")]
                                                                                        #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                                        unsafe extern "C" {
                                                                                          #[link_name = "[method]gpu-command-encoder.resolve-query-set"]
                                                                                          fn wit_import0(_: i32, _: i32, _: i32, _: i32, _: i32, _: i64, );
                                                                                        }

                                                                                        #[cfg(not(target_arch = "wasm32"))]
                                                                                        unsafe extern "C" fn wit_import0(_: i32, _: i32, _: i32, _: i32, _: i32, _: i64, ) { unreachable!() }
                                                                                        wit_import0((self).handle() as i32, (query_set).handle() as i32, _rt::as_i32(first_query), _rt::as_i32(query_count), (destination).handle() as i32, _rt::as_i64(destination_offset));
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                  impl GpuCommandEncoder {
                                                                                    #[allow(unused_unsafe, clippy::all)]
                                                                                    #[allow(async_fn_in_trait)]
                                                                                    pub fn finish(&self,descriptor: Option<&GpuCommandBufferDescriptor>,) -> GpuCommandBuffer{
                                                                                      unsafe {
                                                                                        let (result3_0,result3_1,result3_2,result3_3,) = match descriptor {
                                                                                          Some(e) => {
                                                                                            let GpuCommandBufferDescriptor{ label:label0, } = e;
                                                                                            let (result2_0,result2_1,result2_2,) = match label0 {
                                                                                              Some(e) => {
                                                                                                let vec1 = e;
                                                                                                let ptr1 = vec1.as_ptr().cast::<u8>();
                                                                                                let len1 = vec1.len();

                                                                                                (1i32, ptr1.cast_mut(), len1)
                                                                                              },
                                                                                              None => {
                                                                                                (0i32, ::core::ptr::null_mut(), 0usize)
                                                                                              },
                                                                                            };
                                                                                            (1i32, result2_0, result2_1, result2_2)
                                                                                          },
                                                                                          None => {
                                                                                            (0i32, 0i32, ::core::ptr::null_mut(), 0usize)
                                                                                          },
                                                                                        };
                                                                                        #[cfg(target_arch = "wasm32")]
                                                                                        #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                                        unsafe extern "C" {
                                                                                          #[link_name = "[method]gpu-command-encoder.finish"]
                                                                                          fn wit_import4(_: i32, _: i32, _: i32, _: *mut u8, _: usize, ) -> i32;
                                                                                        }

                                                                                        #[cfg(not(target_arch = "wasm32"))]
                                                                                        unsafe extern "C" fn wit_import4(_: i32, _: i32, _: i32, _: *mut u8, _: usize, ) -> i32 { unreachable!() }
                                                                                        let ret = wit_import4((self).handle() as i32, result3_0, result3_1, result3_2, result3_3);
                                                                                        GpuCommandBuffer::from_handle(ret as u32)
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                  impl GpuCommandEncoder {
                                                                                    #[allow(unused_unsafe, clippy::all)]
                                                                                    #[allow(async_fn_in_trait)]
                                                                                    pub fn label(&self,) -> _rt::String{
                                                                                      unsafe {

                                                                                        #[cfg_attr(target_pointer_width="64", repr(align(8)))]
                                                                                        #[cfg_attr(target_pointer_width="32", repr(align(4)))]
                                                                                        struct RetArea([::core::mem::MaybeUninit::<u8>; 2*::core::mem::size_of::<*const u8>()]);
                                                                                        let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2*::core::mem::size_of::<*const u8>()]);
                                                                                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                                                                                        #[cfg(target_arch = "wasm32")]
                                                                                        #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                                        unsafe extern "C" {
                                                                                          #[link_name = "[method]gpu-command-encoder.label"]
                                                                                          fn wit_import1(_: i32, _: *mut u8, );
                                                                                        }

                                                                                        #[cfg(not(target_arch = "wasm32"))]
                                                                                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, ) { unreachable!() }
                                                                                        wit_import1((self).handle() as i32, ptr0);
                                                                                        let l2 = *ptr0.add(0).cast::<*mut u8>();
                                                                                        let l3 = *ptr0.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
                                                                                        let len4 = l3;
                                                                                        let bytes4 = _rt::Vec::from_raw_parts(l2.cast(), len4, len4);
                                                                                        let result5 = _rt::string_lift(bytes4);
                                                                                        result5
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                  impl GpuCommandEncoder {
                                                                                    #[allow(unused_unsafe, clippy::all)]
                                                                                    #[allow(async_fn_in_trait)]
                                                                                    pub fn set_label(&self,label: &str,) -> (){
                                                                                      unsafe {
                                                                                        let vec0 = label;
                                                                                        let ptr0 = vec0.as_ptr().cast::<u8>();
                                                                                        let len0 = vec0.len();

                                                                                        #[cfg(target_arch = "wasm32")]
                                                                                        #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                                        unsafe extern "C" {
                                                                                          #[link_name = "[method]gpu-command-encoder.set-label"]
                                                                                          fn wit_import1(_: i32, _: *mut u8, _: usize, );
                                                                                        }

                                                                                        #[cfg(not(target_arch = "wasm32"))]
                                                                                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, _: usize, ) { unreachable!() }
                                                                                        wit_import1((self).handle() as i32, ptr0.cast_mut(), len0);
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                  impl GpuCommandEncoder {
                                                                                    #[allow(unused_unsafe, clippy::all)]
                                                                                    #[allow(async_fn_in_trait)]
                                                                                    pub fn push_debug_group(&self,group_label: &str,) -> (){
                                                                                      unsafe {
                                                                                        let vec0 = group_label;
                                                                                        let ptr0 = vec0.as_ptr().cast::<u8>();
                                                                                        let len0 = vec0.len();

                                                                                        #[cfg(target_arch = "wasm32")]
                                                                                        #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                                        unsafe extern "C" {
                                                                                          #[link_name = "[method]gpu-command-encoder.push-debug-group"]
                                                                                          fn wit_import1(_: i32, _: *mut u8, _: usize, );
                                                                                        }

                                                                                        #[cfg(not(target_arch = "wasm32"))]
                                                                                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, _: usize, ) { unreachable!() }
                                                                                        wit_import1((self).handle() as i32, ptr0.cast_mut(), len0);
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                  impl GpuCommandEncoder {
                                                                                    #[allow(unused_unsafe, clippy::all)]
                                                                                    #[allow(async_fn_in_trait)]
                                                                                    pub fn pop_debug_group(&self,) -> (){
                                                                                      unsafe {

                                                                                        #[cfg(target_arch = "wasm32")]
                                                                                        #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                                        unsafe extern "C" {
                                                                                          #[link_name = "[method]gpu-command-encoder.pop-debug-group"]
                                                                                          fn wit_import0(_: i32, );
                                                                                        }

                                                                                        #[cfg(not(target_arch = "wasm32"))]
                                                                                        unsafe extern "C" fn wit_import0(_: i32, ) { unreachable!() }
                                                                                        wit_import0((self).handle() as i32);
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                  impl GpuCommandEncoder {
                                                                                    #[allow(unused_unsafe, clippy::all)]
                                                                                    #[allow(async_fn_in_trait)]
                                                                                    pub fn insert_debug_marker(&self,marker_label: &str,) -> (){
                                                                                      unsafe {
                                                                                        let vec0 = marker_label;
                                                                                        let ptr0 = vec0.as_ptr().cast::<u8>();
                                                                                        let len0 = vec0.len();

                                                                                        #[cfg(target_arch = "wasm32")]
                                                                                        #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                                        unsafe extern "C" {
                                                                                          #[link_name = "[method]gpu-command-encoder.insert-debug-marker"]
                                                                                          fn wit_import1(_: i32, _: *mut u8, _: usize, );
                                                                                        }

                                                                                        #[cfg(not(target_arch = "wasm32"))]
                                                                                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, _: usize, ) { unreachable!() }
                                                                                        wit_import1((self).handle() as i32, ptr0.cast_mut(), len0);
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                  impl GpuComputePassEncoder {
                                                                                    #[allow(unused_unsafe, clippy::all)]
                                                                                    #[allow(async_fn_in_trait)]
                                                                                    pub fn set_pipeline(&self,pipeline: &GpuComputePipeline,) -> (){
                                                                                      unsafe {

                                                                                        #[cfg(target_arch = "wasm32")]
                                                                                        #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                                        unsafe extern "C" {
                                                                                          #[link_name = "[method]gpu-compute-pass-encoder.set-pipeline"]
                                                                                          fn wit_import0(_: i32, _: i32, );
                                                                                        }

                                                                                        #[cfg(not(target_arch = "wasm32"))]
                                                                                        unsafe extern "C" fn wit_import0(_: i32, _: i32, ) { unreachable!() }
                                                                                        wit_import0((self).handle() as i32, (pipeline).handle() as i32);
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                  impl GpuComputePassEncoder {
                                                                                    #[allow(unused_unsafe, clippy::all)]
                                                                                    #[allow(async_fn_in_trait)]
                                                                                    pub fn dispatch_workgroups(&self,workgroup_count_x: GpuSize32,workgroup_count_y: Option<GpuSize32>,workgroup_count_z: Option<GpuSize32>,) -> (){
                                                                                      unsafe {
                                                                                        let (result0_0,result0_1,) = match workgroup_count_y {
                                                                                          Some(e) => (1i32, _rt::as_i32(e)),
                                                                                          None => {
                                                                                            (0i32, 0i32)
                                                                                          },
                                                                                        };let (result1_0,result1_1,) = match workgroup_count_z {
                                                                                          Some(e) => (1i32, _rt::as_i32(e)),
                                                                                          None => {
                                                                                            (0i32, 0i32)
                                                                                          },
                                                                                        };
                                                                                        #[cfg(target_arch = "wasm32")]
                                                                                        #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                                        unsafe extern "C" {
                                                                                          #[link_name = "[method]gpu-compute-pass-encoder.dispatch-workgroups"]
                                                                                          fn wit_import2(_: i32, _: i32, _: i32, _: i32, _: i32, _: i32, );
                                                                                        }

                                                                                        #[cfg(not(target_arch = "wasm32"))]
                                                                                        unsafe extern "C" fn wit_import2(_: i32, _: i32, _: i32, _: i32, _: i32, _: i32, ) { unreachable!() }
                                                                                        wit_import2((self).handle() as i32, _rt::as_i32(workgroup_count_x), result0_0, result0_1, result1_0, result1_1);
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                  impl GpuComputePassEncoder {
                                                                                    #[allow(unused_unsafe, clippy::all)]
                                                                                    #[allow(async_fn_in_trait)]
                                                                                    pub fn dispatch_workgroups_indirect(&self,indirect_buffer: &GpuBuffer,indirect_offset: GpuSize64,) -> (){
                                                                                      unsafe {

                                                                                        #[cfg(target_arch = "wasm32")]
                                                                                        #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                                        unsafe extern "C" {
                                                                                          #[link_name = "[method]gpu-compute-pass-encoder.dispatch-workgroups-indirect"]
                                                                                          fn wit_import0(_: i32, _: i32, _: i64, );
                                                                                        }

                                                                                        #[cfg(not(target_arch = "wasm32"))]
                                                                                        unsafe extern "C" fn wit_import0(_: i32, _: i32, _: i64, ) { unreachable!() }
                                                                                        wit_import0((self).handle() as i32, (indirect_buffer).handle() as i32, _rt::as_i64(indirect_offset));
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                  impl GpuComputePassEncoder {
                                                                                    #[allow(unused_unsafe, clippy::all)]
                                                                                    #[allow(async_fn_in_trait)]
                                                                                    pub fn end(&self,) -> (){
                                                                                      unsafe {

                                                                                        #[cfg(target_arch = "wasm32")]
                                                                                        #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                                        unsafe extern "C" {
                                                                                          #[link_name = "[method]gpu-compute-pass-encoder.end"]
                                                                                          fn wit_import0(_: i32, );
                                                                                        }

                                                                                        #[cfg(not(target_arch = "wasm32"))]
                                                                                        unsafe extern "C" fn wit_import0(_: i32, ) { unreachable!() }
                                                                                        wit_import0((self).handle() as i32);
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                  impl GpuComputePassEncoder {
                                                                                    #[allow(unused_unsafe, clippy::all)]
                                                                                    #[allow(async_fn_in_trait)]
                                                                                    pub fn label(&self,) -> _rt::String{
                                                                                      unsafe {

                                                                                        #[cfg_attr(target_pointer_width="64", repr(align(8)))]
                                                                                        #[cfg_attr(target_pointer_width="32", repr(align(4)))]
                                                                                        struct RetArea([::core::mem::MaybeUninit::<u8>; 2*::core::mem::size_of::<*const u8>()]);
                                                                                        let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2*::core::mem::size_of::<*const u8>()]);
                                                                                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                                                                                        #[cfg(target_arch = "wasm32")]
                                                                                        #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                                        unsafe extern "C" {
                                                                                          #[link_name = "[method]gpu-compute-pass-encoder.label"]
                                                                                          fn wit_import1(_: i32, _: *mut u8, );
                                                                                        }

                                                                                        #[cfg(not(target_arch = "wasm32"))]
                                                                                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, ) { unreachable!() }
                                                                                        wit_import1((self).handle() as i32, ptr0);
                                                                                        let l2 = *ptr0.add(0).cast::<*mut u8>();
                                                                                        let l3 = *ptr0.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
                                                                                        let len4 = l3;
                                                                                        let bytes4 = _rt::Vec::from_raw_parts(l2.cast(), len4, len4);
                                                                                        let result5 = _rt::string_lift(bytes4);
                                                                                        result5
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                  impl GpuComputePassEncoder {
                                                                                    #[allow(unused_unsafe, clippy::all)]
                                                                                    #[allow(async_fn_in_trait)]
                                                                                    pub fn set_label(&self,label: &str,) -> (){
                                                                                      unsafe {
                                                                                        let vec0 = label;
                                                                                        let ptr0 = vec0.as_ptr().cast::<u8>();
                                                                                        let len0 = vec0.len();

                                                                                        #[cfg(target_arch = "wasm32")]
                                                                                        #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                                        unsafe extern "C" {
                                                                                          #[link_name = "[method]gpu-compute-pass-encoder.set-label"]
                                                                                          fn wit_import1(_: i32, _: *mut u8, _: usize, );
                                                                                        }

                                                                                        #[cfg(not(target_arch = "wasm32"))]
                                                                                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, _: usize, ) { unreachable!() }
                                                                                        wit_import1((self).handle() as i32, ptr0.cast_mut(), len0);
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                  impl GpuComputePassEncoder {
                                                                                    #[allow(unused_unsafe, clippy::all)]
                                                                                    #[allow(async_fn_in_trait)]
                                                                                    pub fn push_debug_group(&self,group_label: &str,) -> (){
                                                                                      unsafe {
                                                                                        let vec0 = group_label;
                                                                                        let ptr0 = vec0.as_ptr().cast::<u8>();
                                                                                        let len0 = vec0.len();

                                                                                        #[cfg(target_arch = "wasm32")]
                                                                                        #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                                        unsafe extern "C" {
                                                                                          #[link_name = "[method]gpu-compute-pass-encoder.push-debug-group"]
                                                                                          fn wit_import1(_: i32, _: *mut u8, _: usize, );
                                                                                        }

                                                                                        #[cfg(not(target_arch = "wasm32"))]
                                                                                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, _: usize, ) { unreachable!() }
                                                                                        wit_import1((self).handle() as i32, ptr0.cast_mut(), len0);
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                  impl GpuComputePassEncoder {
                                                                                    #[allow(unused_unsafe, clippy::all)]
                                                                                    #[allow(async_fn_in_trait)]
                                                                                    pub fn pop_debug_group(&self,) -> (){
                                                                                      unsafe {

                                                                                        #[cfg(target_arch = "wasm32")]
                                                                                        #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                                        unsafe extern "C" {
                                                                                          #[link_name = "[method]gpu-compute-pass-encoder.pop-debug-group"]
                                                                                          fn wit_import0(_: i32, );
                                                                                        }

                                                                                        #[cfg(not(target_arch = "wasm32"))]
                                                                                        unsafe extern "C" fn wit_import0(_: i32, ) { unreachable!() }
                                                                                        wit_import0((self).handle() as i32);
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                  impl GpuComputePassEncoder {
                                                                                    #[allow(unused_unsafe, clippy::all)]
                                                                                    #[allow(async_fn_in_trait)]
                                                                                    pub fn insert_debug_marker(&self,marker_label: &str,) -> (){
                                                                                      unsafe {
                                                                                        let vec0 = marker_label;
                                                                                        let ptr0 = vec0.as_ptr().cast::<u8>();
                                                                                        let len0 = vec0.len();

                                                                                        #[cfg(target_arch = "wasm32")]
                                                                                        #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                                        unsafe extern "C" {
                                                                                          #[link_name = "[method]gpu-compute-pass-encoder.insert-debug-marker"]
                                                                                          fn wit_import1(_: i32, _: *mut u8, _: usize, );
                                                                                        }

                                                                                        #[cfg(not(target_arch = "wasm32"))]
                                                                                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, _: usize, ) { unreachable!() }
                                                                                        wit_import1((self).handle() as i32, ptr0.cast_mut(), len0);
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                  impl GpuComputePassEncoder {
                                                                                    #[allow(unused_unsafe, clippy::all)]
                                                                                    #[allow(async_fn_in_trait)]
                                                                                    pub fn set_bind_group(&self,index: GpuIndex32,bind_group: Option<&GpuBindGroup>,dynamic_offsets_data: Option<&[GpuBufferDynamicOffset]>,dynamic_offsets_data_start: Option<GpuSize64>,dynamic_offsets_data_length: Option<GpuSize32>,) -> Result<(),SetBindGroupError>{
                                                                                      unsafe {

                                                                                        #[cfg_attr(target_pointer_width="64", repr(align(8)))]
                                                                                        #[cfg_attr(target_pointer_width="32", repr(align(4)))]
                                                                                        struct RetArea([::core::mem::MaybeUninit::<u8>; 4*::core::mem::size_of::<*const u8>()]);
                                                                                        let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 4*::core::mem::size_of::<*const u8>()]);
                                                                                        let (result0_0,result0_1,) = match bind_group {
                                                                                          Some(e) => (1i32, (e).handle() as i32),
                                                                                          None => {
                                                                                            (0i32, 0i32)
                                                                                          },
                                                                                        };let (result2_0,result2_1,result2_2,) = match dynamic_offsets_data {
                                                                                          Some(e) => {
                                                                                            let vec1 = e;
                                                                                            let ptr1 = vec1.as_ptr().cast::<u8>();
                                                                                            let len1 = vec1.len();

                                                                                            (1i32, ptr1.cast_mut(), len1)
                                                                                          },
                                                                                          None => {
                                                                                            (0i32, ::core::ptr::null_mut(), 0usize)
                                                                                          },
                                                                                        };let (result3_0,result3_1,) = match dynamic_offsets_data_start {
                                                                                          Some(e) => (1i32, _rt::as_i64(e)),
                                                                                          None => {
                                                                                            (0i32, 0i64)
                                                                                          },
                                                                                        };let (result4_0,result4_1,) = match dynamic_offsets_data_length {
                                                                                          Some(e) => (1i32, _rt::as_i32(e)),
                                                                                          None => {
                                                                                            (0i32, 0i32)
                                                                                          },
                                                                                        };let ptr5 = ret_area.0.as_mut_ptr().cast::<u8>();
                                                                                        #[cfg(target_arch = "wasm32")]
                                                                                        #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                                        unsafe extern "C" {
                                                                                          #[link_name = "[method]gpu-compute-pass-encoder.set-bind-group"]
                                                                                          fn wit_import6(_: i32, _: i32, _: i32, _: i32, _: i32, _: *mut u8, _: usize, _: i32, _: i64, _: i32, _: i32, _: *mut u8, );
                                                                                        }

                                                                                        #[cfg(not(target_arch = "wasm32"))]
                                                                                        unsafe extern "C" fn wit_import6(_: i32, _: i32, _: i32, _: i32, _: i32, _: *mut u8, _: usize, _: i32, _: i64, _: i32, _: i32, _: *mut u8, ) { unreachable!() }
                                                                                        wit_import6((self).handle() as i32, _rt::as_i32(index), result0_0, result0_1, result2_0, result2_1, result2_2, result3_0, result3_1, result4_0, result4_1, ptr5);
                                                                                        let l7 = i32::from(*ptr5.add(0).cast::<u8>());
                                                                                        let result13 = match l7 {
                                                                                          0 => {
                                                                                            let e = ();
                                                                                            Ok(e)
                                                                                          }
                                                                                          1 => {
                                                                                            let e = {
                                                                                              let l8 = i32::from(*ptr5.add(::core::mem::size_of::<*const u8>()).cast::<u8>());
                                                                                              let v9 = match l8 {
                                                                                                n => {
                                                                                                  debug_assert_eq!(n, 0, "invalid enum discriminant");
                                                                                                  SetBindGroupErrorKind::RangeError
                                                                                                }
                                                                                              };
                                                                                              let l10 = *ptr5.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                                                                                              let l11 = *ptr5.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>();
                                                                                              let len12 = l11;
                                                                                              let bytes12 = _rt::Vec::from_raw_parts(l10.cast(), len12, len12);

                                                                                              SetBindGroupError{
                                                                                                kind: v9,
                                                                                                message: _rt::string_lift(bytes12),
                                                                                              }
                                                                                            };
                                                                                            Err(e)
                                                                                          }
                                                                                          _ => _rt::invalid_enum_discriminant(),
                                                                                        };
                                                                                        result13
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                  impl GpuRenderPassEncoder {
                                                                                    #[allow(unused_unsafe, clippy::all)]
                                                                                    #[allow(async_fn_in_trait)]
                                                                                    pub fn set_viewport(&self,x: f32,y: f32,width: f32,height: f32,min_depth: f32,max_depth: f32,) -> (){
                                                                                      unsafe {

                                                                                        #[cfg(target_arch = "wasm32")]
                                                                                        #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                                        unsafe extern "C" {
                                                                                          #[link_name = "[method]gpu-render-pass-encoder.set-viewport"]
                                                                                          fn wit_import0(_: i32, _: f32, _: f32, _: f32, _: f32, _: f32, _: f32, );
                                                                                        }

                                                                                        #[cfg(not(target_arch = "wasm32"))]
                                                                                        unsafe extern "C" fn wit_import0(_: i32, _: f32, _: f32, _: f32, _: f32, _: f32, _: f32, ) { unreachable!() }
                                                                                        wit_import0((self).handle() as i32, _rt::as_f32(&x), _rt::as_f32(&y), _rt::as_f32(&width), _rt::as_f32(&height), _rt::as_f32(&min_depth), _rt::as_f32(&max_depth));
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                  impl GpuRenderPassEncoder {
                                                                                    #[allow(unused_unsafe, clippy::all)]
                                                                                    #[allow(async_fn_in_trait)]
                                                                                    pub fn set_scissor_rect(&self,x: GpuIntegerCoordinate,y: GpuIntegerCoordinate,width: GpuIntegerCoordinate,height: GpuIntegerCoordinate,) -> (){
                                                                                      unsafe {

                                                                                        #[cfg(target_arch = "wasm32")]
                                                                                        #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                                        unsafe extern "C" {
                                                                                          #[link_name = "[method]gpu-render-pass-encoder.set-scissor-rect"]
                                                                                          fn wit_import0(_: i32, _: i32, _: i32, _: i32, _: i32, );
                                                                                        }

                                                                                        #[cfg(not(target_arch = "wasm32"))]
                                                                                        unsafe extern "C" fn wit_import0(_: i32, _: i32, _: i32, _: i32, _: i32, ) { unreachable!() }
                                                                                        wit_import0((self).handle() as i32, _rt::as_i32(x), _rt::as_i32(y), _rt::as_i32(width), _rt::as_i32(height));
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                  impl GpuRenderPassEncoder {
                                                                                    #[allow(unused_unsafe, clippy::all)]
                                                                                    #[allow(async_fn_in_trait)]
                                                                                    pub fn set_blend_constant(&self,color: GpuColor,) -> (){
                                                                                      unsafe {
                                                                                        let GpuColor{ r:r0, g:g0, b:b0, a:a0, } = color;

                                                                                        #[cfg(target_arch = "wasm32")]
                                                                                        #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                                        unsafe extern "C" {
                                                                                          #[link_name = "[method]gpu-render-pass-encoder.set-blend-constant"]
                                                                                          fn wit_import1(_: i32, _: f64, _: f64, _: f64, _: f64, );
                                                                                        }

                                                                                        #[cfg(not(target_arch = "wasm32"))]
                                                                                        unsafe extern "C" fn wit_import1(_: i32, _: f64, _: f64, _: f64, _: f64, ) { unreachable!() }
                                                                                        wit_import1((self).handle() as i32, _rt::as_f64(r0), _rt::as_f64(g0), _rt::as_f64(b0), _rt::as_f64(a0));
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                  impl GpuRenderPassEncoder {
                                                                                    #[allow(unused_unsafe, clippy::all)]
                                                                                    #[allow(async_fn_in_trait)]
                                                                                    pub fn set_stencil_reference(&self,reference: GpuStencilValue,) -> (){
                                                                                      unsafe {

                                                                                        #[cfg(target_arch = "wasm32")]
                                                                                        #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                                        unsafe extern "C" {
                                                                                          #[link_name = "[method]gpu-render-pass-encoder.set-stencil-reference"]
                                                                                          fn wit_import0(_: i32, _: i32, );
                                                                                        }

                                                                                        #[cfg(not(target_arch = "wasm32"))]
                                                                                        unsafe extern "C" fn wit_import0(_: i32, _: i32, ) { unreachable!() }
                                                                                        wit_import0((self).handle() as i32, _rt::as_i32(reference));
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                  impl GpuRenderPassEncoder {
                                                                                    #[allow(unused_unsafe, clippy::all)]
                                                                                    #[allow(async_fn_in_trait)]
                                                                                    pub fn begin_occlusion_query(&self,query_index: GpuSize32,) -> (){
                                                                                      unsafe {

                                                                                        #[cfg(target_arch = "wasm32")]
                                                                                        #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                                        unsafe extern "C" {
                                                                                          #[link_name = "[method]gpu-render-pass-encoder.begin-occlusion-query"]
                                                                                          fn wit_import0(_: i32, _: i32, );
                                                                                        }

                                                                                        #[cfg(not(target_arch = "wasm32"))]
                                                                                        unsafe extern "C" fn wit_import0(_: i32, _: i32, ) { unreachable!() }
                                                                                        wit_import0((self).handle() as i32, _rt::as_i32(query_index));
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                  impl GpuRenderPassEncoder {
                                                                                    #[allow(unused_unsafe, clippy::all)]
                                                                                    #[allow(async_fn_in_trait)]
                                                                                    pub fn end_occlusion_query(&self,) -> (){
                                                                                      unsafe {

                                                                                        #[cfg(target_arch = "wasm32")]
                                                                                        #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                                        unsafe extern "C" {
                                                                                          #[link_name = "[method]gpu-render-pass-encoder.end-occlusion-query"]
                                                                                          fn wit_import0(_: i32, );
                                                                                        }

                                                                                        #[cfg(not(target_arch = "wasm32"))]
                                                                                        unsafe extern "C" fn wit_import0(_: i32, ) { unreachable!() }
                                                                                        wit_import0((self).handle() as i32);
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                  impl GpuRenderPassEncoder {
                                                                                    #[allow(unused_unsafe, clippy::all)]
                                                                                    #[allow(async_fn_in_trait)]
                                                                                    pub fn execute_bundles(&self,bundles: &[&GpuRenderBundle],) -> (){
                                                                                      unsafe {
                                                                                        let vec0 = bundles;
                                                                                        let len0 = vec0.len();
                                                                                        let layout0 = _rt::alloc::Layout::from_size_align(vec0.len() * 4, 4).unwrap();
                                                                                        let (result0, _cleanup0) = wit_bindgen::rt::Cleanup::new(layout0);for (i, e) in vec0.into_iter().enumerate() {
                                                                                          let base = result0.add(i * 4);
                                                                                          {
                                                                                            *base.add(0).cast::<i32>() = (e).handle() as i32;
                                                                                          }
                                                                                        }

                                                                                        #[cfg(target_arch = "wasm32")]
                                                                                        #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                                        unsafe extern "C" {
                                                                                          #[link_name = "[method]gpu-render-pass-encoder.execute-bundles"]
                                                                                          fn wit_import1(_: i32, _: *mut u8, _: usize, );
                                                                                        }

                                                                                        #[cfg(not(target_arch = "wasm32"))]
                                                                                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, _: usize, ) { unreachable!() }
                                                                                        wit_import1((self).handle() as i32, result0, len0);
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                  impl GpuRenderPassEncoder {
                                                                                    #[allow(unused_unsafe, clippy::all)]
                                                                                    #[allow(async_fn_in_trait)]
                                                                                    pub fn end(&self,) -> (){
                                                                                      unsafe {

                                                                                        #[cfg(target_arch = "wasm32")]
                                                                                        #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                                        unsafe extern "C" {
                                                                                          #[link_name = "[method]gpu-render-pass-encoder.end"]
                                                                                          fn wit_import0(_: i32, );
                                                                                        }

                                                                                        #[cfg(not(target_arch = "wasm32"))]
                                                                                        unsafe extern "C" fn wit_import0(_: i32, ) { unreachable!() }
                                                                                        wit_import0((self).handle() as i32);
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                  impl GpuRenderPassEncoder {
                                                                                    #[allow(unused_unsafe, clippy::all)]
                                                                                    #[allow(async_fn_in_trait)]
                                                                                    pub fn label(&self,) -> _rt::String{
                                                                                      unsafe {

                                                                                        #[cfg_attr(target_pointer_width="64", repr(align(8)))]
                                                                                        #[cfg_attr(target_pointer_width="32", repr(align(4)))]
                                                                                        struct RetArea([::core::mem::MaybeUninit::<u8>; 2*::core::mem::size_of::<*const u8>()]);
                                                                                        let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2*::core::mem::size_of::<*const u8>()]);
                                                                                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                                                                                        #[cfg(target_arch = "wasm32")]
                                                                                        #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                                        unsafe extern "C" {
                                                                                          #[link_name = "[method]gpu-render-pass-encoder.label"]
                                                                                          fn wit_import1(_: i32, _: *mut u8, );
                                                                                        }

                                                                                        #[cfg(not(target_arch = "wasm32"))]
                                                                                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, ) { unreachable!() }
                                                                                        wit_import1((self).handle() as i32, ptr0);
                                                                                        let l2 = *ptr0.add(0).cast::<*mut u8>();
                                                                                        let l3 = *ptr0.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
                                                                                        let len4 = l3;
                                                                                        let bytes4 = _rt::Vec::from_raw_parts(l2.cast(), len4, len4);
                                                                                        let result5 = _rt::string_lift(bytes4);
                                                                                        result5
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                  impl GpuRenderPassEncoder {
                                                                                    #[allow(unused_unsafe, clippy::all)]
                                                                                    #[allow(async_fn_in_trait)]
                                                                                    pub fn set_label(&self,label: &str,) -> (){
                                                                                      unsafe {
                                                                                        let vec0 = label;
                                                                                        let ptr0 = vec0.as_ptr().cast::<u8>();
                                                                                        let len0 = vec0.len();

                                                                                        #[cfg(target_arch = "wasm32")]
                                                                                        #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                                        unsafe extern "C" {
                                                                                          #[link_name = "[method]gpu-render-pass-encoder.set-label"]
                                                                                          fn wit_import1(_: i32, _: *mut u8, _: usize, );
                                                                                        }

                                                                                        #[cfg(not(target_arch = "wasm32"))]
                                                                                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, _: usize, ) { unreachable!() }
                                                                                        wit_import1((self).handle() as i32, ptr0.cast_mut(), len0);
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                  impl GpuRenderPassEncoder {
                                                                                    #[allow(unused_unsafe, clippy::all)]
                                                                                    #[allow(async_fn_in_trait)]
                                                                                    pub fn push_debug_group(&self,group_label: &str,) -> (){
                                                                                      unsafe {
                                                                                        let vec0 = group_label;
                                                                                        let ptr0 = vec0.as_ptr().cast::<u8>();
                                                                                        let len0 = vec0.len();

                                                                                        #[cfg(target_arch = "wasm32")]
                                                                                        #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                                        unsafe extern "C" {
                                                                                          #[link_name = "[method]gpu-render-pass-encoder.push-debug-group"]
                                                                                          fn wit_import1(_: i32, _: *mut u8, _: usize, );
                                                                                        }

                                                                                        #[cfg(not(target_arch = "wasm32"))]
                                                                                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, _: usize, ) { unreachable!() }
                                                                                        wit_import1((self).handle() as i32, ptr0.cast_mut(), len0);
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                  impl GpuRenderPassEncoder {
                                                                                    #[allow(unused_unsafe, clippy::all)]
                                                                                    #[allow(async_fn_in_trait)]
                                                                                    pub fn pop_debug_group(&self,) -> (){
                                                                                      unsafe {

                                                                                        #[cfg(target_arch = "wasm32")]
                                                                                        #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                                        unsafe extern "C" {
                                                                                          #[link_name = "[method]gpu-render-pass-encoder.pop-debug-group"]
                                                                                          fn wit_import0(_: i32, );
                                                                                        }

                                                                                        #[cfg(not(target_arch = "wasm32"))]
                                                                                        unsafe extern "C" fn wit_import0(_: i32, ) { unreachable!() }
                                                                                        wit_import0((self).handle() as i32);
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                  impl GpuRenderPassEncoder {
                                                                                    #[allow(unused_unsafe, clippy::all)]
                                                                                    #[allow(async_fn_in_trait)]
                                                                                    pub fn insert_debug_marker(&self,marker_label: &str,) -> (){
                                                                                      unsafe {
                                                                                        let vec0 = marker_label;
                                                                                        let ptr0 = vec0.as_ptr().cast::<u8>();
                                                                                        let len0 = vec0.len();

                                                                                        #[cfg(target_arch = "wasm32")]
                                                                                        #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                                        unsafe extern "C" {
                                                                                          #[link_name = "[method]gpu-render-pass-encoder.insert-debug-marker"]
                                                                                          fn wit_import1(_: i32, _: *mut u8, _: usize, );
                                                                                        }

                                                                                        #[cfg(not(target_arch = "wasm32"))]
                                                                                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, _: usize, ) { unreachable!() }
                                                                                        wit_import1((self).handle() as i32, ptr0.cast_mut(), len0);
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                  impl GpuRenderPassEncoder {
                                                                                    #[allow(unused_unsafe, clippy::all)]
                                                                                    #[allow(async_fn_in_trait)]
                                                                                    pub fn set_bind_group(&self,index: GpuIndex32,bind_group: Option<&GpuBindGroup>,dynamic_offsets_data: Option<&[GpuBufferDynamicOffset]>,dynamic_offsets_data_start: Option<GpuSize64>,dynamic_offsets_data_length: Option<GpuSize32>,) -> Result<(),SetBindGroupError>{
                                                                                      unsafe {

                                                                                        #[cfg_attr(target_pointer_width="64", repr(align(8)))]
                                                                                        #[cfg_attr(target_pointer_width="32", repr(align(4)))]
                                                                                        struct RetArea([::core::mem::MaybeUninit::<u8>; 4*::core::mem::size_of::<*const u8>()]);
                                                                                        let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 4*::core::mem::size_of::<*const u8>()]);
                                                                                        let (result0_0,result0_1,) = match bind_group {
                                                                                          Some(e) => (1i32, (e).handle() as i32),
                                                                                          None => {
                                                                                            (0i32, 0i32)
                                                                                          },
                                                                                        };let (result2_0,result2_1,result2_2,) = match dynamic_offsets_data {
                                                                                          Some(e) => {
                                                                                            let vec1 = e;
                                                                                            let ptr1 = vec1.as_ptr().cast::<u8>();
                                                                                            let len1 = vec1.len();

                                                                                            (1i32, ptr1.cast_mut(), len1)
                                                                                          },
                                                                                          None => {
                                                                                            (0i32, ::core::ptr::null_mut(), 0usize)
                                                                                          },
                                                                                        };let (result3_0,result3_1,) = match dynamic_offsets_data_start {
                                                                                          Some(e) => (1i32, _rt::as_i64(e)),
                                                                                          None => {
                                                                                            (0i32, 0i64)
                                                                                          },
                                                                                        };let (result4_0,result4_1,) = match dynamic_offsets_data_length {
                                                                                          Some(e) => (1i32, _rt::as_i32(e)),
                                                                                          None => {
                                                                                            (0i32, 0i32)
                                                                                          },
                                                                                        };let ptr5 = ret_area.0.as_mut_ptr().cast::<u8>();
                                                                                        #[cfg(target_arch = "wasm32")]
                                                                                        #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                                        unsafe extern "C" {
                                                                                          #[link_name = "[method]gpu-render-pass-encoder.set-bind-group"]
                                                                                          fn wit_import6(_: i32, _: i32, _: i32, _: i32, _: i32, _: *mut u8, _: usize, _: i32, _: i64, _: i32, _: i32, _: *mut u8, );
                                                                                        }

                                                                                        #[cfg(not(target_arch = "wasm32"))]
                                                                                        unsafe extern "C" fn wit_import6(_: i32, _: i32, _: i32, _: i32, _: i32, _: *mut u8, _: usize, _: i32, _: i64, _: i32, _: i32, _: *mut u8, ) { unreachable!() }
                                                                                        wit_import6((self).handle() as i32, _rt::as_i32(index), result0_0, result0_1, result2_0, result2_1, result2_2, result3_0, result3_1, result4_0, result4_1, ptr5);
                                                                                        let l7 = i32::from(*ptr5.add(0).cast::<u8>());
                                                                                        let result13 = match l7 {
                                                                                          0 => {
                                                                                            let e = ();
                                                                                            Ok(e)
                                                                                          }
                                                                                          1 => {
                                                                                            let e = {
                                                                                              let l8 = i32::from(*ptr5.add(::core::mem::size_of::<*const u8>()).cast::<u8>());
                                                                                              let v9 = match l8 {
                                                                                                n => {
                                                                                                  debug_assert_eq!(n, 0, "invalid enum discriminant");
                                                                                                  SetBindGroupErrorKind::RangeError
                                                                                                }
                                                                                              };
                                                                                              let l10 = *ptr5.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                                                                                              let l11 = *ptr5.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>();
                                                                                              let len12 = l11;
                                                                                              let bytes12 = _rt::Vec::from_raw_parts(l10.cast(), len12, len12);

                                                                                              SetBindGroupError{
                                                                                                kind: v9,
                                                                                                message: _rt::string_lift(bytes12),
                                                                                              }
                                                                                            };
                                                                                            Err(e)
                                                                                          }
                                                                                          _ => _rt::invalid_enum_discriminant(),
                                                                                        };
                                                                                        result13
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                  impl GpuRenderPassEncoder {
                                                                                    #[allow(unused_unsafe, clippy::all)]
                                                                                    #[allow(async_fn_in_trait)]
                                                                                    pub fn set_pipeline(&self,pipeline: &GpuRenderPipeline,) -> (){
                                                                                      unsafe {

                                                                                        #[cfg(target_arch = "wasm32")]
                                                                                        #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                                        unsafe extern "C" {
                                                                                          #[link_name = "[method]gpu-render-pass-encoder.set-pipeline"]
                                                                                          fn wit_import0(_: i32, _: i32, );
                                                                                        }

                                                                                        #[cfg(not(target_arch = "wasm32"))]
                                                                                        unsafe extern "C" fn wit_import0(_: i32, _: i32, ) { unreachable!() }
                                                                                        wit_import0((self).handle() as i32, (pipeline).handle() as i32);
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                  impl GpuRenderPassEncoder {
                                                                                    #[allow(unused_unsafe, clippy::all)]
                                                                                    #[allow(async_fn_in_trait)]
                                                                                    pub fn set_index_buffer(&self,buffer: &GpuBuffer,index_format: GpuIndexFormat,offset: Option<GpuSize64>,size: Option<GpuSize64>,) -> (){
                                                                                      unsafe {
                                                                                        let (result0_0,result0_1,) = match offset {
                                                                                          Some(e) => (1i32, _rt::as_i64(e)),
                                                                                          None => {
                                                                                            (0i32, 0i64)
                                                                                          },
                                                                                        };let (result1_0,result1_1,) = match size {
                                                                                          Some(e) => (1i32, _rt::as_i64(e)),
                                                                                          None => {
                                                                                            (0i32, 0i64)
                                                                                          },
                                                                                        };
                                                                                        #[cfg(target_arch = "wasm32")]
                                                                                        #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                                        unsafe extern "C" {
                                                                                          #[link_name = "[method]gpu-render-pass-encoder.set-index-buffer"]
                                                                                          fn wit_import2(_: i32, _: i32, _: i32, _: i32, _: i64, _: i32, _: i64, );
                                                                                        }

                                                                                        #[cfg(not(target_arch = "wasm32"))]
                                                                                        unsafe extern "C" fn wit_import2(_: i32, _: i32, _: i32, _: i32, _: i64, _: i32, _: i64, ) { unreachable!() }
                                                                                        wit_import2((self).handle() as i32, (buffer).handle() as i32, index_format.clone() as i32, result0_0, result0_1, result1_0, result1_1);
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                  impl GpuRenderPassEncoder {
                                                                                    #[allow(unused_unsafe, clippy::all)]
                                                                                    #[allow(async_fn_in_trait)]
                                                                                    pub fn set_vertex_buffer(&self,slot: GpuIndex32,buffer: Option<&GpuBuffer>,offset: Option<GpuSize64>,size: Option<GpuSize64>,) -> (){
                                                                                      unsafe {
                                                                                        let (result0_0,result0_1,) = match buffer {
                                                                                          Some(e) => (1i32, (e).handle() as i32),
                                                                                          None => {
                                                                                            (0i32, 0i32)
                                                                                          },
                                                                                        };let (result1_0,result1_1,) = match offset {
                                                                                          Some(e) => (1i32, _rt::as_i64(e)),
                                                                                          None => {
                                                                                            (0i32, 0i64)
                                                                                          },
                                                                                        };let (result2_0,result2_1,) = match size {
                                                                                          Some(e) => (1i32, _rt::as_i64(e)),
                                                                                          None => {
                                                                                            (0i32, 0i64)
                                                                                          },
                                                                                        };
                                                                                        #[cfg(target_arch = "wasm32")]
                                                                                        #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                                        unsafe extern "C" {
                                                                                          #[link_name = "[method]gpu-render-pass-encoder.set-vertex-buffer"]
                                                                                          fn wit_import3(_: i32, _: i32, _: i32, _: i32, _: i32, _: i64, _: i32, _: i64, );
                                                                                        }

                                                                                        #[cfg(not(target_arch = "wasm32"))]
                                                                                        unsafe extern "C" fn wit_import3(_: i32, _: i32, _: i32, _: i32, _: i32, _: i64, _: i32, _: i64, ) { unreachable!() }
                                                                                        wit_import3((self).handle() as i32, _rt::as_i32(slot), result0_0, result0_1, result1_0, result1_1, result2_0, result2_1);
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                  impl GpuRenderPassEncoder {
                                                                                    #[allow(unused_unsafe, clippy::all)]
                                                                                    #[allow(async_fn_in_trait)]
                                                                                    pub fn draw(&self,vertex_count: GpuSize32,instance_count: Option<GpuSize32>,first_vertex: Option<GpuSize32>,first_instance: Option<GpuSize32>,) -> (){
                                                                                      unsafe {
                                                                                        let (result0_0,result0_1,) = match instance_count {
                                                                                          Some(e) => (1i32, _rt::as_i32(e)),
                                                                                          None => {
                                                                                            (0i32, 0i32)
                                                                                          },
                                                                                        };let (result1_0,result1_1,) = match first_vertex {
                                                                                          Some(e) => (1i32, _rt::as_i32(e)),
                                                                                          None => {
                                                                                            (0i32, 0i32)
                                                                                          },
                                                                                        };let (result2_0,result2_1,) = match first_instance {
                                                                                          Some(e) => (1i32, _rt::as_i32(e)),
                                                                                          None => {
                                                                                            (0i32, 0i32)
                                                                                          },
                                                                                        };
                                                                                        #[cfg(target_arch = "wasm32")]
                                                                                        #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                                        unsafe extern "C" {
                                                                                          #[link_name = "[method]gpu-render-pass-encoder.draw"]
                                                                                          fn wit_import3(_: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, );
                                                                                        }

                                                                                        #[cfg(not(target_arch = "wasm32"))]
                                                                                        unsafe extern "C" fn wit_import3(_: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, ) { unreachable!() }
                                                                                        wit_import3((self).handle() as i32, _rt::as_i32(vertex_count), result0_0, result0_1, result1_0, result1_1, result2_0, result2_1);
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                  impl GpuRenderPassEncoder {
                                                                                    #[allow(unused_unsafe, clippy::all)]
                                                                                    #[allow(async_fn_in_trait)]
                                                                                    pub fn draw_indexed(&self,index_count: GpuSize32,instance_count: Option<GpuSize32>,first_index: Option<GpuSize32>,base_vertex: Option<GpuSignedOffset32>,first_instance: Option<GpuSize32>,) -> (){
                                                                                      unsafe {
                                                                                        let (result0_0,result0_1,) = match instance_count {
                                                                                          Some(e) => (1i32, _rt::as_i32(e)),
                                                                                          None => {
                                                                                            (0i32, 0i32)
                                                                                          },
                                                                                        };let (result1_0,result1_1,) = match first_index {
                                                                                          Some(e) => (1i32, _rt::as_i32(e)),
                                                                                          None => {
                                                                                            (0i32, 0i32)
                                                                                          },
                                                                                        };let (result2_0,result2_1,) = match base_vertex {
                                                                                          Some(e) => (1i32, _rt::as_i32(e)),
                                                                                          None => {
                                                                                            (0i32, 0i32)
                                                                                          },
                                                                                        };let (result3_0,result3_1,) = match first_instance {
                                                                                          Some(e) => (1i32, _rt::as_i32(e)),
                                                                                          None => {
                                                                                            (0i32, 0i32)
                                                                                          },
                                                                                        };
                                                                                        #[cfg(target_arch = "wasm32")]
                                                                                        #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                                        unsafe extern "C" {
                                                                                          #[link_name = "[method]gpu-render-pass-encoder.draw-indexed"]
                                                                                          fn wit_import4(_: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, );
                                                                                        }

                                                                                        #[cfg(not(target_arch = "wasm32"))]
                                                                                        unsafe extern "C" fn wit_import4(_: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, ) { unreachable!() }
                                                                                        wit_import4((self).handle() as i32, _rt::as_i32(index_count), result0_0, result0_1, result1_0, result1_1, result2_0, result2_1, result3_0, result3_1);
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                  impl GpuRenderPassEncoder {
                                                                                    #[allow(unused_unsafe, clippy::all)]
                                                                                    #[allow(async_fn_in_trait)]
                                                                                    pub fn draw_indirect(&self,indirect_buffer: &GpuBuffer,indirect_offset: GpuSize64,) -> (){
                                                                                      unsafe {

                                                                                        #[cfg(target_arch = "wasm32")]
                                                                                        #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                                        unsafe extern "C" {
                                                                                          #[link_name = "[method]gpu-render-pass-encoder.draw-indirect"]
                                                                                          fn wit_import0(_: i32, _: i32, _: i64, );
                                                                                        }

                                                                                        #[cfg(not(target_arch = "wasm32"))]
                                                                                        unsafe extern "C" fn wit_import0(_: i32, _: i32, _: i64, ) { unreachable!() }
                                                                                        wit_import0((self).handle() as i32, (indirect_buffer).handle() as i32, _rt::as_i64(indirect_offset));
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                  impl GpuRenderPassEncoder {
                                                                                    #[allow(unused_unsafe, clippy::all)]
                                                                                    #[allow(async_fn_in_trait)]
                                                                                    pub fn draw_indexed_indirect(&self,indirect_buffer: &GpuBuffer,indirect_offset: GpuSize64,) -> (){
                                                                                      unsafe {

                                                                                        #[cfg(target_arch = "wasm32")]
                                                                                        #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                                        unsafe extern "C" {
                                                                                          #[link_name = "[method]gpu-render-pass-encoder.draw-indexed-indirect"]
                                                                                          fn wit_import0(_: i32, _: i32, _: i64, );
                                                                                        }

                                                                                        #[cfg(not(target_arch = "wasm32"))]
                                                                                        unsafe extern "C" fn wit_import0(_: i32, _: i32, _: i64, ) { unreachable!() }
                                                                                        wit_import0((self).handle() as i32, (indirect_buffer).handle() as i32, _rt::as_i64(indirect_offset));
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                  impl GpuRenderBundle {
                                                                                    #[allow(unused_unsafe, clippy::all)]
                                                                                    #[allow(async_fn_in_trait)]
                                                                                    pub fn label(&self,) -> _rt::String{
                                                                                      unsafe {

                                                                                        #[cfg_attr(target_pointer_width="64", repr(align(8)))]
                                                                                        #[cfg_attr(target_pointer_width="32", repr(align(4)))]
                                                                                        struct RetArea([::core::mem::MaybeUninit::<u8>; 2*::core::mem::size_of::<*const u8>()]);
                                                                                        let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2*::core::mem::size_of::<*const u8>()]);
                                                                                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                                                                                        #[cfg(target_arch = "wasm32")]
                                                                                        #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                                        unsafe extern "C" {
                                                                                          #[link_name = "[method]gpu-render-bundle.label"]
                                                                                          fn wit_import1(_: i32, _: *mut u8, );
                                                                                        }

                                                                                        #[cfg(not(target_arch = "wasm32"))]
                                                                                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, ) { unreachable!() }
                                                                                        wit_import1((self).handle() as i32, ptr0);
                                                                                        let l2 = *ptr0.add(0).cast::<*mut u8>();
                                                                                        let l3 = *ptr0.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
                                                                                        let len4 = l3;
                                                                                        let bytes4 = _rt::Vec::from_raw_parts(l2.cast(), len4, len4);
                                                                                        let result5 = _rt::string_lift(bytes4);
                                                                                        result5
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                  impl GpuRenderBundle {
                                                                                    #[allow(unused_unsafe, clippy::all)]
                                                                                    #[allow(async_fn_in_trait)]
                                                                                    pub fn set_label(&self,label: &str,) -> (){
                                                                                      unsafe {
                                                                                        let vec0 = label;
                                                                                        let ptr0 = vec0.as_ptr().cast::<u8>();
                                                                                        let len0 = vec0.len();

                                                                                        #[cfg(target_arch = "wasm32")]
                                                                                        #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                                        unsafe extern "C" {
                                                                                          #[link_name = "[method]gpu-render-bundle.set-label"]
                                                                                          fn wit_import1(_: i32, _: *mut u8, _: usize, );
                                                                                        }

                                                                                        #[cfg(not(target_arch = "wasm32"))]
                                                                                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, _: usize, ) { unreachable!() }
                                                                                        wit_import1((self).handle() as i32, ptr0.cast_mut(), len0);
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                  impl GpuRenderBundleEncoder {
                                                                                    #[allow(unused_unsafe, clippy::all)]
                                                                                    #[allow(async_fn_in_trait)]
                                                                                    pub fn finish(&self,descriptor: Option<&GpuRenderBundleDescriptor>,) -> GpuRenderBundle{
                                                                                      unsafe {
                                                                                        let (result3_0,result3_1,result3_2,result3_3,) = match descriptor {
                                                                                          Some(e) => {
                                                                                            let GpuRenderBundleDescriptor{ label:label0, } = e;
                                                                                            let (result2_0,result2_1,result2_2,) = match label0 {
                                                                                              Some(e) => {
                                                                                                let vec1 = e;
                                                                                                let ptr1 = vec1.as_ptr().cast::<u8>();
                                                                                                let len1 = vec1.len();

                                                                                                (1i32, ptr1.cast_mut(), len1)
                                                                                              },
                                                                                              None => {
                                                                                                (0i32, ::core::ptr::null_mut(), 0usize)
                                                                                              },
                                                                                            };
                                                                                            (1i32, result2_0, result2_1, result2_2)
                                                                                          },
                                                                                          None => {
                                                                                            (0i32, 0i32, ::core::ptr::null_mut(), 0usize)
                                                                                          },
                                                                                        };
                                                                                        #[cfg(target_arch = "wasm32")]
                                                                                        #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                                        unsafe extern "C" {
                                                                                          #[link_name = "[method]gpu-render-bundle-encoder.finish"]
                                                                                          fn wit_import4(_: i32, _: i32, _: i32, _: *mut u8, _: usize, ) -> i32;
                                                                                        }

                                                                                        #[cfg(not(target_arch = "wasm32"))]
                                                                                        unsafe extern "C" fn wit_import4(_: i32, _: i32, _: i32, _: *mut u8, _: usize, ) -> i32 { unreachable!() }
                                                                                        let ret = wit_import4((self).handle() as i32, result3_0, result3_1, result3_2, result3_3);
                                                                                        GpuRenderBundle::from_handle(ret as u32)
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                  impl GpuRenderBundleEncoder {
                                                                                    #[allow(unused_unsafe, clippy::all)]
                                                                                    #[allow(async_fn_in_trait)]
                                                                                    pub fn label(&self,) -> _rt::String{
                                                                                      unsafe {

                                                                                        #[cfg_attr(target_pointer_width="64", repr(align(8)))]
                                                                                        #[cfg_attr(target_pointer_width="32", repr(align(4)))]
                                                                                        struct RetArea([::core::mem::MaybeUninit::<u8>; 2*::core::mem::size_of::<*const u8>()]);
                                                                                        let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2*::core::mem::size_of::<*const u8>()]);
                                                                                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                                                                                        #[cfg(target_arch = "wasm32")]
                                                                                        #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                                        unsafe extern "C" {
                                                                                          #[link_name = "[method]gpu-render-bundle-encoder.label"]
                                                                                          fn wit_import1(_: i32, _: *mut u8, );
                                                                                        }

                                                                                        #[cfg(not(target_arch = "wasm32"))]
                                                                                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, ) { unreachable!() }
                                                                                        wit_import1((self).handle() as i32, ptr0);
                                                                                        let l2 = *ptr0.add(0).cast::<*mut u8>();
                                                                                        let l3 = *ptr0.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
                                                                                        let len4 = l3;
                                                                                        let bytes4 = _rt::Vec::from_raw_parts(l2.cast(), len4, len4);
                                                                                        let result5 = _rt::string_lift(bytes4);
                                                                                        result5
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                  impl GpuRenderBundleEncoder {
                                                                                    #[allow(unused_unsafe, clippy::all)]
                                                                                    #[allow(async_fn_in_trait)]
                                                                                    pub fn set_label(&self,label: &str,) -> (){
                                                                                      unsafe {
                                                                                        let vec0 = label;
                                                                                        let ptr0 = vec0.as_ptr().cast::<u8>();
                                                                                        let len0 = vec0.len();

                                                                                        #[cfg(target_arch = "wasm32")]
                                                                                        #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                                        unsafe extern "C" {
                                                                                          #[link_name = "[method]gpu-render-bundle-encoder.set-label"]
                                                                                          fn wit_import1(_: i32, _: *mut u8, _: usize, );
                                                                                        }

                                                                                        #[cfg(not(target_arch = "wasm32"))]
                                                                                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, _: usize, ) { unreachable!() }
                                                                                        wit_import1((self).handle() as i32, ptr0.cast_mut(), len0);
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                  impl GpuRenderBundleEncoder {
                                                                                    #[allow(unused_unsafe, clippy::all)]
                                                                                    #[allow(async_fn_in_trait)]
                                                                                    pub fn push_debug_group(&self,group_label: &str,) -> (){
                                                                                      unsafe {
                                                                                        let vec0 = group_label;
                                                                                        let ptr0 = vec0.as_ptr().cast::<u8>();
                                                                                        let len0 = vec0.len();

                                                                                        #[cfg(target_arch = "wasm32")]
                                                                                        #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                                        unsafe extern "C" {
                                                                                          #[link_name = "[method]gpu-render-bundle-encoder.push-debug-group"]
                                                                                          fn wit_import1(_: i32, _: *mut u8, _: usize, );
                                                                                        }

                                                                                        #[cfg(not(target_arch = "wasm32"))]
                                                                                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, _: usize, ) { unreachable!() }
                                                                                        wit_import1((self).handle() as i32, ptr0.cast_mut(), len0);
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                  impl GpuRenderBundleEncoder {
                                                                                    #[allow(unused_unsafe, clippy::all)]
                                                                                    #[allow(async_fn_in_trait)]
                                                                                    pub fn pop_debug_group(&self,) -> (){
                                                                                      unsafe {

                                                                                        #[cfg(target_arch = "wasm32")]
                                                                                        #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                                        unsafe extern "C" {
                                                                                          #[link_name = "[method]gpu-render-bundle-encoder.pop-debug-group"]
                                                                                          fn wit_import0(_: i32, );
                                                                                        }

                                                                                        #[cfg(not(target_arch = "wasm32"))]
                                                                                        unsafe extern "C" fn wit_import0(_: i32, ) { unreachable!() }
                                                                                        wit_import0((self).handle() as i32);
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                  impl GpuRenderBundleEncoder {
                                                                                    #[allow(unused_unsafe, clippy::all)]
                                                                                    #[allow(async_fn_in_trait)]
                                                                                    pub fn insert_debug_marker(&self,marker_label: &str,) -> (){
                                                                                      unsafe {
                                                                                        let vec0 = marker_label;
                                                                                        let ptr0 = vec0.as_ptr().cast::<u8>();
                                                                                        let len0 = vec0.len();

                                                                                        #[cfg(target_arch = "wasm32")]
                                                                                        #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                                        unsafe extern "C" {
                                                                                          #[link_name = "[method]gpu-render-bundle-encoder.insert-debug-marker"]
                                                                                          fn wit_import1(_: i32, _: *mut u8, _: usize, );
                                                                                        }

                                                                                        #[cfg(not(target_arch = "wasm32"))]
                                                                                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, _: usize, ) { unreachable!() }
                                                                                        wit_import1((self).handle() as i32, ptr0.cast_mut(), len0);
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                  impl GpuRenderBundleEncoder {
                                                                                    #[allow(unused_unsafe, clippy::all)]
                                                                                    #[allow(async_fn_in_trait)]
                                                                                    pub fn set_bind_group(&self,index: GpuIndex32,bind_group: Option<&GpuBindGroup>,dynamic_offsets_data: Option<&[GpuBufferDynamicOffset]>,dynamic_offsets_data_start: Option<GpuSize64>,dynamic_offsets_data_length: Option<GpuSize32>,) -> Result<(),SetBindGroupError>{
                                                                                      unsafe {

                                                                                        #[cfg_attr(target_pointer_width="64", repr(align(8)))]
                                                                                        #[cfg_attr(target_pointer_width="32", repr(align(4)))]
                                                                                        struct RetArea([::core::mem::MaybeUninit::<u8>; 4*::core::mem::size_of::<*const u8>()]);
                                                                                        let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 4*::core::mem::size_of::<*const u8>()]);
                                                                                        let (result0_0,result0_1,) = match bind_group {
                                                                                          Some(e) => (1i32, (e).handle() as i32),
                                                                                          None => {
                                                                                            (0i32, 0i32)
                                                                                          },
                                                                                        };let (result2_0,result2_1,result2_2,) = match dynamic_offsets_data {
                                                                                          Some(e) => {
                                                                                            let vec1 = e;
                                                                                            let ptr1 = vec1.as_ptr().cast::<u8>();
                                                                                            let len1 = vec1.len();

                                                                                            (1i32, ptr1.cast_mut(), len1)
                                                                                          },
                                                                                          None => {
                                                                                            (0i32, ::core::ptr::null_mut(), 0usize)
                                                                                          },
                                                                                        };let (result3_0,result3_1,) = match dynamic_offsets_data_start {
                                                                                          Some(e) => (1i32, _rt::as_i64(e)),
                                                                                          None => {
                                                                                            (0i32, 0i64)
                                                                                          },
                                                                                        };let (result4_0,result4_1,) = match dynamic_offsets_data_length {
                                                                                          Some(e) => (1i32, _rt::as_i32(e)),
                                                                                          None => {
                                                                                            (0i32, 0i32)
                                                                                          },
                                                                                        };let ptr5 = ret_area.0.as_mut_ptr().cast::<u8>();
                                                                                        #[cfg(target_arch = "wasm32")]
                                                                                        #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                                        unsafe extern "C" {
                                                                                          #[link_name = "[method]gpu-render-bundle-encoder.set-bind-group"]
                                                                                          fn wit_import6(_: i32, _: i32, _: i32, _: i32, _: i32, _: *mut u8, _: usize, _: i32, _: i64, _: i32, _: i32, _: *mut u8, );
                                                                                        }

                                                                                        #[cfg(not(target_arch = "wasm32"))]
                                                                                        unsafe extern "C" fn wit_import6(_: i32, _: i32, _: i32, _: i32, _: i32, _: *mut u8, _: usize, _: i32, _: i64, _: i32, _: i32, _: *mut u8, ) { unreachable!() }
                                                                                        wit_import6((self).handle() as i32, _rt::as_i32(index), result0_0, result0_1, result2_0, result2_1, result2_2, result3_0, result3_1, result4_0, result4_1, ptr5);
                                                                                        let l7 = i32::from(*ptr5.add(0).cast::<u8>());
                                                                                        let result13 = match l7 {
                                                                                          0 => {
                                                                                            let e = ();
                                                                                            Ok(e)
                                                                                          }
                                                                                          1 => {
                                                                                            let e = {
                                                                                              let l8 = i32::from(*ptr5.add(::core::mem::size_of::<*const u8>()).cast::<u8>());
                                                                                              let v9 = match l8 {
                                                                                                n => {
                                                                                                  debug_assert_eq!(n, 0, "invalid enum discriminant");
                                                                                                  SetBindGroupErrorKind::RangeError
                                                                                                }
                                                                                              };
                                                                                              let l10 = *ptr5.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                                                                                              let l11 = *ptr5.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>();
                                                                                              let len12 = l11;
                                                                                              let bytes12 = _rt::Vec::from_raw_parts(l10.cast(), len12, len12);

                                                                                              SetBindGroupError{
                                                                                                kind: v9,
                                                                                                message: _rt::string_lift(bytes12),
                                                                                              }
                                                                                            };
                                                                                            Err(e)
                                                                                          }
                                                                                          _ => _rt::invalid_enum_discriminant(),
                                                                                        };
                                                                                        result13
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                  impl GpuRenderBundleEncoder {
                                                                                    #[allow(unused_unsafe, clippy::all)]
                                                                                    #[allow(async_fn_in_trait)]
                                                                                    pub fn set_pipeline(&self,pipeline: &GpuRenderPipeline,) -> (){
                                                                                      unsafe {

                                                                                        #[cfg(target_arch = "wasm32")]
                                                                                        #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                                        unsafe extern "C" {
                                                                                          #[link_name = "[method]gpu-render-bundle-encoder.set-pipeline"]
                                                                                          fn wit_import0(_: i32, _: i32, );
                                                                                        }

                                                                                        #[cfg(not(target_arch = "wasm32"))]
                                                                                        unsafe extern "C" fn wit_import0(_: i32, _: i32, ) { unreachable!() }
                                                                                        wit_import0((self).handle() as i32, (pipeline).handle() as i32);
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                  impl GpuRenderBundleEncoder {
                                                                                    #[allow(unused_unsafe, clippy::all)]
                                                                                    #[allow(async_fn_in_trait)]
                                                                                    pub fn set_index_buffer(&self,buffer: &GpuBuffer,index_format: GpuIndexFormat,offset: Option<GpuSize64>,size: Option<GpuSize64>,) -> (){
                                                                                      unsafe {
                                                                                        let (result0_0,result0_1,) = match offset {
                                                                                          Some(e) => (1i32, _rt::as_i64(e)),
                                                                                          None => {
                                                                                            (0i32, 0i64)
                                                                                          },
                                                                                        };let (result1_0,result1_1,) = match size {
                                                                                          Some(e) => (1i32, _rt::as_i64(e)),
                                                                                          None => {
                                                                                            (0i32, 0i64)
                                                                                          },
                                                                                        };
                                                                                        #[cfg(target_arch = "wasm32")]
                                                                                        #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                                        unsafe extern "C" {
                                                                                          #[link_name = "[method]gpu-render-bundle-encoder.set-index-buffer"]
                                                                                          fn wit_import2(_: i32, _: i32, _: i32, _: i32, _: i64, _: i32, _: i64, );
                                                                                        }

                                                                                        #[cfg(not(target_arch = "wasm32"))]
                                                                                        unsafe extern "C" fn wit_import2(_: i32, _: i32, _: i32, _: i32, _: i64, _: i32, _: i64, ) { unreachable!() }
                                                                                        wit_import2((self).handle() as i32, (buffer).handle() as i32, index_format.clone() as i32, result0_0, result0_1, result1_0, result1_1);
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                  impl GpuRenderBundleEncoder {
                                                                                    #[allow(unused_unsafe, clippy::all)]
                                                                                    #[allow(async_fn_in_trait)]
                                                                                    pub fn set_vertex_buffer(&self,slot: GpuIndex32,buffer: Option<&GpuBuffer>,offset: Option<GpuSize64>,size: Option<GpuSize64>,) -> (){
                                                                                      unsafe {
                                                                                        let (result0_0,result0_1,) = match buffer {
                                                                                          Some(e) => (1i32, (e).handle() as i32),
                                                                                          None => {
                                                                                            (0i32, 0i32)
                                                                                          },
                                                                                        };let (result1_0,result1_1,) = match offset {
                                                                                          Some(e) => (1i32, _rt::as_i64(e)),
                                                                                          None => {
                                                                                            (0i32, 0i64)
                                                                                          },
                                                                                        };let (result2_0,result2_1,) = match size {
                                                                                          Some(e) => (1i32, _rt::as_i64(e)),
                                                                                          None => {
                                                                                            (0i32, 0i64)
                                                                                          },
                                                                                        };
                                                                                        #[cfg(target_arch = "wasm32")]
                                                                                        #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                                        unsafe extern "C" {
                                                                                          #[link_name = "[method]gpu-render-bundle-encoder.set-vertex-buffer"]
                                                                                          fn wit_import3(_: i32, _: i32, _: i32, _: i32, _: i32, _: i64, _: i32, _: i64, );
                                                                                        }

                                                                                        #[cfg(not(target_arch = "wasm32"))]
                                                                                        unsafe extern "C" fn wit_import3(_: i32, _: i32, _: i32, _: i32, _: i32, _: i64, _: i32, _: i64, ) { unreachable!() }
                                                                                        wit_import3((self).handle() as i32, _rt::as_i32(slot), result0_0, result0_1, result1_0, result1_1, result2_0, result2_1);
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                  impl GpuRenderBundleEncoder {
                                                                                    #[allow(unused_unsafe, clippy::all)]
                                                                                    #[allow(async_fn_in_trait)]
                                                                                    pub fn draw(&self,vertex_count: GpuSize32,instance_count: Option<GpuSize32>,first_vertex: Option<GpuSize32>,first_instance: Option<GpuSize32>,) -> (){
                                                                                      unsafe {
                                                                                        let (result0_0,result0_1,) = match instance_count {
                                                                                          Some(e) => (1i32, _rt::as_i32(e)),
                                                                                          None => {
                                                                                            (0i32, 0i32)
                                                                                          },
                                                                                        };let (result1_0,result1_1,) = match first_vertex {
                                                                                          Some(e) => (1i32, _rt::as_i32(e)),
                                                                                          None => {
                                                                                            (0i32, 0i32)
                                                                                          },
                                                                                        };let (result2_0,result2_1,) = match first_instance {
                                                                                          Some(e) => (1i32, _rt::as_i32(e)),
                                                                                          None => {
                                                                                            (0i32, 0i32)
                                                                                          },
                                                                                        };
                                                                                        #[cfg(target_arch = "wasm32")]
                                                                                        #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                                        unsafe extern "C" {
                                                                                          #[link_name = "[method]gpu-render-bundle-encoder.draw"]
                                                                                          fn wit_import3(_: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, );
                                                                                        }

                                                                                        #[cfg(not(target_arch = "wasm32"))]
                                                                                        unsafe extern "C" fn wit_import3(_: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, ) { unreachable!() }
                                                                                        wit_import3((self).handle() as i32, _rt::as_i32(vertex_count), result0_0, result0_1, result1_0, result1_1, result2_0, result2_1);
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                  impl GpuRenderBundleEncoder {
                                                                                    #[allow(unused_unsafe, clippy::all)]
                                                                                    #[allow(async_fn_in_trait)]
                                                                                    pub fn draw_indexed(&self,index_count: GpuSize32,instance_count: Option<GpuSize32>,first_index: Option<GpuSize32>,base_vertex: Option<GpuSignedOffset32>,first_instance: Option<GpuSize32>,) -> (){
                                                                                      unsafe {
                                                                                        let (result0_0,result0_1,) = match instance_count {
                                                                                          Some(e) => (1i32, _rt::as_i32(e)),
                                                                                          None => {
                                                                                            (0i32, 0i32)
                                                                                          },
                                                                                        };let (result1_0,result1_1,) = match first_index {
                                                                                          Some(e) => (1i32, _rt::as_i32(e)),
                                                                                          None => {
                                                                                            (0i32, 0i32)
                                                                                          },
                                                                                        };let (result2_0,result2_1,) = match base_vertex {
                                                                                          Some(e) => (1i32, _rt::as_i32(e)),
                                                                                          None => {
                                                                                            (0i32, 0i32)
                                                                                          },
                                                                                        };let (result3_0,result3_1,) = match first_instance {
                                                                                          Some(e) => (1i32, _rt::as_i32(e)),
                                                                                          None => {
                                                                                            (0i32, 0i32)
                                                                                          },
                                                                                        };
                                                                                        #[cfg(target_arch = "wasm32")]
                                                                                        #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                                        unsafe extern "C" {
                                                                                          #[link_name = "[method]gpu-render-bundle-encoder.draw-indexed"]
                                                                                          fn wit_import4(_: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, );
                                                                                        }

                                                                                        #[cfg(not(target_arch = "wasm32"))]
                                                                                        unsafe extern "C" fn wit_import4(_: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, ) { unreachable!() }
                                                                                        wit_import4((self).handle() as i32, _rt::as_i32(index_count), result0_0, result0_1, result1_0, result1_1, result2_0, result2_1, result3_0, result3_1);
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                  impl GpuRenderBundleEncoder {
                                                                                    #[allow(unused_unsafe, clippy::all)]
                                                                                    #[allow(async_fn_in_trait)]
                                                                                    pub fn draw_indirect(&self,indirect_buffer: &GpuBuffer,indirect_offset: GpuSize64,) -> (){
                                                                                      unsafe {

                                                                                        #[cfg(target_arch = "wasm32")]
                                                                                        #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                                        unsafe extern "C" {
                                                                                          #[link_name = "[method]gpu-render-bundle-encoder.draw-indirect"]
                                                                                          fn wit_import0(_: i32, _: i32, _: i64, );
                                                                                        }

                                                                                        #[cfg(not(target_arch = "wasm32"))]
                                                                                        unsafe extern "C" fn wit_import0(_: i32, _: i32, _: i64, ) { unreachable!() }
                                                                                        wit_import0((self).handle() as i32, (indirect_buffer).handle() as i32, _rt::as_i64(indirect_offset));
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                  impl GpuRenderBundleEncoder {
                                                                                    #[allow(unused_unsafe, clippy::all)]
                                                                                    #[allow(async_fn_in_trait)]
                                                                                    pub fn draw_indexed_indirect(&self,indirect_buffer: &GpuBuffer,indirect_offset: GpuSize64,) -> (){
                                                                                      unsafe {

                                                                                        #[cfg(target_arch = "wasm32")]
                                                                                        #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                                        unsafe extern "C" {
                                                                                          #[link_name = "[method]gpu-render-bundle-encoder.draw-indexed-indirect"]
                                                                                          fn wit_import0(_: i32, _: i32, _: i64, );
                                                                                        }

                                                                                        #[cfg(not(target_arch = "wasm32"))]
                                                                                        unsafe extern "C" fn wit_import0(_: i32, _: i32, _: i64, ) { unreachable!() }
                                                                                        wit_import0((self).handle() as i32, (indirect_buffer).handle() as i32, _rt::as_i64(indirect_offset));
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                  impl GpuQueue {
                                                                                    #[allow(unused_unsafe, clippy::all)]
                                                                                    #[allow(async_fn_in_trait)]
                                                                                    pub fn submit(&self,command_buffers: &[&GpuCommandBuffer],) -> (){
                                                                                      unsafe {
                                                                                        let vec0 = command_buffers;
                                                                                        let len0 = vec0.len();
                                                                                        let layout0 = _rt::alloc::Layout::from_size_align(vec0.len() * 4, 4).unwrap();
                                                                                        let (result0, _cleanup0) = wit_bindgen::rt::Cleanup::new(layout0);for (i, e) in vec0.into_iter().enumerate() {
                                                                                          let base = result0.add(i * 4);
                                                                                          {
                                                                                            *base.add(0).cast::<i32>() = (e).handle() as i32;
                                                                                          }
                                                                                        }

                                                                                        #[cfg(target_arch = "wasm32")]
                                                                                        #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                                        unsafe extern "C" {
                                                                                          #[link_name = "[method]gpu-queue.submit"]
                                                                                          fn wit_import1(_: i32, _: *mut u8, _: usize, );
                                                                                        }

                                                                                        #[cfg(not(target_arch = "wasm32"))]
                                                                                        unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, _: usize, ) { unreachable!() }
                                                                                        wit_import1((self).handle() as i32, result0, len0);
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                  impl GpuQueue {
                                                                                    #[allow(unused_unsafe, clippy::all)]
                                                                                    #[allow(async_fn_in_trait)]
                                                                                    pub fn on_submitted_work_done(&self,) -> (){
                                                                                      unsafe {

                                                                                        #[cfg(target_arch = "wasm32")]
                                                                                        #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                                        unsafe extern "C" {
                                                                                          #[link_name = "[method]gpu-queue.on-submitted-work-done"]
                                                                                          fn wit_import0(_: i32, );
                                                                                        }

                                                                                        #[cfg(not(target_arch = "wasm32"))]
                                                                                        unsafe extern "C" fn wit_import0(_: i32, ) { unreachable!() }
                                                                                        wit_import0((self).handle() as i32);
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                  impl GpuQueue {
                                                                                    #[allow(unused_unsafe, clippy::all)]
                                                                                    #[allow(async_fn_in_trait)]
                                                                                    pub fn write_buffer_with_copy(&self,buffer: &GpuBuffer,buffer_offset: GpuSize64,data: &[u8],data_offset: Option<GpuSize64>,size: Option<GpuSize64>,) -> Result<(),WriteBufferError>{
                                                                                      unsafe {

                                                                                        #[cfg_attr(target_pointer_width="64", repr(align(8)))]
                                                                                        #[cfg_attr(target_pointer_width="32", repr(align(4)))]
                                                                                        struct RetArea([::core::mem::MaybeUninit::<u8>; 4*::core::mem::size_of::<*const u8>()]);
                                                                                        let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 4*::core::mem::size_of::<*const u8>()]);
                                                                                        let vec0 = data;
                                                                                        let ptr0 = vec0.as_ptr().cast::<u8>();
                                                                                        let len0 = vec0.len();
                                                                                        let (result1_0,result1_1,) = match data_offset {
                                                                                          Some(e) => (1i32, _rt::as_i64(e)),
                                                                                          None => {
                                                                                            (0i32, 0i64)
                                                                                          },
                                                                                        };let (result2_0,result2_1,) = match size {
                                                                                          Some(e) => (1i32, _rt::as_i64(e)),
                                                                                          None => {
                                                                                            (0i32, 0i64)
                                                                                          },
                                                                                        };let ptr3 = ret_area.0.as_mut_ptr().cast::<u8>();
                                                                                        #[cfg(target_arch = "wasm32")]
                                                                                        #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                                        unsafe extern "C" {
                                                                                          #[link_name = "[method]gpu-queue.write-buffer-with-copy"]
                                                                                          fn wit_import4(_: i32, _: i32, _: i64, _: *mut u8, _: usize, _: i32, _: i64, _: i32, _: i64, _: *mut u8, );
                                                                                        }

                                                                                        #[cfg(not(target_arch = "wasm32"))]
                                                                                        unsafe extern "C" fn wit_import4(_: i32, _: i32, _: i64, _: *mut u8, _: usize, _: i32, _: i64, _: i32, _: i64, _: *mut u8, ) { unreachable!() }
                                                                                        wit_import4((self).handle() as i32, (buffer).handle() as i32, _rt::as_i64(buffer_offset), ptr0.cast_mut(), len0, result1_0, result1_1, result2_0, result2_1, ptr3);
                                                                                        let l5 = i32::from(*ptr3.add(0).cast::<u8>());
                                                                                        let result11 = match l5 {
                                                                                          0 => {
                                                                                            let e = ();
                                                                                            Ok(e)
                                                                                          }
                                                                                          1 => {
                                                                                            let e = {
                                                                                              let l6 = i32::from(*ptr3.add(::core::mem::size_of::<*const u8>()).cast::<u8>());
                                                                                              let v7 = match l6 {
                                                                                                n => {
                                                                                                  debug_assert_eq!(n, 0, "invalid enum discriminant");
                                                                                                  WriteBufferErrorKind::OperationError
                                                                                                }
                                                                                              };
                                                                                              let l8 = *ptr3.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                                                                                              let l9 = *ptr3.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>();
                                                                                              let len10 = l9;
                                                                                              let bytes10 = _rt::Vec::from_raw_parts(l8.cast(), len10, len10);

                                                                                              WriteBufferError{
                                                                                                kind: v7,
                                                                                                message: _rt::string_lift(bytes10),
                                                                                              }
                                                                                            };
                                                                                            Err(e)
                                                                                          }
                                                                                          _ => _rt::invalid_enum_discriminant(),
                                                                                        };
                                                                                        result11
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                  impl GpuQueue {
                                                                                    #[allow(unused_unsafe, clippy::all)]
                                                                                    #[allow(async_fn_in_trait)]
                                                                                    pub fn write_texture_with_copy(&self,destination: &GpuTexelCopyTextureInfo<'_,>,data: &[u8],data_layout: GpuTexelCopyBufferLayout,size: GpuExtent3D,) -> (){
                                                                                      unsafe {

                                                                                        #[repr(align(8))]
                                                                                        struct RetArea([::core::mem::MaybeUninit::<u8>; 104+2*::core::mem::size_of::<*const u8>()]);
                                                                                        let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 104+2*::core::mem::size_of::<*const u8>()]);
                                                                                        let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();*ptr0.add(0).cast::<i32>() = (self).handle() as i32;
                                                                                        let GpuTexelCopyTextureInfo{ texture:texture1, mip_level:mip_level1, origin:origin1, aspect:aspect1, } = destination;
                                                                                        *ptr0.add(4).cast::<i32>() = (texture1).handle() as i32;
                                                                                        match mip_level1 {
                                                                                          Some(e) => {
                                                                                            *ptr0.add(8).cast::<u8>() = (1i32) as u8;
                                                                                            *ptr0.add(12).cast::<i32>() = _rt::as_i32(e);
                                                                                          },
                                                                                          None => {
                                                                                            {
                                                                                              *ptr0.add(8).cast::<u8>() = (0i32) as u8;
                                                                                            }
                                                                                          },
                                                                                        };match origin1 {
                                                                                          Some(e) => {
                                                                                            *ptr0.add(16).cast::<u8>() = (1i32) as u8;
                                                                                            let GpuOrigin3D{ x:x2, y:y2, z:z2, } = e;
                                                                                            match x2 {
                                                                                              Some(e) => {
                                                                                                *ptr0.add(20).cast::<u8>() = (1i32) as u8;
                                                                                                *ptr0.add(24).cast::<i32>() = _rt::as_i32(e);
                                                                                              },
                                                                                              None => {
                                                                                                {
                                                                                                  *ptr0.add(20).cast::<u8>() = (0i32) as u8;
                                                                                                }
                                                                                              },
                                                                                            };match y2 {
                                                                                              Some(e) => {
                                                                                                *ptr0.add(28).cast::<u8>() = (1i32) as u8;
                                                                                                *ptr0.add(32).cast::<i32>() = _rt::as_i32(e);
                                                                                              },
                                                                                              None => {
                                                                                                {
                                                                                                  *ptr0.add(28).cast::<u8>() = (0i32) as u8;
                                                                                                }
                                                                                              },
                                                                                            };match z2 {
                                                                                              Some(e) => {
                                                                                                *ptr0.add(36).cast::<u8>() = (1i32) as u8;
                                                                                                *ptr0.add(40).cast::<i32>() = _rt::as_i32(e);
                                                                                              },
                                                                                              None => {
                                                                                                {
                                                                                                  *ptr0.add(36).cast::<u8>() = (0i32) as u8;
                                                                                                }
                                                                                              },
                                                                                            };},
                                                                                            None => {
                                                                                              {
                                                                                                *ptr0.add(16).cast::<u8>() = (0i32) as u8;
                                                                                              }
                                                                                            },
                                                                                          };match aspect1 {
                                                                                            Some(e) => {
                                                                                              *ptr0.add(44).cast::<u8>() = (1i32) as u8;
                                                                                              *ptr0.add(45).cast::<u8>() = (e.clone() as i32) as u8;
                                                                                            },
                                                                                            None => {
                                                                                              {
                                                                                                *ptr0.add(44).cast::<u8>() = (0i32) as u8;
                                                                                              }
                                                                                            },
                                                                                          };let vec3 = data;
                                                                                          let ptr3 = vec3.as_ptr().cast::<u8>();
                                                                                          let len3 = vec3.len();
                                                                                          *ptr0.add(48+1*::core::mem::size_of::<*const u8>()).cast::<usize>() = len3;
                                                                                          *ptr0.add(48).cast::<*mut u8>() = ptr3.cast_mut();
                                                                                          let GpuTexelCopyBufferLayout{ offset:offset4, bytes_per_row:bytes_per_row4, rows_per_image:rows_per_image4, } = data_layout;
                                                                                          match offset4 {
                                                                                            Some(e) => {
                                                                                              *ptr0.add(48+2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                                                                              *ptr0.add(56+2*::core::mem::size_of::<*const u8>()).cast::<i64>() = _rt::as_i64(e);
                                                                                            },
                                                                                            None => {
                                                                                              {
                                                                                                *ptr0.add(48+2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                                                                              }
                                                                                            },
                                                                                          };match bytes_per_row4 {
                                                                                            Some(e) => {
                                                                                              *ptr0.add(64+2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                                                                              *ptr0.add(68+2*::core::mem::size_of::<*const u8>()).cast::<i32>() = _rt::as_i32(e);
                                                                                            },
                                                                                            None => {
                                                                                              {
                                                                                                *ptr0.add(64+2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                                                                              }
                                                                                            },
                                                                                          };match rows_per_image4 {
                                                                                            Some(e) => {
                                                                                              *ptr0.add(72+2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                                                                              *ptr0.add(76+2*::core::mem::size_of::<*const u8>()).cast::<i32>() = _rt::as_i32(e);
                                                                                            },
                                                                                            None => {
                                                                                              {
                                                                                                *ptr0.add(72+2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                                                                              }
                                                                                            },
                                                                                          };let GpuExtent3D{ width:width5, height:height5, depth_or_array_layers:depth_or_array_layers5, } = size;
                                                                                          *ptr0.add(80+2*::core::mem::size_of::<*const u8>()).cast::<i32>() = _rt::as_i32(width5);
                                                                                          match height5 {
                                                                                            Some(e) => {
                                                                                              *ptr0.add(84+2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                                                                              *ptr0.add(88+2*::core::mem::size_of::<*const u8>()).cast::<i32>() = _rt::as_i32(e);
                                                                                            },
                                                                                            None => {
                                                                                              {
                                                                                                *ptr0.add(84+2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                                                                              }
                                                                                            },
                                                                                          };match depth_or_array_layers5 {
                                                                                            Some(e) => {
                                                                                              *ptr0.add(92+2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                                                                              *ptr0.add(96+2*::core::mem::size_of::<*const u8>()).cast::<i32>() = _rt::as_i32(e);
                                                                                            },
                                                                                            None => {
                                                                                              {
                                                                                                *ptr0.add(92+2*::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                                                                              }
                                                                                            },
                                                                                          };
                                                                                          #[cfg(target_arch = "wasm32")]
                                                                                          #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                                          unsafe extern "C" {
                                                                                            #[link_name = "[method]gpu-queue.write-texture-with-copy"]
                                                                                            fn wit_import6(_: *mut u8, );
                                                                                          }

                                                                                          #[cfg(not(target_arch = "wasm32"))]
                                                                                          unsafe extern "C" fn wit_import6(_: *mut u8, ) { unreachable!() }
                                                                                          wit_import6(ptr0);
                                                                                        }
                                                                                      }
                                                                                    }
                                                                                    impl GpuQueue {
                                                                                      #[allow(unused_unsafe, clippy::all)]
                                                                                      #[allow(async_fn_in_trait)]
                                                                                      pub fn label(&self,) -> _rt::String{
                                                                                        unsafe {

                                                                                          #[cfg_attr(target_pointer_width="64", repr(align(8)))]
                                                                                          #[cfg_attr(target_pointer_width="32", repr(align(4)))]
                                                                                          struct RetArea([::core::mem::MaybeUninit::<u8>; 2*::core::mem::size_of::<*const u8>()]);
                                                                                          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2*::core::mem::size_of::<*const u8>()]);
                                                                                          let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                                                                                          #[cfg(target_arch = "wasm32")]
                                                                                          #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                                          unsafe extern "C" {
                                                                                            #[link_name = "[method]gpu-queue.label"]
                                                                                            fn wit_import1(_: i32, _: *mut u8, );
                                                                                          }

                                                                                          #[cfg(not(target_arch = "wasm32"))]
                                                                                          unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, ) { unreachable!() }
                                                                                          wit_import1((self).handle() as i32, ptr0);
                                                                                          let l2 = *ptr0.add(0).cast::<*mut u8>();
                                                                                          let l3 = *ptr0.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
                                                                                          let len4 = l3;
                                                                                          let bytes4 = _rt::Vec::from_raw_parts(l2.cast(), len4, len4);
                                                                                          let result5 = _rt::string_lift(bytes4);
                                                                                          result5
                                                                                        }
                                                                                      }
                                                                                    }
                                                                                    impl GpuQueue {
                                                                                      #[allow(unused_unsafe, clippy::all)]
                                                                                      #[allow(async_fn_in_trait)]
                                                                                      pub fn set_label(&self,label: &str,) -> (){
                                                                                        unsafe {
                                                                                          let vec0 = label;
                                                                                          let ptr0 = vec0.as_ptr().cast::<u8>();
                                                                                          let len0 = vec0.len();

                                                                                          #[cfg(target_arch = "wasm32")]
                                                                                          #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                                          unsafe extern "C" {
                                                                                            #[link_name = "[method]gpu-queue.set-label"]
                                                                                            fn wit_import1(_: i32, _: *mut u8, _: usize, );
                                                                                          }

                                                                                          #[cfg(not(target_arch = "wasm32"))]
                                                                                          unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, _: usize, ) { unreachable!() }
                                                                                          wit_import1((self).handle() as i32, ptr0.cast_mut(), len0);
                                                                                        }
                                                                                      }
                                                                                    }
                                                                                    impl GpuQuerySet {
                                                                                      #[allow(unused_unsafe, clippy::all)]
                                                                                      #[allow(async_fn_in_trait)]
                                                                                      pub fn destroy(&self,) -> (){
                                                                                        unsafe {

                                                                                          #[cfg(target_arch = "wasm32")]
                                                                                          #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                                          unsafe extern "C" {
                                                                                            #[link_name = "[method]gpu-query-set.destroy"]
                                                                                            fn wit_import0(_: i32, );
                                                                                          }

                                                                                          #[cfg(not(target_arch = "wasm32"))]
                                                                                          unsafe extern "C" fn wit_import0(_: i32, ) { unreachable!() }
                                                                                          wit_import0((self).handle() as i32);
                                                                                        }
                                                                                      }
                                                                                    }
                                                                                    impl GpuQuerySet {
                                                                                      #[allow(unused_unsafe, clippy::all)]
                                                                                      #[allow(async_fn_in_trait)]
                                                                                      pub fn type_(&self,) -> GpuQueryType{
                                                                                        unsafe {

                                                                                          #[cfg(target_arch = "wasm32")]
                                                                                          #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                                          unsafe extern "C" {
                                                                                            #[link_name = "[method]gpu-query-set.type"]
                                                                                            fn wit_import0(_: i32, ) -> i32;
                                                                                          }

                                                                                          #[cfg(not(target_arch = "wasm32"))]
                                                                                          unsafe extern "C" fn wit_import0(_: i32, ) -> i32 { unreachable!() }
                                                                                          let ret = wit_import0((self).handle() as i32);
                                                                                          GpuQueryType::_lift(ret as u8)
                                                                                        }
                                                                                      }
                                                                                    }
                                                                                    impl GpuQuerySet {
                                                                                      #[allow(unused_unsafe, clippy::all)]
                                                                                      #[allow(async_fn_in_trait)]
                                                                                      pub fn count(&self,) -> GpuSize32Out{
                                                                                        unsafe {

                                                                                          #[cfg(target_arch = "wasm32")]
                                                                                          #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                                          unsafe extern "C" {
                                                                                            #[link_name = "[method]gpu-query-set.count"]
                                                                                            fn wit_import0(_: i32, ) -> i32;
                                                                                          }

                                                                                          #[cfg(not(target_arch = "wasm32"))]
                                                                                          unsafe extern "C" fn wit_import0(_: i32, ) -> i32 { unreachable!() }
                                                                                          let ret = wit_import0((self).handle() as i32);
                                                                                          ret as u32
                                                                                        }
                                                                                      }
                                                                                    }
                                                                                    impl GpuQuerySet {
                                                                                      #[allow(unused_unsafe, clippy::all)]
                                                                                      #[allow(async_fn_in_trait)]
                                                                                      pub fn label(&self,) -> _rt::String{
                                                                                        unsafe {

                                                                                          #[cfg_attr(target_pointer_width="64", repr(align(8)))]
                                                                                          #[cfg_attr(target_pointer_width="32", repr(align(4)))]
                                                                                          struct RetArea([::core::mem::MaybeUninit::<u8>; 2*::core::mem::size_of::<*const u8>()]);
                                                                                          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2*::core::mem::size_of::<*const u8>()]);
                                                                                          let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                                                                                          #[cfg(target_arch = "wasm32")]
                                                                                          #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                                          unsafe extern "C" {
                                                                                            #[link_name = "[method]gpu-query-set.label"]
                                                                                            fn wit_import1(_: i32, _: *mut u8, );
                                                                                          }

                                                                                          #[cfg(not(target_arch = "wasm32"))]
                                                                                          unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, ) { unreachable!() }
                                                                                          wit_import1((self).handle() as i32, ptr0);
                                                                                          let l2 = *ptr0.add(0).cast::<*mut u8>();
                                                                                          let l3 = *ptr0.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
                                                                                          let len4 = l3;
                                                                                          let bytes4 = _rt::Vec::from_raw_parts(l2.cast(), len4, len4);
                                                                                          let result5 = _rt::string_lift(bytes4);
                                                                                          result5
                                                                                        }
                                                                                      }
                                                                                    }
                                                                                    impl GpuQuerySet {
                                                                                      #[allow(unused_unsafe, clippy::all)]
                                                                                      #[allow(async_fn_in_trait)]
                                                                                      pub fn set_label(&self,label: &str,) -> (){
                                                                                        unsafe {
                                                                                          let vec0 = label;
                                                                                          let ptr0 = vec0.as_ptr().cast::<u8>();
                                                                                          let len0 = vec0.len();

                                                                                          #[cfg(target_arch = "wasm32")]
                                                                                          #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                                          unsafe extern "C" {
                                                                                            #[link_name = "[method]gpu-query-set.set-label"]
                                                                                            fn wit_import1(_: i32, _: *mut u8, _: usize, );
                                                                                          }

                                                                                          #[cfg(not(target_arch = "wasm32"))]
                                                                                          unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, _: usize, ) { unreachable!() }
                                                                                          wit_import1((self).handle() as i32, ptr0.cast_mut(), len0);
                                                                                        }
                                                                                      }
                                                                                    }
                                                                                    impl GpuCanvasContext {
                                                                                      #[allow(unused_unsafe, clippy::all)]
                                                                                      #[allow(async_fn_in_trait)]
                                                                                      pub fn configure(&self,configuration: &GpuCanvasConfiguration<'_,>,) -> (){
                                                                                        unsafe {
                                                                                          let mut cleanup_list = _rt::Vec::new();
                                                                                          let GpuCanvasConfiguration{ device:device0, format:format0, usage:usage0, view_formats:view_formats0, color_space:color_space0, tone_mapping:tone_mapping0, alpha_mode:alpha_mode0, } = configuration;
                                                                                          let (result1_0,result1_1,) = match usage0 {
                                                                                            Some(e) => (1i32, _rt::as_i32(e)),
                                                                                            None => {
                                                                                              (0i32, 0i32)
                                                                                            },
                                                                                          };let (result3_0,result3_1,result3_2,) = match view_formats0 {
                                                                                            Some(e) => {
                                                                                              let vec2 = e;
                                                                                              let len2 = vec2.len();
                                                                                              let layout2 = _rt::alloc::Layout::from_size_align(vec2.len() * 1, 1).unwrap();
                                                                                              let (result2, _cleanup2) = wit_bindgen::rt::Cleanup::new(layout2);cleanup_list.extend(_cleanup2);
                                                                                              for (i, e) in vec2.into_iter().enumerate() {
                                                                                                let base = result2.add(i * 1);
                                                                                                {
                                                                                                  *base.add(0).cast::<u8>() = (e.clone() as i32) as u8;
                                                                                                }
                                                                                              }

                                                                                              (1i32, result2, len2)
                                                                                            },
                                                                                            None => {
                                                                                              (0i32, ::core::ptr::null_mut(), 0usize)
                                                                                            },
                                                                                          };let (result4_0,result4_1,) = match color_space0 {
                                                                                            Some(e) => (1i32, e.clone() as i32),
                                                                                            None => {
                                                                                              (0i32, 0i32)
                                                                                            },
                                                                                          };let (result7_0,result7_1,result7_2,) = match tone_mapping0 {
                                                                                            Some(e) => {
                                                                                              let GpuCanvasToneMapping{ mode:mode5, } = e;
                                                                                              let (result6_0,result6_1,) = match mode5 {
                                                                                                Some(e) => (1i32, e.clone() as i32),
                                                                                                None => {
                                                                                                  (0i32, 0i32)
                                                                                                },
                                                                                              };
                                                                                              (1i32, result6_0, result6_1)
                                                                                            },
                                                                                            None => {
                                                                                              (0i32, 0i32, 0i32)
                                                                                            },
                                                                                          };let (result8_0,result8_1,) = match alpha_mode0 {
                                                                                            Some(e) => (1i32, e.clone() as i32),
                                                                                            None => {
                                                                                              (0i32, 0i32)
                                                                                            },
                                                                                          };
                                                                                          #[cfg(target_arch = "wasm32")]
                                                                                          #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                                          unsafe extern "C" {
                                                                                            #[link_name = "[method]gpu-canvas-context.configure"]
                                                                                            fn wit_import9(_: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: *mut u8, _: usize, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, );
                                                                                          }

                                                                                          #[cfg(not(target_arch = "wasm32"))]
                                                                                          unsafe extern "C" fn wit_import9(_: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: *mut u8, _: usize, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, ) { unreachable!() }
                                                                                          wit_import9((self).handle() as i32, (device0).handle() as i32, format0.clone() as i32, result1_0, result1_1, result3_0, result3_1, result3_2, result4_0, result4_1, result7_0, result7_1, result7_2, result8_0, result8_1);
                                                                                        }
                                                                                      }
                                                                                    }
                                                                                    impl GpuCanvasContext {
                                                                                      #[allow(unused_unsafe, clippy::all)]
                                                                                      #[allow(async_fn_in_trait)]
                                                                                      pub fn unconfigure(&self,) -> (){
                                                                                        unsafe {

                                                                                          #[cfg(target_arch = "wasm32")]
                                                                                          #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                                          unsafe extern "C" {
                                                                                            #[link_name = "[method]gpu-canvas-context.unconfigure"]
                                                                                            fn wit_import0(_: i32, );
                                                                                          }

                                                                                          #[cfg(not(target_arch = "wasm32"))]
                                                                                          unsafe extern "C" fn wit_import0(_: i32, ) { unreachable!() }
                                                                                          wit_import0((self).handle() as i32);
                                                                                        }
                                                                                      }
                                                                                    }
                                                                                    impl GpuCanvasContext {
                                                                                      #[allow(unused_unsafe, clippy::all)]
                                                                                      #[allow(async_fn_in_trait)]
                                                                                      pub fn get_configuration(&self,) -> Option<GpuCanvasConfigurationOwned>{
                                                                                        unsafe {

                                                                                          #[cfg_attr(target_pointer_width="64", repr(align(8)))]
                                                                                          #[cfg_attr(target_pointer_width="32", repr(align(4)))]
                                                                                          struct RetArea([::core::mem::MaybeUninit::<u8>; 24+4*::core::mem::size_of::<*const u8>()]);
                                                                                          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 24+4*::core::mem::size_of::<*const u8>()]);
                                                                                          let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                                                                                          #[cfg(target_arch = "wasm32")]
                                                                                          #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                                          unsafe extern "C" {
                                                                                            #[link_name = "[method]gpu-canvas-context.get-configuration"]
                                                                                            fn wit_import1(_: i32, _: *mut u8, );
                                                                                          }

                                                                                          #[cfg(not(target_arch = "wasm32"))]
                                                                                          unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, ) { unreachable!() }
                                                                                          wit_import1((self).handle() as i32, ptr0);
                                                                                          let l2 = i32::from(*ptr0.add(0).cast::<u8>());
                                                                                          let result19 = match l2 {
                                                                                            0 => None,
                                                                                            1 => {
                                                                                              let e = {
                                                                                                let l3 = *ptr0.add(::core::mem::size_of::<*const u8>()).cast::<i32>();
                                                                                                let l4 = i32::from(*ptr0.add(4+1*::core::mem::size_of::<*const u8>()).cast::<u8>());
                                                                                                let l5 = i32::from(*ptr0.add(8+1*::core::mem::size_of::<*const u8>()).cast::<u8>());
                                                                                                let l7 = i32::from(*ptr0.add(16+1*::core::mem::size_of::<*const u8>()).cast::<u8>());
                                                                                                let l12 = i32::from(*ptr0.add(16+4*::core::mem::size_of::<*const u8>()).cast::<u8>());
                                                                                                let l14 = i32::from(*ptr0.add(18+4*::core::mem::size_of::<*const u8>()).cast::<u8>());
                                                                                                let l17 = i32::from(*ptr0.add(21+4*::core::mem::size_of::<*const u8>()).cast::<u8>());

                                                                                                GpuCanvasConfigurationOwned{
                                                                                                  device: GpuDevice::from_handle(l3 as u32),
                                                                                                  format: GpuTextureFormat::_lift(l4 as u8),
                                                                                                  usage: match l5 {
                                                                                                    0 => None,
                                                                                                    1 => {
                                                                                                      let e = {
                                                                                                        let l6 = *ptr0.add(12+1*::core::mem::size_of::<*const u8>()).cast::<i32>();

                                                                                                        l6 as u32
                                                                                                      };
                                                                                                      Some(e)
                                                                                                    }
                                                                                                    _ => _rt::invalid_enum_discriminant(),
                                                                                                  },
                                                                                                  view_formats: match l7 {
                                                                                                    0 => None,
                                                                                                    1 => {
                                                                                                      let e = {
                                                                                                        let l8 = *ptr0.add(16+2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                                                                                                        let l9 = *ptr0.add(16+3*::core::mem::size_of::<*const u8>()).cast::<usize>();
                                                                                                        let base11 = l8;
                                                                                                        let len11 = l9;
                                                                                                        let mut result11 = _rt::Vec::with_capacity(len11);
                                                                                                        for i in 0..len11 {
                                                                                                          let base = base11.add(i * 1);
                                                                                                          let e11 = {
                                                                                                            let l10 = i32::from(*base.add(0).cast::<u8>());

                                                                                                            GpuTextureFormat::_lift(l10 as u8)
                                                                                                          };
                                                                                                          result11.push(e11);
                                                                                                        }
                                                                                                        _rt::cabi_dealloc(base11, len11 * 1, 1);

                                                                                                        result11
                                                                                                      };
                                                                                                      Some(e)
                                                                                                    }
                                                                                                    _ => _rt::invalid_enum_discriminant(),
                                                                                                  },
                                                                                                  color_space: match l12 {
                                                                                                    0 => None,
                                                                                                    1 => {
                                                                                                      let e = {
                                                                                                        let l13 = i32::from(*ptr0.add(17+4*::core::mem::size_of::<*const u8>()).cast::<u8>());

                                                                                                        PredefinedColorSpace::_lift(l13 as u8)
                                                                                                      };
                                                                                                      Some(e)
                                                                                                    }
                                                                                                    _ => _rt::invalid_enum_discriminant(),
                                                                                                  },
                                                                                                  tone_mapping: match l14 {
                                                                                                    0 => None,
                                                                                                    1 => {
                                                                                                      let e = {
                                                                                                        let l15 = i32::from(*ptr0.add(19+4*::core::mem::size_of::<*const u8>()).cast::<u8>());

                                                                                                        GpuCanvasToneMapping{
                                                                                                          mode: match l15 {
                                                                                                            0 => None,
                                                                                                            1 => {
                                                                                                              let e = {
                                                                                                                let l16 = i32::from(*ptr0.add(20+4*::core::mem::size_of::<*const u8>()).cast::<u8>());

                                                                                                                GpuCanvasToneMappingMode::_lift(l16 as u8)
                                                                                                              };
                                                                                                              Some(e)
                                                                                                            }
                                                                                                            _ => _rt::invalid_enum_discriminant(),
                                                                                                          },
                                                                                                        }
                                                                                                      };
                                                                                                      Some(e)
                                                                                                    }
                                                                                                    _ => _rt::invalid_enum_discriminant(),
                                                                                                  },
                                                                                                  alpha_mode: match l17 {
                                                                                                    0 => None,
                                                                                                    1 => {
                                                                                                      let e = {
                                                                                                        let l18 = i32::from(*ptr0.add(22+4*::core::mem::size_of::<*const u8>()).cast::<u8>());

                                                                                                        GpuCanvasAlphaMode::_lift(l18 as u8)
                                                                                                      };
                                                                                                      Some(e)
                                                                                                    }
                                                                                                    _ => _rt::invalid_enum_discriminant(),
                                                                                                  },
                                                                                                }
                                                                                              };
                                                                                              Some(e)
                                                                                            }
                                                                                            _ => _rt::invalid_enum_discriminant(),
                                                                                          };
                                                                                          result19
                                                                                        }
                                                                                      }
                                                                                    }
                                                                                    impl GpuCanvasContext {
                                                                                      #[allow(unused_unsafe, clippy::all)]
                                                                                      #[allow(async_fn_in_trait)]
                                                                                      pub fn get_current_texture(&self,) -> GpuTexture{
                                                                                        unsafe {

                                                                                          #[cfg(target_arch = "wasm32")]
                                                                                          #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                                          unsafe extern "C" {
                                                                                            #[link_name = "[method]gpu-canvas-context.get-current-texture"]
                                                                                            fn wit_import0(_: i32, ) -> i32;
                                                                                          }

                                                                                          #[cfg(not(target_arch = "wasm32"))]
                                                                                          unsafe extern "C" fn wit_import0(_: i32, ) -> i32 { unreachable!() }
                                                                                          let ret = wit_import0((self).handle() as i32);
                                                                                          GpuTexture::from_handle(ret as u32)
                                                                                        }
                                                                                      }
                                                                                    }
                                                                                    impl GpuDeviceLostInfo {
                                                                                      #[allow(unused_unsafe, clippy::all)]
                                                                                      #[allow(async_fn_in_trait)]
                                                                                      pub fn reason(&self,) -> GpuDeviceLostReason{
                                                                                        unsafe {

                                                                                          #[cfg(target_arch = "wasm32")]
                                                                                          #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                                          unsafe extern "C" {
                                                                                            #[link_name = "[method]gpu-device-lost-info.reason"]
                                                                                            fn wit_import0(_: i32, ) -> i32;
                                                                                          }

                                                                                          #[cfg(not(target_arch = "wasm32"))]
                                                                                          unsafe extern "C" fn wit_import0(_: i32, ) -> i32 { unreachable!() }
                                                                                          let ret = wit_import0((self).handle() as i32);
                                                                                          GpuDeviceLostReason::_lift(ret as u8)
                                                                                        }
                                                                                      }
                                                                                    }
                                                                                    impl GpuDeviceLostInfo {
                                                                                      #[allow(unused_unsafe, clippy::all)]
                                                                                      #[allow(async_fn_in_trait)]
                                                                                      pub fn message(&self,) -> _rt::String{
                                                                                        unsafe {

                                                                                          #[cfg_attr(target_pointer_width="64", repr(align(8)))]
                                                                                          #[cfg_attr(target_pointer_width="32", repr(align(4)))]
                                                                                          struct RetArea([::core::mem::MaybeUninit::<u8>; 2*::core::mem::size_of::<*const u8>()]);
                                                                                          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2*::core::mem::size_of::<*const u8>()]);
                                                                                          let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                                                                                          #[cfg(target_arch = "wasm32")]
                                                                                          #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                                          unsafe extern "C" {
                                                                                            #[link_name = "[method]gpu-device-lost-info.message"]
                                                                                            fn wit_import1(_: i32, _: *mut u8, );
                                                                                          }

                                                                                          #[cfg(not(target_arch = "wasm32"))]
                                                                                          unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, ) { unreachable!() }
                                                                                          wit_import1((self).handle() as i32, ptr0);
                                                                                          let l2 = *ptr0.add(0).cast::<*mut u8>();
                                                                                          let l3 = *ptr0.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
                                                                                          let len4 = l3;
                                                                                          let bytes4 = _rt::Vec::from_raw_parts(l2.cast(), len4, len4);
                                                                                          let result5 = _rt::string_lift(bytes4);
                                                                                          result5
                                                                                        }
                                                                                      }
                                                                                    }
                                                                                    impl GpuError {
                                                                                      #[allow(unused_unsafe, clippy::all)]
                                                                                      #[allow(async_fn_in_trait)]
                                                                                      pub fn message(&self,) -> _rt::String{
                                                                                        unsafe {

                                                                                          #[cfg_attr(target_pointer_width="64", repr(align(8)))]
                                                                                          #[cfg_attr(target_pointer_width="32", repr(align(4)))]
                                                                                          struct RetArea([::core::mem::MaybeUninit::<u8>; 2*::core::mem::size_of::<*const u8>()]);
                                                                                          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2*::core::mem::size_of::<*const u8>()]);
                                                                                          let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                                                                                          #[cfg(target_arch = "wasm32")]
                                                                                          #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                                          unsafe extern "C" {
                                                                                            #[link_name = "[method]gpu-error.message"]
                                                                                            fn wit_import1(_: i32, _: *mut u8, );
                                                                                          }

                                                                                          #[cfg(not(target_arch = "wasm32"))]
                                                                                          unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, ) { unreachable!() }
                                                                                          wit_import1((self).handle() as i32, ptr0);
                                                                                          let l2 = *ptr0.add(0).cast::<*mut u8>();
                                                                                          let l3 = *ptr0.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
                                                                                          let len4 = l3;
                                                                                          let bytes4 = _rt::Vec::from_raw_parts(l2.cast(), len4, len4);
                                                                                          let result5 = _rt::string_lift(bytes4);
                                                                                          result5
                                                                                        }
                                                                                      }
                                                                                    }
                                                                                    impl GpuError {
                                                                                      #[allow(unused_unsafe, clippy::all)]
                                                                                      #[allow(async_fn_in_trait)]
                                                                                      pub fn kind(&self,) -> GpuErrorKind{
                                                                                        unsafe {

                                                                                          #[cfg(target_arch = "wasm32")]
                                                                                          #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                                          unsafe extern "C" {
                                                                                            #[link_name = "[method]gpu-error.kind"]
                                                                                            fn wit_import0(_: i32, ) -> i32;
                                                                                          }

                                                                                          #[cfg(not(target_arch = "wasm32"))]
                                                                                          unsafe extern "C" fn wit_import0(_: i32, ) -> i32 { unreachable!() }
                                                                                          let ret = wit_import0((self).handle() as i32);
                                                                                          let v1 = match ret {
                                                                                            0 => {
                                                                                              GpuErrorKind::ValidationError
                                                                                            }
                                                                                            1 => {
                                                                                              GpuErrorKind::OutOfMemoryError
                                                                                            }
                                                                                            n => {
                                                                                              debug_assert_eq!(n, 2, "invalid enum discriminant");
                                                                                              GpuErrorKind::InternalError
                                                                                            }
                                                                                          };
                                                                                          v1
                                                                                        }
                                                                                      }
                                                                                    }
                                                                                    impl GpuUncapturedErrorEvent {
                                                                                      #[allow(unused_unsafe, clippy::all)]
                                                                                      #[allow(async_fn_in_trait)]
                                                                                      pub fn error(&self,) -> GpuError{
                                                                                        unsafe {

                                                                                          #[cfg(target_arch = "wasm32")]
                                                                                          #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                                          unsafe extern "C" {
                                                                                            #[link_name = "[method]gpu-uncaptured-error-event.error"]
                                                                                            fn wit_import0(_: i32, ) -> i32;
                                                                                          }

                                                                                          #[cfg(not(target_arch = "wasm32"))]
                                                                                          unsafe extern "C" fn wit_import0(_: i32, ) -> i32 { unreachable!() }
                                                                                          let ret = wit_import0((self).handle() as i32);
                                                                                          GpuError::from_handle(ret as u32)
                                                                                        }
                                                                                      }
                                                                                    }
                                                                                    #[allow(unused_unsafe, clippy::all)]
                                                                                    #[allow(async_fn_in_trait)]
                                                                                    pub fn get_gpu() -> Gpu{
                                                                                      unsafe {

                                                                                        #[cfg(target_arch = "wasm32")]
                                                                                        #[link(wasm_import_module = "wasi:webgpu/webgpu@0.0.1")]
                                                                                        unsafe extern "C" {
                                                                                          #[link_name = "get-gpu"]
                                                                                          fn wit_import0() -> i32;
                                                                                        }

                                                                                        #[cfg(not(target_arch = "wasm32"))]
                                                                                        unsafe extern "C" fn wit_import0() -> i32 { unreachable!() }
                                                                                        let ret = wit_import0();
                                                                                        Gpu::from_handle(ret as u32)
                                                                                      }
                                                                                    }

                                                                                  }

                                                                                }
                                                                              }
                                                                              #[allow(dead_code, clippy::all)]
                                                                              pub mod exports {
                                                                                pub mod local {
                                                                                  pub mod immediate_renderer {

                                                                                    #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
                                                                                    pub mod render {
                                                                                      #[used]
                                                                                      #[doc(hidden)]
                                                                                      static __FORCE_SECTION_REF: fn() =
                                                                                      super::super::super::super::__link_custom_section_describing_imports;
                                                                                      
                                                                                      use super::super::super::super::_rt;
                                                                                      pub type RenderContext = super::super::super::super::local::webgpu_runtime::surface::RenderContext;
                                                                                      pub type Event = super::super::super::super::local::immediate_renderer::types::Event;
                                                                                      pub type UnhandleEvent = super::super::super::super::local::immediate_renderer::types::UnhandleEvent;

                                                                                      #[derive(Debug)]
                                                                                      #[repr(transparent)]
                                                                                      pub struct Dispatcher{
                                                                                        handle: _rt::Resource<Dispatcher>,
                                                                                      }

                                                                                      type _DispatcherRep<T> = Option<T>;

                                                                                      impl Dispatcher{
                                                                                        /// Creates a new resource from the specified representation.
                                                                                        ///
                                                                                        /// This function will create a new resource handle by moving `val` onto
                                                                                        /// the heap and then passing that heap pointer to the component model to
                                                                                        /// create a handle. The owned handle is then returned as `Dispatcher`.
                                                                                        pub fn new<T: GuestDispatcher>(val: T) -> Self {
                                                                                          Self::type_guard::<T>();
                                                                                          let val: _DispatcherRep<T> = Some(val);
                                                                                          let ptr: *mut _DispatcherRep<T> =
                                                                                          _rt::Box::into_raw(_rt::Box::new(val));
                                                                                          unsafe {
                                                                                            Self::from_handle(T::_resource_new(ptr.cast()))
                                                                                          }
                                                                                        }

                                                                                        /// Gets access to the underlying `T` which represents this resource.
                                                                                        pub fn get<T: GuestDispatcher>(&self) -> &T {
                                                                                          let ptr = unsafe { &*self.as_ptr::<T>() };
                                                                                          ptr.as_ref().unwrap()
                                                                                        }

                                                                                        /// Gets mutable access to the underlying `T` which represents this
                                                                                        /// resource.
                                                                                        pub fn get_mut<T: GuestDispatcher>(&mut self) -> &mut T {
                                                                                          let ptr = unsafe { &mut *self.as_ptr::<T>() };
                                                                                          ptr.as_mut().unwrap()
                                                                                        }

                                                                                        /// Consumes this resource and returns the underlying `T`.
                                                                                        pub fn into_inner<T: GuestDispatcher>(self) -> T {
                                                                                          let ptr = unsafe { &mut *self.as_ptr::<T>() };
                                                                                          ptr.take().unwrap()
                                                                                        }

                                                                                        #[doc(hidden)]
                                                                                        pub unsafe fn from_handle(handle: u32) -> Self {
                                                                                          Self {
                                                                                            handle: unsafe { _rt::Resource::from_handle(handle) },
                                                                                          }
                                                                                        }

                                                                                        #[doc(hidden)]
                                                                                        pub fn take_handle(&self) -> u32 {
                                                                                          _rt::Resource::take_handle(&self.handle)
                                                                                        }

                                                                                        #[doc(hidden)]
                                                                                        pub fn handle(&self) -> u32 {
                                                                                          _rt::Resource::handle(&self.handle)
                                                                                        }

                                                                                        // It's theoretically possible to implement the `GuestDispatcher` trait twice
                                                                                        // so guard against using it with two different types here.
                                                                                        #[doc(hidden)]
                                                                                        fn type_guard<T: 'static>() {
                                                                                          use core::any::TypeId;
                                                                                          static mut LAST_TYPE: Option<TypeId> = None;
                                                                                          unsafe {
                                                                                            assert!(!cfg!(target_feature = "atomics"));
                                                                                            let id = TypeId::of::<T>();
                                                                                            match LAST_TYPE {
                                                                                              Some(ty) => assert!(ty == id, "cannot use two types with this resource type"),
                                                                                              None => LAST_TYPE = Some(id),
                                                                                            }
                                                                                          }
                                                                                        }

                                                                                        #[doc(hidden)]
                                                                                        pub unsafe fn dtor<T: 'static>(handle: *mut u8) {
                                                                                          Self::type_guard::<T>();
                                                                                          let _ = unsafe { _rt::Box::from_raw(handle as *mut _DispatcherRep<T>) };
                                                                                        }

                                                                                        fn as_ptr<T: GuestDispatcher>(&self) -> *mut _DispatcherRep<T> {
                                                                                          Dispatcher::type_guard::<T>();
                                                                                          T::_resource_rep(self.handle()).cast()
                                                                                        }
                                                                                      }

                                                                                      /// A borrowed version of [`Dispatcher`] which represents a borrowed value
                                                                                      /// with the lifetime `'a`.
                                                                                      #[derive(Debug)]
                                                                                      #[repr(transparent)]
                                                                                      pub struct DispatcherBorrow<'a> {
                                                                                        rep: *mut u8,
                                                                                        _marker: core::marker::PhantomData<&'a Dispatcher>,
                                                                                      }

                                                                                      impl<'a> DispatcherBorrow<'a>{
                                                                                        #[doc(hidden)]
                                                                                        pub unsafe fn lift(rep: usize) -> Self {
                                                                                          Self {
                                                                                            rep: rep as *mut u8,
                                                                                            _marker: core::marker::PhantomData,
                                                                                          }
                                                                                        }

                                                                                        /// Gets access to the underlying `T` in this resource.
                                                                                        pub fn get<T: GuestDispatcher>(&self) -> &'a T {
                                                                                          let ptr = unsafe { &mut *self.as_ptr::<T>() };
                                                                                          ptr.as_ref().unwrap()
                                                                                        }

                                                                                        // NB: mutable access is not allowed due to the component model allowing
                                                                                        // multiple borrows of the same resource.

                                                                                        fn as_ptr<T: 'static>(&self) -> *mut _DispatcherRep<T> {
                                                                                          Dispatcher::type_guard::<T>();
                                                                                          self.rep.cast()
                                                                                        }
                                                                                      }
                                                                                      

                                                                                      unsafe impl _rt::WasmResource for Dispatcher{
                                                                                        #[inline]
                                                                                        unsafe fn drop(_handle: u32) {
                                                                                          
                                                                                          #[cfg(target_arch = "wasm32")]
                                                                                          #[link(wasm_import_module = "[export]local:immediate-renderer/render")]
                                                                                          unsafe extern "C" {
                                                                                            #[link_name = "[resource-drop]dispatcher"]
                                                                                            fn drop(_: i32, );
                                                                                          }

                                                                                          #[cfg(not(target_arch = "wasm32"))]
                                                                                          unsafe extern "C" fn drop(_: i32, ) { unreachable!() }
                                                                                          
                                                                                          unsafe { drop(_handle as i32); }
                                                                                        }
                                                                                      }
                                                                                      
                                                                                      #[doc(hidden)]
                                                                                      #[allow(non_snake_case, unused_unsafe)]
                                                                                      pub unsafe fn _export_method_dispatcher_push_event_cabi<T: GuestDispatcher>(arg0: *mut u8,arg1: i32,arg2: i32,arg3: i32,arg4: i32,arg5: i32,) { unsafe {#[cfg(target_arch="wasm32")]
                                                                                      _rt::run_ctors_once();{
                                                                                        use super::super::super::super::local::immediate_renderer::types::Event as V0;
                                                                                        let v0 = match arg1 {
                                                                                          0 => {
                                                                                            let e0 = super::super::super::super::local::immediate_renderer::types::ModifierOptions{
                                                                                              ctrl: super::super::super::super::local::immediate_renderer::types::ModifierPressed::empty() | super::super::super::super::local::immediate_renderer::types::ModifierPressed::from_bits_retain(((arg2 as u8) << 0) as _),
                                                                                              shift: super::super::super::super::local::immediate_renderer::types::ModifierPressed::empty() | super::super::super::super::local::immediate_renderer::types::ModifierPressed::from_bits_retain(((arg3 as u8) << 0) as _),
                                                                                              alt: super::super::super::super::local::immediate_renderer::types::ModifierPressed::empty() | super::super::super::super::local::immediate_renderer::types::ModifierPressed::from_bits_retain(((arg4 as u8) << 0) as _),
                                                                                              super_key: super::super::super::super::local::immediate_renderer::types::ModifierPressed::empty() | super::super::super::super::local::immediate_renderer::types::ModifierPressed::from_bits_retain(((arg5 as u8) << 0) as _),
                                                                                            };
                                                                                            V0::Modifiers(e0)
                                                                                          }
                                                                                          1 => {
                                                                                            let e0 = super::super::super::super::local::immediate_renderer::types::Location{
                                                                                              x: f32::from_bits(arg2 as u32),
                                                                                              y: f32::from_bits(arg3 as u32),
                                                                                            };
                                                                                            V0::Pointer(e0)
                                                                                          }
                                                                                          2 => {
                                                                                            let e0 = super::super::super::super::local::immediate_renderer::types::MouseButton::_lift(arg2 as u8);
                                                                                            V0::MouseDown(e0)
                                                                                          }
                                                                                          n => {
                                                                                            debug_assert_eq!(n, 3, "invalid enum discriminant");
                                                                                            let e0 = super::super::super::super::local::immediate_renderer::types::MouseButton::_lift(arg2 as u8);
                                                                                            V0::MouseUp(e0)
                                                                                          }
                                                                                        };
                                                                                        T::push_event(DispatcherBorrow::lift(arg0 as u32 as usize).get(), v0)
                                                                                      };
                                                                                    } }
                                                                                    #[doc(hidden)]
                                                                                    #[allow(non_snake_case, unused_unsafe)]
                                                                                    pub unsafe fn _export_method_dispatcher_push_event_all_cabi<T: GuestDispatcher>(arg0: *mut u8,arg1: *mut u8,arg2: usize,) { unsafe {#[cfg(target_arch="wasm32")]
                                                                                    _rt::run_ctors_once();{
                                                                                      let base10 = arg1;
                                                                                      let len10 = arg2;
                                                                                      let mut result10 = _rt::Vec::with_capacity(len10);
                                                                                      for i in 0..len10 {
                                                                                        let base = base10.add(i * 12);
                                                                                        let e10 = {
                                                                                          let l0 = i32::from(*base.add(0).cast::<u8>());
                                                                                          use super::super::super::super::local::immediate_renderer::types::Event as V9;
                                                                                          let v9 = match l0 {
                                                                                            0 => {
                                                                                              let e9 = {
                                                                                                let l1 = i32::from(*base.add(4).cast::<u8>());
                                                                                                let l2 = i32::from(*base.add(5).cast::<u8>());
                                                                                                let l3 = i32::from(*base.add(6).cast::<u8>());
                                                                                                let l4 = i32::from(*base.add(7).cast::<u8>());

                                                                                                super::super::super::super::local::immediate_renderer::types::ModifierOptions{
                                                                                                  ctrl: super::super::super::super::local::immediate_renderer::types::ModifierPressed::empty() | super::super::super::super::local::immediate_renderer::types::ModifierPressed::from_bits_retain(((l1 as u8) << 0) as _),
                                                                                                  shift: super::super::super::super::local::immediate_renderer::types::ModifierPressed::empty() | super::super::super::super::local::immediate_renderer::types::ModifierPressed::from_bits_retain(((l2 as u8) << 0) as _),
                                                                                                  alt: super::super::super::super::local::immediate_renderer::types::ModifierPressed::empty() | super::super::super::super::local::immediate_renderer::types::ModifierPressed::from_bits_retain(((l3 as u8) << 0) as _),
                                                                                                  super_key: super::super::super::super::local::immediate_renderer::types::ModifierPressed::empty() | super::super::super::super::local::immediate_renderer::types::ModifierPressed::from_bits_retain(((l4 as u8) << 0) as _),
                                                                                                }
                                                                                              };
                                                                                              V9::Modifiers(e9)
                                                                                            }
                                                                                            1 => {
                                                                                              let e9 = {
                                                                                                let l5 = *base.add(4).cast::<f32>();
                                                                                                let l6 = *base.add(8).cast::<f32>();

                                                                                                super::super::super::super::local::immediate_renderer::types::Location{
                                                                                                  x: l5,
                                                                                                  y: l6,
                                                                                                }
                                                                                              };
                                                                                              V9::Pointer(e9)
                                                                                            }
                                                                                            2 => {
                                                                                              let e9 = {
                                                                                                let l7 = i32::from(*base.add(4).cast::<u8>());

                                                                                                super::super::super::super::local::immediate_renderer::types::MouseButton::_lift(l7 as u8)
                                                                                              };
                                                                                              V9::MouseDown(e9)
                                                                                            }
                                                                                            n => {
                                                                                              debug_assert_eq!(n, 3, "invalid enum discriminant");
                                                                                              let e9 = {
                                                                                                let l8 = i32::from(*base.add(4).cast::<u8>());

                                                                                                super::super::super::super::local::immediate_renderer::types::MouseButton::_lift(l8 as u8)
                                                                                              };
                                                                                              V9::MouseUp(e9)
                                                                                            }
                                                                                          };

                                                                                          v9
                                                                                        };
                                                                                        result10.push(e10);
                                                                                      }
                                                                                      _rt::cabi_dealloc(base10, len10 * 12, 4);
                                                                                      T::push_event_all(DispatcherBorrow::lift(arg0 as u32 as usize).get(), result10)
                                                                                    };
                                                                                  } }
                                                                                  #[doc(hidden)]
                                                                                  #[allow(non_snake_case, unused_unsafe)]
                                                                                  pub unsafe fn _export_method_dispatcher_dispatch_cabi<T: GuestDispatcher>(arg0: *mut u8,) -> *mut u8 { unsafe {#[cfg(target_arch="wasm32")]
                                                                                  _rt::run_ctors_once();let result0 = {
                                                                                    T::dispatch(DispatcherBorrow::lift(arg0 as u32 as usize).get())
                                                                                  };
                                                                                  let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                                                                                  let vec11 = result0;
                                                                                  let len11 = vec11.len();
                                                                                  let layout11 = _rt::alloc::Layout::from_size_align(vec11.len() * (8+2*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>()).unwrap();
                                                                                  let (result11, _cleanup11) = wit_bindgen::rt::Cleanup::new(layout11);if let Some(cleanup) = _cleanup11 { cleanup.forget(); }
                                                                                  for (i, e) in vec11.into_iter().enumerate() {
                                                                                    let base = result11.add(i * (8+2*::core::mem::size_of::<*const u8>()));
                                                                                    {
                                                                                      use super::super::super::super::local::immediate_renderer::types::UnhandleEvent as V10;
                                                                                      match e {
                                                                                        V10::Event(e) => {
                                                                                          *base.add(0).cast::<u8>() = (0i32) as u8;
                                                                                          use super::super::super::super::local::immediate_renderer::types::Event as V8;
                                                                                          match e {
                                                                                            V8::Modifiers(e) => {
                                                                                              *base.add(::core::mem::size_of::<*const u8>()).cast::<u8>() = (0i32) as u8;
                                                                                              let super::super::super::super::local::immediate_renderer::types::ModifierOptions{ ctrl:ctrl2, shift:shift2, alt:alt2, super_key:super_key2, } = e;
                                                                                              let flags3 = ctrl2;
                                                                                              *base.add(4+1*::core::mem::size_of::<*const u8>()).cast::<u8>() = ((flags3.bits() >> 0) as i32) as u8;
                                                                                              let flags4 = shift2;
                                                                                              *base.add(5+1*::core::mem::size_of::<*const u8>()).cast::<u8>() = ((flags4.bits() >> 0) as i32) as u8;
                                                                                              let flags5 = alt2;
                                                                                              *base.add(6+1*::core::mem::size_of::<*const u8>()).cast::<u8>() = ((flags5.bits() >> 0) as i32) as u8;
                                                                                              let flags6 = super_key2;
                                                                                              *base.add(7+1*::core::mem::size_of::<*const u8>()).cast::<u8>() = ((flags6.bits() >> 0) as i32) as u8;
                                                                                            },
                                                                                            V8::Pointer(e) => {
                                                                                              *base.add(::core::mem::size_of::<*const u8>()).cast::<u8>() = (1i32) as u8;
                                                                                              let super::super::super::super::local::immediate_renderer::types::Location{ x:x7, y:y7, } = e;
                                                                                              *base.add(4+1*::core::mem::size_of::<*const u8>()).cast::<f32>() = _rt::as_f32(x7);
                                                                                              *base.add(8+1*::core::mem::size_of::<*const u8>()).cast::<f32>() = _rt::as_f32(y7);
                                                                                            },
                                                                                            V8::MouseDown(e) => {
                                                                                              *base.add(::core::mem::size_of::<*const u8>()).cast::<u8>() = (2i32) as u8;
                                                                                              *base.add(4+1*::core::mem::size_of::<*const u8>()).cast::<u8>() = (e.clone() as i32) as u8;
                                                                                            },
                                                                                            V8::MouseUp(e) => {
                                                                                              *base.add(::core::mem::size_of::<*const u8>()).cast::<u8>() = (3i32) as u8;
                                                                                              *base.add(4+1*::core::mem::size_of::<*const u8>()).cast::<u8>() = (e.clone() as i32) as u8;
                                                                                            },
                                                                                          }
                                                                                        },
                                                                                        V10::OpenWindow(e) => {
                                                                                          *base.add(0).cast::<u8>() = (1i32) as u8;
                                                                                          let vec9 = (e.into_bytes()).into_boxed_slice();
                                                                                          let ptr9 = vec9.as_ptr().cast::<u8>();
                                                                                          let len9 = vec9.len();
                                                                                          ::core::mem::forget(vec9);
                                                                                          *base.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>() = len9;
                                                                                          *base.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>() = ptr9.cast_mut();
                                                                                        },
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                  *ptr1.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len11;
                                                                                  *ptr1.add(0).cast::<*mut u8>() = result11;
                                                                                  ptr1
                                                                                } }
                                                                                #[doc(hidden)]
                                                                                #[allow(non_snake_case)]
                                                                                pub unsafe fn __post_return_method_dispatcher_dispatch<T: GuestDispatcher>(arg0: *mut u8,) { unsafe {
                                                                                  let l0 = *arg0.add(0).cast::<*mut u8>();
                                                                                  let l1 = *arg0.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
                                                                                  let base5 = l0;
                                                                                  let len5 = l1;
                                                                                  for i in 0..len5 {
                                                                                    let base = base5.add(i * (8+2*::core::mem::size_of::<*const u8>()));
                                                                                    {
                                                                                      let l2 = i32::from(*base.add(0).cast::<u8>());
                                                                                      match l2 {
                                                                                        0 => (),
                                                                                        _ => {
                                                                                          let l3 = *base.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                                                                                          let l4 = *base.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>();
                                                                                          _rt::cabi_dealloc(l3, l4, 1);
                                                                                        },
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                  _rt::cabi_dealloc(base5, len5 * (8+2*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>());
                                                                                } }
                                                                                #[doc(hidden)]
                                                                                #[allow(non_snake_case, unused_unsafe)]
                                                                                pub unsafe fn _export_create_main_renderer_cabi<T: Guest>(arg0: i32,) -> i32 { unsafe {#[cfg(target_arch="wasm32")]
                                                                                _rt::run_ctors_once();let result0 = {
                                                                                  T::create_main_renderer(super::super::super::super::local::webgpu_runtime::surface::RenderContext::from_handle(arg0 as u32))
                                                                                };
                                                                                (result0).take_handle() as i32
                                                                              } }
                                                                              #[doc(hidden)]
                                                                              #[allow(non_snake_case, unused_unsafe)]
                                                                              pub unsafe fn _export_create_triangle_renderer_cabi<T: Guest>(arg0: i32,) -> i32 { unsafe {#[cfg(target_arch="wasm32")]
                                                                              _rt::run_ctors_once();let result0 = {
                                                                                T::create_triangle_renderer(super::super::super::super::local::webgpu_runtime::surface::RenderContext::from_handle(arg0 as u32))
                                                                              };
                                                                              (result0).take_handle() as i32
                                                                            } }
                                                                            #[doc(hidden)]
                                                                            #[allow(non_snake_case, unused_unsafe)]
                                                                            pub unsafe fn _export_create_counter_renderer_cabi<T: Guest>(arg0: i32,) -> i32 { unsafe {#[cfg(target_arch="wasm32")]
                                                                            _rt::run_ctors_once();let result0 = {
                                                                              T::create_counter_renderer(super::super::super::super::local::webgpu_runtime::surface::RenderContext::from_handle(arg0 as u32))
                                                                            };
                                                                            (result0).take_handle() as i32
                                                                          } }
                                                                          pub trait Guest {
                                                                            type Dispatcher: GuestDispatcher;
                                                                            #[allow(async_fn_in_trait)]
                                                                            fn create_main_renderer(context: RenderContext,) -> Dispatcher;
                                                                            #[allow(async_fn_in_trait)]
                                                                            fn create_triangle_renderer(context: RenderContext,) -> Dispatcher;
                                                                            #[allow(async_fn_in_trait)]
                                                                            fn create_counter_renderer(context: RenderContext,) -> Dispatcher;
                                                                          }
                                                                          pub trait GuestDispatcher: 'static {

                                                                            #[doc(hidden)]
                                                                            unsafe fn _resource_new(val: *mut u8) -> u32
                                                                            where Self: Sized
                                                                            {
                                                                              
                                                                              #[cfg(target_arch = "wasm32")]
                                                                              #[link(wasm_import_module = "[export]local:immediate-renderer/render")]
                                                                              unsafe extern "C" {
                                                                                #[link_name = "[resource-new]dispatcher"]
                                                                                fn new(_: *mut u8, ) -> i32;
                                                                              }

                                                                              #[cfg(not(target_arch = "wasm32"))]
                                                                              unsafe extern "C" fn new(_: *mut u8, ) -> i32 { unreachable!() }
                                                                              
                                                                              unsafe { new(val) as u32 }
                                                                            }

                                                                            #[doc(hidden)]
                                                                            fn _resource_rep(handle: u32) -> *mut u8
                                                                            where Self: Sized
                                                                            {
                                                                              
                                                                              #[cfg(target_arch = "wasm32")]
                                                                              #[link(wasm_import_module = "[export]local:immediate-renderer/render")]
                                                                              unsafe extern "C" {
                                                                                #[link_name = "[resource-rep]dispatcher"]
                                                                                fn rep(_: i32, ) -> *mut u8;
                                                                              }

                                                                              #[cfg(not(target_arch = "wasm32"))]
                                                                              unsafe extern "C" fn rep(_: i32, ) -> *mut u8 { unreachable!() }
                                                                              
                                                                              unsafe { rep(handle as i32) }
                                                                            }

                                                                            
                                                                            #[allow(async_fn_in_trait)]
                                                                            fn push_event(&self,event: Event,) -> ();
                                                                            #[allow(async_fn_in_trait)]
                                                                            fn push_event_all(&self,event: _rt::Vec::<Event>,) -> ();
                                                                            #[allow(async_fn_in_trait)]
                                                                            fn dispatch(&self,) -> _rt::Vec::<UnhandleEvent>;
                                                                          }
                                                                          #[doc(hidden)]

                                                                          macro_rules! __export_local_immediate_renderer_render_cabi{
                                                                            ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

                                                                              #[unsafe(export_name = "local:immediate-renderer/render#[method]dispatcher.push-event")]
                                                                              unsafe extern "C" fn export_method_dispatcher_push_event(arg0: *mut u8,arg1: i32,arg2: i32,arg3: i32,arg4: i32,arg5: i32,) {
                                                                                unsafe { $($path_to_types)*::_export_method_dispatcher_push_event_cabi::<<$ty as $($path_to_types)*::Guest>::Dispatcher>(arg0, arg1, arg2, arg3, arg4, arg5) }
                                                                              }
                                                                              #[unsafe(export_name = "local:immediate-renderer/render#[method]dispatcher.push-event-all")]
                                                                              unsafe extern "C" fn export_method_dispatcher_push_event_all(arg0: *mut u8,arg1: *mut u8,arg2: usize,) {
                                                                                unsafe { $($path_to_types)*::_export_method_dispatcher_push_event_all_cabi::<<$ty as $($path_to_types)*::Guest>::Dispatcher>(arg0, arg1, arg2) }
                                                                              }
                                                                              #[unsafe(export_name = "local:immediate-renderer/render#[method]dispatcher.dispatch")]
                                                                              unsafe extern "C" fn export_method_dispatcher_dispatch(arg0: *mut u8,) -> *mut u8 {
                                                                                unsafe { $($path_to_types)*::_export_method_dispatcher_dispatch_cabi::<<$ty as $($path_to_types)*::Guest>::Dispatcher>(arg0) }
                                                                              }
                                                                              #[unsafe(export_name = "cabi_post_local:immediate-renderer/render#[method]dispatcher.dispatch")]
                                                                              unsafe extern "C" fn _post_return_method_dispatcher_dispatch(arg0: *mut u8,) {
                                                                                unsafe { $($path_to_types)*::__post_return_method_dispatcher_dispatch::<<$ty as $($path_to_types)*::Guest>::Dispatcher>(arg0) }
                                                                              }
                                                                              #[unsafe(export_name = "local:immediate-renderer/render#create-main-renderer")]
                                                                              unsafe extern "C" fn export_create_main_renderer(arg0: i32,) -> i32 {
                                                                                unsafe { $($path_to_types)*::_export_create_main_renderer_cabi::<$ty>(arg0) }
                                                                              }
                                                                              #[unsafe(export_name = "local:immediate-renderer/render#create-triangle-renderer")]
                                                                              unsafe extern "C" fn export_create_triangle_renderer(arg0: i32,) -> i32 {
                                                                                unsafe { $($path_to_types)*::_export_create_triangle_renderer_cabi::<$ty>(arg0) }
                                                                              }
                                                                              #[unsafe(export_name = "local:immediate-renderer/render#create-counter-renderer")]
                                                                              unsafe extern "C" fn export_create_counter_renderer(arg0: i32,) -> i32 {
                                                                                unsafe { $($path_to_types)*::_export_create_counter_renderer_cabi::<$ty>(arg0) }
                                                                              }

                                                                              const _: () = {
                                                                                #[doc(hidden)]
                                                                                #[unsafe(export_name = "local:immediate-renderer/render#[dtor]dispatcher")]
                                                                                #[allow(non_snake_case)]
                                                                                unsafe extern "C" fn dtor(rep: *mut u8) {
                                                                                  unsafe {
                                                                                    $($path_to_types)*::Dispatcher::dtor::<
                                                                                    <$ty as $($path_to_types)*::Guest>::Dispatcher
                                                                                    >(rep)
                                                                                  }
                                                                                }
                                                                              };
                                                                              
                                                                            };);
                                                                          }
                                                                          #[doc(hidden)]
                                                                          pub(crate) use __export_local_immediate_renderer_render_cabi;

                                                                          #[cfg_attr(target_pointer_width="64", repr(align(8)))]
                                                                          #[cfg_attr(target_pointer_width="32", repr(align(4)))]
                                                                          struct _RetArea([::core::mem::MaybeUninit::<u8>; 2*::core::mem::size_of::<*const u8>()]);
                                                                          static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 2*::core::mem::size_of::<*const u8>()]);

                                                                        }

                                                                      }
                                                                    }
                                                                  }
                                                                  mod _rt {
                                                                    #![allow(dead_code, unused_imports, clippy::all)]


                                                                    use core::fmt;
                                                                    use core::marker;
                                                                    use core::sync::atomic::{AtomicU32, Ordering::Relaxed};

                                                                    /// A type which represents a component model resource, either imported or
                                                                    /// exported into this component.
                                                                    ///
                                                                    /// This is a low-level wrapper which handles the lifetime of the resource
                                                                    /// (namely this has a destructor). The `T` provided defines the component model
                                                                    /// intrinsics that this wrapper uses.
                                                                    ///
                                                                    /// One of the chief purposes of this type is to provide `Deref` implementations
                                                                    /// to access the underlying data when it is owned.
                                                                    ///
                                                                    /// This type is primarily used in generated code for exported and imported
                                                                    /// resources.
                                                                    #[repr(transparent)]
                                                                    pub struct Resource<T: WasmResource> {
                                                                      // NB: This would ideally be `u32` but it is not. The fact that this has
                                                                      // interior mutability is not exposed in the API of this type except for the
                                                                      // `take_handle` method which is supposed to in theory be private.
                                                                      //
                                                                      // This represents, almost all the time, a valid handle value. When it's
                                                                      // invalid it's stored as `u32::MAX`.
                                                                      handle: AtomicU32,
                                                                      _marker: marker::PhantomData<T>,
                                                                    }

                                                                    /// A trait which all wasm resources implement, namely providing the ability to
                                                                    /// drop a resource.
                                                                    ///
                                                                    /// This generally is implemented by generated code, not user-facing code.
                                                                    #[allow(clippy::missing_safety_doc)]
                                                                    pub unsafe trait WasmResource {
                                                                      /// Invokes the `[resource-drop]...` intrinsic.
                                                                      unsafe fn drop(handle: u32);
                                                                    }

                                                                    impl<T: WasmResource> Resource<T> {
                                                                      #[doc(hidden)]
                                                                      pub unsafe fn from_handle(handle: u32) -> Self {
                                                                        debug_assert!(handle != 0 && handle != u32::MAX);
                                                                        Self {
                                                                          handle: AtomicU32::new(handle),
                                                                          _marker: marker::PhantomData,
                                                                        }
                                                                      }

                                                                      /// Takes ownership of the handle owned by `resource`.
                                                                      ///
                                                                      /// Note that this ideally would be `into_handle` taking `Resource<T>` by
                                                                      /// ownership. The code generator does not enable that in all situations,
                                                                      /// unfortunately, so this is provided instead.
                                                                      ///
                                                                      /// Also note that `take_handle` is in theory only ever called on values
                                                                      /// owned by a generated function. For example a generated function might
                                                                      /// take `Resource<T>` as an argument but then call `take_handle` on a
                                                                      /// reference to that argument. In that sense the dynamic nature of
                                                                      /// `take_handle` should only be exposed internally to generated code, not
                                                                      /// to user code.
                                                                      #[doc(hidden)]
                                                                      pub fn take_handle(resource: &Resource<T>) -> u32 {
                                                                        resource.handle.swap(u32::MAX, Relaxed)
                                                                      }

                                                                      #[doc(hidden)]
                                                                      pub fn handle(resource: &Resource<T>) -> u32 {
                                                                        resource.handle.load(Relaxed)
                                                                      }
                                                                    }

                                                                    impl<T: WasmResource> fmt::Debug for Resource<T> {
                                                                      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                                                                        f.debug_struct("Resource")
                                                                        .field("handle", &self.handle)
                                                                        .finish()
                                                                      }
                                                                    }

                                                                    impl<T: WasmResource> Drop for Resource<T> {
                                                                      fn drop(&mut self) {
                                                                        unsafe {
                                                                          match self.handle.load(Relaxed) {
                                                                            // If this handle was "taken" then don't do anything in the
                                                                            // destructor.
                                                                            u32::MAX => {}

                                                                            // ... but otherwise do actually destroy it with the imported
                                                                            // component model intrinsic as defined through `T`.
                                                                            other => T::drop(other),
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                    pub unsafe fn bool_lift(val: u8) -> bool {
                                                                      if cfg!(debug_assertions) {
                                                                        match val {
                                                                          0 => false,
                                                                          1 => true,
                                                                          _ => panic!("invalid bool discriminant"),
                                                                        }
                                                                      } else {
                                                                        val != 0
                                                                      }
                                                                    }
                                                                    pub use alloc_crate::vec::Vec;
                                                                    pub use alloc_crate::alloc;
                                                                    pub use alloc_crate::string::String;
                                                                    pub unsafe fn string_lift(bytes: Vec<u8>) -> String {
                                                                      if cfg!(debug_assertions) {
                                                                        String::from_utf8(bytes).unwrap()
                                                                      } else {
                                                                        unsafe { String::from_utf8_unchecked(bytes) }
                                                                      }
                                                                    }
                                                                    pub unsafe fn invalid_enum_discriminant<T>() -> T {
                                                                      if cfg!(debug_assertions) {
                                                                        panic!("invalid enum discriminant")
                                                                      } else {
                                                                        unsafe { core::hint::unreachable_unchecked() }
                                                                      }
                                                                    }
                                                                    
                                                                    pub fn as_i64<T: AsI64>(t: T) -> i64 {
                                                                      t.as_i64()
                                                                    }

                                                                    pub trait AsI64 {
                                                                      fn as_i64(self) -> i64;
                                                                    }

                                                                    impl<'a, T: Copy + AsI64> AsI64 for &'a T {
                                                                      fn as_i64(self) -> i64 {
                                                                        (*self).as_i64()
                                                                      }
                                                                    }
                                                                    
                                                                    impl AsI64 for i64 {
                                                                      #[inline]
                                                                      fn as_i64(self) -> i64 {
                                                                        self as i64
                                                                      }
                                                                    }
                                                                    
                                                                    impl AsI64 for u64 {
                                                                      #[inline]
                                                                      fn as_i64(self) -> i64 {
                                                                        self as i64
                                                                      }
                                                                    }
                                                                    pub unsafe fn cabi_dealloc(ptr: *mut u8, size: usize, align: usize) {
                                                                      if size == 0 {
                                                                        return;
                                                                      }
                                                                      unsafe {
                                                                        let layout = alloc::Layout::from_size_align_unchecked(size, align);
                                                                        alloc::dealloc(ptr, layout);
                                                                      }
                                                                    }
                                                                    
                                                                    pub fn as_i32<T: AsI32>(t: T) -> i32 {
                                                                      t.as_i32()
                                                                    }

                                                                    pub trait AsI32 {
                                                                      fn as_i32(self) -> i32;
                                                                    }

                                                                    impl<'a, T: Copy + AsI32> AsI32 for &'a T {
                                                                      fn as_i32(self) -> i32 {
                                                                        (*self).as_i32()
                                                                      }
                                                                    }
                                                                    
                                                                    impl AsI32 for i32 {
                                                                      #[inline]
                                                                      fn as_i32(self) -> i32 {
                                                                        self as i32
                                                                      }
                                                                    }
                                                                    
                                                                    impl AsI32 for u32 {
                                                                      #[inline]
                                                                      fn as_i32(self) -> i32 {
                                                                        self as i32
                                                                      }
                                                                    }
                                                                    
                                                                    impl AsI32 for i16 {
                                                                      #[inline]
                                                                      fn as_i32(self) -> i32 {
                                                                        self as i32
                                                                      }
                                                                    }
                                                                    
                                                                    impl AsI32 for u16 {
                                                                      #[inline]
                                                                      fn as_i32(self) -> i32 {
                                                                        self as i32
                                                                      }
                                                                    }
                                                                    
                                                                    impl AsI32 for i8 {
                                                                      #[inline]
                                                                      fn as_i32(self) -> i32 {
                                                                        self as i32
                                                                      }
                                                                    }
                                                                    
                                                                    impl AsI32 for u8 {
                                                                      #[inline]
                                                                      fn as_i32(self) -> i32 {
                                                                        self as i32
                                                                      }
                                                                    }
                                                                    
                                                                    impl AsI32 for char {
                                                                      #[inline]
                                                                      fn as_i32(self) -> i32 {
                                                                        self as i32
                                                                      }
                                                                    }
                                                                    
                                                                    impl AsI32 for usize {
                                                                      #[inline]
                                                                      fn as_i32(self) -> i32 {
                                                                        self as i32
                                                                      }
                                                                    }
                                                                    
                                                                    pub fn as_f32<T: AsF32>(t: T) -> f32 {
                                                                      t.as_f32()
                                                                    }

                                                                    pub trait AsF32 {
                                                                      fn as_f32(self) -> f32;
                                                                    }

                                                                    impl<'a, T: Copy + AsF32> AsF32 for &'a T {
                                                                      fn as_f32(self) -> f32 {
                                                                        (*self).as_f32()
                                                                      }
                                                                    }
                                                                    
                                                                    impl AsF32 for f32 {
                                                                      #[inline]
                                                                      fn as_f32(self) -> f32 {
                                                                        self as f32
                                                                      }
                                                                    }
                                                                    
                                                                    pub fn as_f64<T: AsF64>(t: T) -> f64 {
                                                                      t.as_f64()
                                                                    }

                                                                    pub trait AsF64 {
                                                                      fn as_f64(self) -> f64;
                                                                    }

                                                                    impl<'a, T: Copy + AsF64> AsF64 for &'a T {
                                                                      fn as_f64(self) -> f64 {
                                                                        (*self).as_f64()
                                                                      }
                                                                    }
                                                                    
                                                                    impl AsF64 for f64 {
                                                                      #[inline]
                                                                      fn as_f64(self) -> f64 {
                                                                        self as f64
                                                                      }
                                                                    }
                                                                    pub use alloc_crate::boxed::Box;

                                                                    #[cfg(target_arch = "wasm32")]
                                                                    pub fn run_ctors_once() {
                                                                      wit_bindgen::rt::run_ctors_once();
                                                                    }
                                                                    extern crate alloc as alloc_crate;
                                                                  }

                                                                  /// Generates `#[unsafe(no_mangle)]` functions to export the specified type as
                                                                  /// the root implementation of all generated traits.
                                                                  ///
                                                                  /// For more information see the documentation of `wit_bindgen::generate!`.
                                                                  ///
                                                                  /// ```rust
                                                                  /// # macro_rules! export{ ($($t:tt)*) => (); }
                                                                  /// # trait Guest {}
                                                                  /// struct MyType;
                                                                  ///
                                                                  /// impl Guest for MyType {
                                                                  ///     // ...
                                                                  /// }
                                                                  ///
                                                                  /// export!(MyType);
                                                                  /// ```
                                                                  #[allow(unused_macros)]
                                                                  #[doc(hidden)]

                                                                  macro_rules! __export_immediate_renderer_world_impl {
                                                                    ($ty:ident) => (crate::bindings::immediate_renderer_world::export!($ty with_types_in crate::bindings::immediate_renderer_world););
                                                                    ($ty:ident with_types_in $($path_to_types_root:tt)*) => (
                                                                    $($path_to_types_root)*::exports::local::immediate_renderer::render::__export_local_immediate_renderer_render_cabi!($ty with_types_in $($path_to_types_root)*::exports::local::immediate_renderer::render);
                                                                    )
                                                                  }
                                                                  #[doc(inline)]
                                                                  pub(crate) use __export_immediate_renderer_world_impl as export;

                                                                  #[cfg(target_arch = "wasm32")]
                                                                  #[unsafe(link_section = "component-type:wit-bindgen:0.52.0:local:immediate-renderer:immediate-renderer-world:encoded world")]
                                                                  #[doc(hidden)]
                                                                  #[allow(clippy::octal_escapes)]
                                                                  pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 29656] = *b"\
\0asm\x0d\0\x01\0\0\x19\x16wit-component-encoding\x04\0\x07\xc8\xe6\x01\x01A\x02\
\x01A\x16\x01B\x0a\x04\0\x08pollable\x03\x01\x01h\0\x01@\x01\x04self\x01\0\x7f\x04\
\0\x16[method]pollable.ready\x01\x02\x01@\x01\x04self\x01\x01\0\x04\0\x16[method\
]pollable.block\x01\x03\x01p\x01\x01py\x01@\x01\x02in\x04\0\x05\x04\0\x04poll\x01\
\x06\x03\0\x12wasi:io/poll@0.2.9\x05\0\x01B\x0b\x04\0\x07context\x03\x01\x04\0\x0f\
abstract-buffer\x03\x01\x01i\0\x01@\0\0\x02\x04\0\x14[constructor]context\x01\x03\
\x01h\0\x01i\x01\x01@\x01\x04self\x04\0\x05\x04\0\"[method]context.get-current-b\
uffer\x01\x06\x01@\x01\x04self\x04\x01\0\x04\0\x17[method]context.present\x01\x07\
\x03\0,wasi:graphics-context/graphics-context@0.0.1\x05\x01\x02\x03\0\0\x08polla\
ble\x02\x03\0\x01\x07context\x02\x03\0\x01\x0fabstract-buffer\x01B\x8e\x07\x02\x03\
\x02\x01\x02\x04\0\x08pollable\x03\0\0\x02\x03\x02\x01\x03\x04\0\x07context\x03\0\
\x02\x02\x03\x02\x01\x04\x04\0\x0fabstract-buffer\x03\0\x04\x04\0\x14gpu-support\
ed-limits\x03\x01\x04\0\x16gpu-supported-features\x03\x01\x04\0\x16wgsl-language\
-features\x03\x01\x04\0\x10gpu-adapter-info\x03\x01\x04\0\x03gpu\x03\x01\x01m\x02\
\x09low-power\x10high-performance\x04\0\x14gpu-power-preference\x03\0\x0b\x01ks\x01\
k\x0c\x01k\x7f\x01r\x04\x0dfeature-level\x0d\x10power-preference\x0e\x16force-fa\
llback-adapter\x0f\x0dxr-compatible\x0f\x04\0\x1bgpu-request-adapter-options\x03\
\0\x10\x04\0\x0bgpu-adapter\x03\x01\x04\0\x18record-option-gpu-size64\x03\x01\x01\
m\x11\x12depth-clip-control\x15depth32float-stencil8\x16texture-compression-bc\x1f\
texture-compression-bc-sliced3d\x18texture-compression-etc2\x18texture-compressi\
on-astc!texture-compression-astc-sliced3d\x0ftimestamp-query\x17indirect-first-i\
nstance\x0ashader-f16\x18rg11b10ufloat-renderable\x12bgra8unorm-storage\x12float\
32-filterable\x11float32-blendable\x0eclip-distances\x14dual-source-blending\x09\
subgroups\x04\0\x10gpu-feature-name\x03\0\x14\x04\0\x0agpu-device\x03\x01\x04\0\x0a\
gpu-buffer\x03\x01\x01m\x03\x08unmapped\x07pending\x06mapped\x04\0\x14gpu-buffer\
-map-state\x03\0\x18\x01y\x04\0\x16gpu-buffer-usage-flags\x03\0\x1a\x04\0\x10gpu\
-buffer-usage\x03\x01\x01y\x04\0\x12gpu-map-mode-flags\x03\0\x1d\x04\0\x0cgpu-ma\
p-mode\x03\x01\x04\0\x0bgpu-texture\x03\x01\x01m\x03\x02d1\x02d2\x02d3\x04\0\x15\
gpu-texture-dimension\x03\0!\x01y\x04\0\x17gpu-texture-usage-flags\x03\0#\x04\0\x11\
gpu-texture-usage\x03\x01\x04\0\x10gpu-texture-view\x03\x01\x01m\x06\x02d1\x02d2\
\x08d2-array\x04cube\x0acube-array\x02d3\x04\0\x1agpu-texture-view-dimension\x03\
\0'\x01m\x03\x03all\x0cstencil-only\x0adepth-only\x04\0\x12gpu-texture-aspect\x03\
\0)\x01m_\x07r8unorm\x07r8snorm\x06r8uint\x06r8sint\x07r16uint\x07r16sint\x08r16\
float\x08rg8unorm\x08rg8snorm\x07rg8uint\x07rg8sint\x07r32uint\x07r32sint\x08r32\
float\x08rg16uint\x08rg16sint\x09rg16float\x0argba8unorm\x0frgba8unorm-srgb\x0ar\
gba8snorm\x09rgba8uint\x09rgba8sint\x0abgra8unorm\x0fbgra8unorm-srgb\x0crgb9e5uf\
loat\x0brgb10a2uint\x0crgb10a2unorm\x0drg11b10ufloat\x08rg32uint\x08rg32sint\x09\
rg32float\x0argba16uint\x0argba16sint\x0brgba16float\x0argba32uint\x0argba32sint\
\x0brgba32float\x08stencil8\x0cdepth16unorm\x0bdepth24plus\x14depth24plus-stenci\
l8\x0cdepth32float\x15depth32float-stencil8\x0ebc1-rgba-unorm\x13bc1-rgba-unorm-\
srgb\x0ebc2-rgba-unorm\x13bc2-rgba-unorm-srgb\x0ebc3-rgba-unorm\x13bc3-rgba-unor\
m-srgb\x0bbc4-r-unorm\x0bbc4-r-snorm\x0cbc5-rg-unorm\x0cbc5-rg-snorm\x0fbc6h-rgb\
-ufloat\x0ebc6h-rgb-float\x0ebc7-rgba-unorm\x13bc7-rgba-unorm-srgb\x0eetc2-rgb8u\
norm\x13etc2-rgb8unorm-srgb\x10etc2-rgb8a1unorm\x15etc2-rgb8a1unorm-srgb\x0fetc2\
-rgba8unorm\x14etc2-rgba8unorm-srgb\x0ceac-r11unorm\x0ceac-r11snorm\x0deac-rg11u\
norm\x0deac-rg11snorm\x0dastc4x4-unorm\x12astc4x4-unorm-srgb\x0dastc5x4-unorm\x12\
astc5x4-unorm-srgb\x0dastc5x5-unorm\x12astc5x5-unorm-srgb\x0dastc6x5-unorm\x12as\
tc6x5-unorm-srgb\x0dastc6x6-unorm\x12astc6x6-unorm-srgb\x0dastc8x5-unorm\x12astc\
8x5-unorm-srgb\x0dastc8x6-unorm\x12astc8x6-unorm-srgb\x0dastc8x8-unorm\x12astc8x\
8-unorm-srgb\x0eastc10x5-unorm\x13astc10x5-unorm-srgb\x0eastc10x6-unorm\x13astc1\
0x6-unorm-srgb\x0eastc10x8-unorm\x13astc10x8-unorm-srgb\x0fastc10x10-unorm\x14as\
tc10x10-unorm-srgb\x0fastc12x10-unorm\x14astc12x10-unorm-srgb\x0fastc12x12-unorm\
\x14astc12x12-unorm-srgb\x04\0\x12gpu-texture-format\x03\0+\x04\0\x0bgpu-sampler\
\x03\x01\x01m\x03\x0dclamp-to-edge\x06repeat\x0dmirror-repeat\x04\0\x10gpu-addre\
ss-mode\x03\0.\x01m\x02\x07nearest\x06linear\x04\0\x0fgpu-filter-mode\x03\00\x01\
m\x02\x07nearest\x06linear\x04\0\x16gpu-mipmap-filter-mode\x03\02\x01m\x08\x05ne\
ver\x04less\x05equal\x0aless-equal\x07greater\x09not-equal\x0dgreater-equal\x06a\
lways\x04\0\x14gpu-compare-function\x03\04\x01k/\x01k1\x01k3\x01kv\x01k5\x01k{\x01\
r\x0b\x0eaddress-mode-u6\x0eaddress-mode-v6\x0eaddress-mode-w6\x0amag-filter7\x0a\
min-filter7\x0dmipmap-filter8\x0dlod-min-clamp9\x0dlod-max-clamp9\x07compare:\x0e\
max-anisotropy;\x05label\x0d\x04\0\x16gpu-sampler-descriptor\x03\0<\x04\0\x15gpu\
-bind-group-layout\x03\x01\x01y\x04\0\x16gpu-shader-stage-flags\x03\0?\x04\0\x10\
gpu-shader-stage\x03\x01\x01m\x03\x07uniform\x07storage\x11read-only-storage\x04\
\0\x17gpu-buffer-binding-type\x03\0B\x01m\x03\x09filtering\x0dnon-filtering\x0ac\
omparison\x04\0\x18gpu-sampler-binding-type\x03\0D\x01k\xc5\0\x01r\x01\x04type\xc6\
\0\x04\0\x1agpu-sampler-binding-layout\x03\0G\x01m\x05\x05float\x12unfilterable-\
float\x05depth\x04sint\x04uint\x04\0\x17gpu-texture-sample-type\x03\0I\x01k\xca\0\
\x01k(\x01r\x03\x0bsample-type\xcb\0\x0eview-dimension\xcc\0\x0cmultisampled\x0f\
\x04\0\x1agpu-texture-binding-layout\x03\0M\x01m\x03\x0awrite-only\x09read-only\x0a\
read-write\x04\0\x1agpu-storage-texture-access\x03\0O\x01k\xd0\0\x01r\x03\x06acc\
ess\xd1\0\x06format,\x0eview-dimension\xcc\0\x04\0\"gpu-storage-texture-binding-\
layout\x03\0R\x04\0\x0egpu-bind-group\x03\x01\x04\0\x13gpu-pipeline-layout\x03\x01\
\x01h>\x01k\xd6\0\x01p\xd7\0\x01r\x02\x12bind-group-layouts\xd8\0\x05label\x0d\x04\
\0\x1egpu-pipeline-layout-descriptor\x03\0Y\x04\0\x11gpu-shader-module\x03\x01\x01\
m\x03\x05error\x07warning\x04info\x04\0\x1cgpu-compilation-message-type\x03\0\\\x04\
\0\x17gpu-compilation-message\x03\x01\x04\0\x14gpu-compilation-info\x03\x01\x01m\
\x02\x0avalidation\x08internal\x04\0\x19gpu-pipeline-error-reason\x03\0`\x01hU\x01\
q\x02\x08specific\x01\xe2\0\0\x04auto\0\0\x04\0\x0fgpu-layout-mode\x03\0c\x01k\xe4\
\0\x01r\x02\x0bentry-points\x06layout\xe5\0\x04\0\"gpu-shader-module-compilation\
-hint\x03\0f\x01p\xe7\0\x01k\xe8\0\x01r\x03\x04codes\x11compilation-hints\xe9\0\x05\
label\x0d\x04\0\x1cgpu-shader-module-descriptor\x03\0j\x04\0\"record-gpu-pipelin\
e-constant-value\x03\x01\x01h[\x01il\x01k\xee\0\x01r\x03\x06module\xed\0\x0bentr\
y-point\x0d\x09constants\xef\0\x04\0\x16gpu-programmable-stage\x03\0p\x01u\x04\0\
\x1bgpu-pipeline-constant-value\x03\0r\x04\0\x14gpu-compute-pipeline\x03\x01\x01\
r\x03\x07compute\xf1\0\x06layout\xe4\0\x05label\x0d\x04\0\x1fgpu-compute-pipelin\
e-descriptor\x03\0u\x04\0\x13gpu-render-pipeline\x03\x01\x01m\x05\x0apoint-list\x09\
line-list\x0aline-strip\x0dtriangle-list\x0etriangle-strip\x04\0\x16gpu-primitiv\
e-topology\x03\0x\x01m\x02\x03ccw\x02cw\x04\0\x0egpu-front-face\x03\0z\x01m\x03\x04\
none\x05front\x04back\x04\0\x0dgpu-cull-mode\x03\0|\x01y\x04\0\x15gpu-color-writ\
e-flags\x03\0~\x04\0\x0fgpu-color-write\x03\x01\x01m\x11\x04zero\x03one\x03src\x0d\
one-minus-src\x09src-alpha\x13one-minus-src-alpha\x03dst\x0done-minus-dst\x09dst\
-alpha\x13one-minus-dst-alpha\x13src-alpha-saturated\x08constant\x12one-minus-co\
nstant\x04src1\x0eone-minus-src1\x0asrc1-alpha\x14one-minus-src1-alpha\x04\0\x10\
gpu-blend-factor\x03\0\x81\x01\x01m\x05\x03add\x08subtract\x10reverse-subtract\x03\
min\x03max\x04\0\x13gpu-blend-operation\x03\0\x83\x01\x01k\x84\x01\x01k\x82\x01\x01\
r\x03\x09operation\x85\x01\x0asrc-factor\x86\x01\x0adst-factor\x86\x01\x04\0\x13\
gpu-blend-component\x03\0\x87\x01\x01r\x02\x05color\x88\x01\x05alpha\x88\x01\x04\
\0\x0fgpu-blend-state\x03\0\x89\x01\x01k\x8a\x01\x01k\xff\0\x01r\x03\x06format,\x05\
blend\x8b\x01\x0awrite-mask\x8c\x01\x04\0\x16gpu-color-target-state\x03\0\x8d\x01\
\x01k\x8e\x01\x01p\x8f\x01\x01r\x04\x07targets\x90\x01\x06module\xed\0\x0bentry-\
point\x0d\x09constants\xef\0\x04\0\x12gpu-fragment-state\x03\0\x91\x01\x01m\x08\x04\
keep\x04zero\x07replace\x06invert\x0fincrement-clamp\x0fdecrement-clamp\x0eincre\
ment-wrap\x0edecrement-wrap\x04\0\x15gpu-stencil-operation\x03\0\x93\x01\x01k\x94\
\x01\x01r\x04\x07compare:\x07fail-op\x95\x01\x0ddepth-fail-op\x95\x01\x07pass-op\
\x95\x01\x04\0\x16gpu-stencil-face-state\x03\0\x96\x01\x01m\x02\x06uint16\x06uin\
t32\x04\0\x10gpu-index-format\x03\0\x98\x01\x01k\xf9\0\x01k\x99\x01\x01k\xfb\0\x01\
k\xfd\0\x01r\x05\x08topology\x9a\x01\x12strip-index-format\x9b\x01\x0afront-face\
\x9c\x01\x09cull-mode\x9d\x01\x0funclipped-depth\x0f\x04\0\x13gpu-primitive-stat\
e\x03\0\x9e\x01\x01m)\x05uint8\x07uint8x2\x07uint8x4\x05sint8\x07sint8x2\x07sint\
8x4\x06unorm8\x08unorm8x2\x08unorm8x4\x06snorm8\x08snorm8x2\x08snorm8x4\x06uint1\
6\x08uint16x2\x08uint16x4\x06sint16\x08sint16x2\x08sint16x4\x07unorm16\x09unorm1\
6x2\x09unorm16x4\x07snorm16\x09snorm16x2\x09snorm16x4\x07float16\x09float16x2\x09\
float16x4\x07float32\x09float32x2\x09float32x3\x09float32x4\x06uint32\x08uint32x\
2\x08uint32x3\x08uint32x4\x06sint32\x08sint32x2\x08sint32x3\x08sint32x4\x0cunorm\
1010102\x0dunorm8x4-bgra\x04\0\x11gpu-vertex-format\x03\0\xa0\x01\x01m\x02\x06ve\
rtex\x08instance\x04\0\x14gpu-vertex-step-mode\x03\0\xa2\x01\x04\0\x12gpu-comman\
d-buffer\x03\x01\x01r\x01\x05label\x0d\x04\0\x1dgpu-command-buffer-descriptor\x03\
\0\xa5\x01\x04\0\x13gpu-command-encoder\x03\x01\x01r\x01\x05label\x0d\x04\0\x1eg\
pu-command-encoder-descriptor\x03\0\xa8\x01\x04\0\x18gpu-compute-pass-encoder\x03\
\x01\x04\0\x17gpu-render-pass-encoder\x03\x01\x01m\x02\x04load\x05clear\x04\0\x0b\
gpu-load-op\x03\0\xac\x01\x01m\x02\x05store\x07discard\x04\0\x0cgpu-store-op\x03\
\0\xae\x01\x04\0\x11gpu-render-bundle\x03\x01\x01r\x01\x05label\x0d\x04\0\x1cgpu\
-render-bundle-descriptor\x03\0\xb1\x01\x04\0\x19gpu-render-bundle-encoder\x03\x01\
\x01r\x01\x05label\x0d\x04\0\x14gpu-queue-descriptor\x03\0\xb4\x01\x01p\x15\x01k\
\xb6\x01\x01i\x13\x01k\xb8\x01\x01k\xb5\x01\x01r\x04\x11required-features\xb7\x01\
\x0frequired-limits\xb9\x01\x0ddefault-queue\xba\x01\x05label\x0d\x04\0\x15gpu-d\
evice-descriptor\x03\0\xbb\x01\x04\0\x09gpu-queue\x03\x01\x04\0\x0dgpu-query-set\
\x03\x01\x01m\x02\x09occlusion\x09timestamp\x04\0\x0egpu-query-type\x03\0\xbf\x01\
\x04\0\x12gpu-canvas-context\x03\x01\x01m\x02\x06opaque\x0dpremultiplied\x04\0\x15\
gpu-canvas-alpha-mode\x03\0\xc2\x01\x01m\x02\x08standard\x08extended\x04\0\x1cgp\
u-canvas-tone-mapping-mode\x03\0\xc4\x01\x01k\xc5\x01\x01r\x01\x04mode\xc6\x01\x04\
\0\x17gpu-canvas-tone-mapping\x03\0\xc7\x01\x01m\x02\x07unknown\x09destroyed\x04\
\0\x16gpu-device-lost-reason\x03\0\xc9\x01\x04\0\x14gpu-device-lost-info\x03\x01\
\x04\0\x09gpu-error\x03\x01\x01m\x03\x0avalidation\x0dout-of-memory\x08internal\x04\
\0\x10gpu-error-filter\x03\0\xcd\x01\x04\0\x1agpu-uncaptured-error-event\x03\x01\
\x01y\x04\0\x19gpu-buffer-dynamic-offset\x03\0\xd0\x01\x01y\x04\0\x11gpu-stencil\
-value\x03\0\xd2\x01\x01h&\x01k\xad\x01\x01k\xaf\x01\x01k\xd3\x01\x01r\x09\x04vi\
ew\xd4\x01\x11depth-clear-value9\x0ddepth-load-op\xd5\x01\x0edepth-store-op\xd6\x01\
\x0fdepth-read-only\x0f\x13stencil-clear-value\xd7\x01\x0fstencil-load-op\xd5\x01\
\x10stencil-store-op\xd6\x01\x11stencil-read-only\x0f\x04\0(gpu-render-pass-dept\
h-stencil-attachment\x03\0\xd8\x01\x01y\x04\0\x0fgpu-sample-mask\x03\0\xda\x01\x01\
z\x04\0\x0egpu-depth-bias\x03\0\xdc\x01\x01k\x97\x01\x01k\xdd\x01\x01r\x0a\x06fo\
rmat,\x13depth-write-enabled\x0f\x0ddepth-compare:\x0dstencil-front\xde\x01\x0cs\
tencil-back\xde\x01\x11stencil-read-mask\xd7\x01\x12stencil-write-mask\xd7\x01\x0a\
depth-bias\xdf\x01\x16depth-bias-slope-scale9\x10depth-bias-clamp9\x04\0\x17gpu-\
depth-stencil-state\x03\0\xe0\x01\x01w\x04\0\x0agpu-size64\x03\0\xe2\x01\x01r\x04\
\x04size\xe3\x01\x05usage\x1b\x12mapped-at-creation\x0f\x05label\x0d\x04\0\x15gp\
u-buffer-descriptor\x03\0\xe4\x01\x01k\xc3\0\x01k\xe3\x01\x01r\x03\x04type\xe6\x01\
\x12has-dynamic-offset\x0f\x10min-binding-size\xe7\x01\x04\0\x19gpu-buffer-bindi\
ng-layout\x03\0\xe8\x01\x01h\x17\x01r\x03\x06buffer\xea\x01\x06offset\xe7\x01\x04\
size\xe7\x01\x04\0\x12gpu-buffer-binding\x03\0\xeb\x01\x01h-\x01q\x03\x12gpu-buf\
fer-binding\x01\xec\x01\0\x0bgpu-sampler\x01\xed\x01\0\x10gpu-texture-view\x01\xd4\
\x01\0\x04\0\x14gpu-binding-resource\x03\0\xee\x01\x01y\x04\0\x16gpu-integer-coo\
rdinate\x03\0\xf0\x01\x01k,\x01k$\x01k*\x01k\xf1\x01\x01r\x09\x06format\xf2\x01\x09\
dimension\xcc\0\x05usage\xf3\x01\x06aspect\xf4\x01\x0ebase-mip-level\xf5\x01\x0f\
mip-level-count\xf5\x01\x10base-array-layer\xf5\x01\x11array-layer-count\xf5\x01\
\x05label\x0d\x04\0\x1bgpu-texture-view-descriptor\x03\0\xf6\x01\x01y\x04\0\x0bg\
pu-index32\x03\0\xf8\x01\x01k\xe9\x01\x01k\xc8\0\x01k\xce\0\x01k\xd3\0\x01r\x06\x07\
binding\xf9\x01\x0avisibility\xc0\0\x06buffer\xfa\x01\x07sampler\xfb\x01\x07text\
ure\xfc\x01\x0fstorage-texture\xfd\x01\x04\0\x1bgpu-bind-group-layout-entry\x03\0\
\xfe\x01\x01p\xff\x01\x01r\x02\x07entries\x80\x02\x05label\x0d\x04\0\x20gpu-bind\
-group-layout-descriptor\x03\0\x81\x02\x01r\x02\x07binding\xf9\x01\x08resource\xef\
\x01\x04\0\x14gpu-bind-group-entry\x03\0\x83\x02\x01p\x84\x02\x01r\x03\x06layout\
\xd6\0\x07entries\x85\x02\x05label\x0d\x04\0\x19gpu-bind-group-descriptor\x03\0\x86\
\x02\x01r\x03\x06format\xa1\x01\x06offset\xe3\x01\x0fshader-location\xf9\x01\x04\
\0\x14gpu-vertex-attribute\x03\0\x88\x02\x01k\xa3\x01\x01p\x89\x02\x01r\x03\x0ca\
rray-stride\xe3\x01\x09step-mode\x8a\x02\x0aattributes\x8b\x02\x04\0\x18gpu-vert\
ex-buffer-layout\x03\0\x8c\x02\x01k\x8d\x02\x01p\x8e\x02\x01k\x8f\x02\x01r\x04\x07\
buffers\x90\x02\x06module\xed\0\x0bentry-point\x0d\x09constants\xef\0\x04\0\x10g\
pu-vertex-state\x03\0\x91\x02\x01y\x04\0\x0agpu-size32\x03\0\x93\x02\x01k\x94\x02\
\x01k\xdb\x01\x01r\x03\x05count\x95\x02\x04mask\x96\x02\x19alpha-to-coverage-ena\
bled\x0f\x04\0\x15gpu-multisample-state\x03\0\x97\x02\x01k\x9f\x01\x01k\xe1\x01\x01\
k\x98\x02\x01k\x92\x01\x01r\x07\x06vertex\x92\x02\x09primitive\x99\x02\x0ddepth-\
stencil\x9a\x02\x0bmultisample\x9b\x02\x08fragment\x9c\x02\x06layout\xe4\0\x05la\
bel\x0d\x04\0\x1egpu-render-pipeline-descriptor\x03\0\x9d\x02\x01r\x03\x06offset\
\xe7\x01\x0dbytes-per-row\x95\x02\x0erows-per-image\x95\x02\x04\0\x1cgpu-texel-c\
opy-buffer-layout\x03\0\x9f\x02\x01r\x04\x06buffer\xea\x01\x06offset\xe7\x01\x0d\
bytes-per-row\x95\x02\x0erows-per-image\x95\x02\x04\0\x1agpu-texel-copy-buffer-i\
nfo\x03\0\xa1\x02\x01h\xbe\x01\x01r\x03\x09query-set\xa3\x02\x1dbeginning-of-pas\
s-write-index\x95\x02\x17end-of-pass-write-index\x95\x02\x04\0!gpu-compute-pass-\
timestamp-writes\x03\0\xa4\x02\x01k\xa5\x02\x01r\x02\x10timestamp-writes\xa6\x02\
\x05label\x0d\x04\0\x1bgpu-compute-pass-descriptor\x03\0\xa7\x02\x01r\x03\x09que\
ry-set\xa3\x02\x1dbeginning-of-pass-write-index\x95\x02\x17end-of-pass-write-ind\
ex\x95\x02\x04\0\x20gpu-render-pass-timestamp-writes\x03\0\xa9\x02\x01p\xf2\x01\x01\
r\x06\x0fdepth-read-only\x0f\x11stencil-read-only\x0f\x0dcolor-formats\xab\x02\x14\
depth-stencil-format\xf2\x01\x0csample-count\x95\x02\x05label\x0d\x04\0$gpu-rend\
er-bundle-encoder-descriptor\x03\0\xac\x02\x01r\x03\x04type\xc0\x01\x05count\x94\
\x02\x05label\x0d\x04\0\x18gpu-query-set-descriptor\x03\0\xae\x02\x01z\x04\0\x13\
gpu-signed-offset32\x03\0\xb0\x02\x01w\x04\0\x0egpu-size64-out\x03\0\xb2\x02\x01\
y\x04\0\x1agpu-integer-coordinate-out\x03\0\xb4\x02\x01y\x04\0\x0egpu-size32-out\
\x03\0\xb6\x02\x01y\x04\0\x12gpu-flags-constant\x03\0\xb8\x02\x01r\x04\x01ru\x01\
gu\x01bu\x01au\x04\0\x09gpu-color\x03\0\xba\x02\x01k\xd4\x01\x01k\xbb\x02\x01r\x06\
\x04view\xd4\x01\x0bdepth-slice\xf5\x01\x0eresolve-target\xbc\x02\x0bclear-value\
\xbd\x02\x07load-op\xad\x01\x08store-op\xaf\x01\x04\0\x20gpu-render-pass-color-a\
ttachment\x03\0\xbe\x02\x01k\xbf\x02\x01p\xc0\x02\x01k\xd9\x01\x01k\xa3\x02\x01k\
\xaa\x02\x01r\x06\x11color-attachments\xc1\x02\x18depth-stencil-attachment\xc2\x02\
\x13occlusion-query-set\xc3\x02\x10timestamp-writes\xc4\x02\x0emax-draw-count\xe7\
\x01\x05label\x0d\x04\0\x1agpu-render-pass-descriptor\x03\0\xc5\x02\x01r\x03\x01\
x\xf5\x01\x01y\xf5\x01\x01z\xf5\x01\x04\0\x0dgpu-origin3-d\x03\0\xc7\x02\x01h\x20\
\x01k\xc8\x02\x01r\x04\x07texture\xc9\x02\x09mip-level\xf5\x01\x06origin\xca\x02\
\x06aspect\xf4\x01\x04\0\x1bgpu-texel-copy-texture-info\x03\0\xcb\x02\x01r\x03\x05\
width\xf1\x01\x06height\xf5\x01\x15depth-or-array-layers\xf5\x01\x04\0\x0dgpu-ex\
tent3-d\x03\0\xcd\x02\x01k\"\x01p,\x01k\xd0\x02\x01r\x08\x04size\xce\x02\x0fmip-\
level-count\xf5\x01\x0csample-count\x95\x02\x09dimension\xcf\x02\x06format,\x05u\
sage$\x0cview-formats\xd1\x02\x05label\x0d\x04\0\x16gpu-texture-descriptor\x03\0\
\xd2\x02\x01m\x02\x04srgb\x0adisplay-p3\x04\0\x16predefined-color-space\x03\0\xd4\
\x02\x01h\x16\x01k\xd5\x02\x01k\xc8\x01\x01k\xc3\x01\x01r\x07\x06device\xd6\x02\x06\
format,\x05usage\xf3\x01\x0cview-formats\xd1\x02\x0bcolor-space\xd7\x02\x0ctone-\
mapping\xd8\x02\x0aalpha-mode\xd9\x02\x04\0\x18gpu-canvas-configuration\x03\0\xda\
\x02\x01i\x16\x01r\x07\x06device\xdc\x02\x06format,\x05usage\xf3\x01\x0cview-for\
mats\xd1\x02\x0bcolor-space\xd7\x02\x0ctone-mapping\xd8\x02\x0aalpha-mode\xd9\x02\
\x04\0\x1egpu-canvas-configuration-owned\x03\0\xdd\x02\x01q\x03\x10validation-er\
ror\0\0\x13out-of-memory-error\0\0\x0einternal-error\0\0\x04\0\x0egpu-error-kind\
\x03\0\xdf\x02\x01q\x02\x0atype-error\0\0\x0foperation-error\0\0\x04\0\x19reques\
t-device-error-kind\x03\0\xe1\x02\x01r\x02\x04kind\xe2\x02\x07messages\x04\0\x14\
request-device-error\x03\0\xe3\x02\x01q\x01\x12gpu-pipeline-error\x01\xe1\0\0\x04\
\0\x1acreate-pipeline-error-kind\x03\0\xe5\x02\x01r\x02\x04kind\xe6\x02\x07messa\
ges\x04\0\x15create-pipeline-error\x03\0\xe7\x02\x01q\x01\x0atype-error\0\0\x04\0\
\x1bcreate-query-set-error-kind\x03\0\xe9\x02\x01r\x02\x04kind\xea\x02\x07messag\
es\x04\0\x16create-query-set-error\x03\0\xeb\x02\x01q\x01\x0foperation-error\0\0\
\x04\0\x1apop-error-scope-error-kind\x03\0\xed\x02\x01r\x02\x04kind\xee\x02\x07m\
essages\x04\0\x15pop-error-scope-error\x03\0\xef\x02\x01q\x03\x0foperation-error\
\0\0\x0brange-error\0\0\x0babort-error\0\0\x04\0\x14map-async-error-kind\x03\0\xf1\
\x02\x01r\x02\x04kind\xf2\x02\x07messages\x04\0\x0fmap-async-error\x03\0\xf3\x02\
\x01q\x03\x0foperation-error\0\0\x0brange-error\0\0\x0atype-error\0\0\x04\0\x1bg\
et-mapped-range-error-kind\x03\0\xf5\x02\x01r\x02\x04kind\xf6\x02\x07messages\x04\
\0\x16get-mapped-range-error\x03\0\xf7\x02\x01q\x01\x0babort-error\0\0\x04\0\x10\
unmap-error-kind\x03\0\xf9\x02\x01r\x02\x04kind\xfa\x02\x07messages\x04\0\x0bunm\
ap-error\x03\0\xfb\x02\x01q\x01\x0brange-error\0\0\x04\0\x19set-bind-group-error\
-kind\x03\0\xfd\x02\x01r\x02\x04kind\xfe\x02\x07messages\x04\0\x14set-bind-group\
-error\x03\0\xff\x02\x01q\x01\x0foperation-error\0\0\x04\0\x17write-buffer-error\
-kind\x03\0\x81\x03\x01r\x02\x04kind\x82\x03\x07messages\x04\0\x12write-buffer-e\
rror\x03\0\x83\x03\x01h\x06\x01@\x01\x04self\x85\x03\0y\x04\05[method]gpu-suppor\
ted-limits.max-texture-dimension1-d\x01\x86\x03\x04\05[method]gpu-supported-limi\
ts.max-texture-dimension2-d\x01\x86\x03\x04\05[method]gpu-supported-limits.max-t\
exture-dimension3-d\x01\x86\x03\x04\05[method]gpu-supported-limits.max-texture-a\
rray-layers\x01\x86\x03\x04\0,[method]gpu-supported-limits.max-bind-groups\x01\x86\
\x03\x04\0@[method]gpu-supported-limits.max-bind-groups-plus-vertex-buffers\x01\x86\
\x03\x04\08[method]gpu-supported-limits.max-bindings-per-bind-group\x01\x86\x03\x04\
\0L[method]gpu-supported-limits.max-dynamic-uniform-buffers-per-pipeline-layout\x01\
\x86\x03\x04\0L[method]gpu-supported-limits.max-dynamic-storage-buffers-per-pipe\
line-layout\x01\x86\x03\x04\0B[method]gpu-supported-limits.max-sampled-textures-\
per-shader-stage\x01\x86\x03\x04\0:[method]gpu-supported-limits.max-samplers-per\
-shader-stage\x01\x86\x03\x04\0A[method]gpu-supported-limits.max-storage-buffers\
-per-shader-stage\x01\x86\x03\x04\0B[method]gpu-supported-limits.max-storage-tex\
tures-per-shader-stage\x01\x86\x03\x04\0A[method]gpu-supported-limits.max-unifor\
m-buffers-per-shader-stage\x01\x86\x03\x01@\x01\x04self\x85\x03\0w\x04\0<[method\
]gpu-supported-limits.max-uniform-buffer-binding-size\x01\x87\x03\x04\0<[method]\
gpu-supported-limits.max-storage-buffer-binding-size\x01\x87\x03\x04\0@[method]g\
pu-supported-limits.min-uniform-buffer-offset-alignment\x01\x86\x03\x04\0@[metho\
d]gpu-supported-limits.min-storage-buffer-offset-alignment\x01\x86\x03\x04\0/[me\
thod]gpu-supported-limits.max-vertex-buffers\x01\x86\x03\x04\0,[method]gpu-suppo\
rted-limits.max-buffer-size\x01\x87\x03\x04\02[method]gpu-supported-limits.max-v\
ertex-attributes\x01\x86\x03\x04\0;[method]gpu-supported-limits.max-vertex-buffe\
r-array-stride\x01\x86\x03\x04\0=[method]gpu-supported-limits.max-inter-stage-sh\
ader-variables\x01\x86\x03\x04\02[method]gpu-supported-limits.max-color-attachme\
nts\x01\x86\x03\x04\0B[method]gpu-supported-limits.max-color-attachment-bytes-pe\
r-sample\x01\x86\x03\x04\0?[method]gpu-supported-limits.max-compute-workgroup-st\
orage-size\x01\x86\x03\x04\0B[method]gpu-supported-limits.max-compute-invocation\
s-per-workgroup\x01\x86\x03\x04\09[method]gpu-supported-limits.max-compute-workg\
roup-size-x\x01\x86\x03\x04\09[method]gpu-supported-limits.max-compute-workgroup\
-size-y\x01\x86\x03\x04\09[method]gpu-supported-limits.max-compute-workgroup-siz\
e-z\x01\x86\x03\x04\0A[method]gpu-supported-limits.max-compute-workgroups-per-di\
mension\x01\x86\x03\x01h\x07\x01@\x02\x04self\x88\x03\x05values\0\x7f\x04\0\"[me\
thod]gpu-supported-features.has\x01\x89\x03\x01h\x08\x01@\x02\x04self\x8a\x03\x05\
values\0\x7f\x04\0\"[method]wgsl-language-features.has\x01\x8b\x03\x01h\x09\x01@\
\x01\x04self\x8c\x03\0s\x04\0\x1f[method]gpu-adapter-info.vendor\x01\x8d\x03\x04\
\0%[method]gpu-adapter-info.architecture\x01\x8d\x03\x04\0\x1f[method]gpu-adapte\
r-info.device\x01\x8d\x03\x04\0$[method]gpu-adapter-info.description\x01\x8d\x03\
\x01@\x01\x04self\x8c\x03\0y\x04\0*[method]gpu-adapter-info.subgroup-min-size\x01\
\x8e\x03\x04\0*[method]gpu-adapter-info.subgroup-max-size\x01\x8e\x03\x01h\x0a\x01\
k\x11\x01i\x12\x01k\x91\x03\x01@\x02\x04self\x8f\x03\x07options\x90\x03\0\x92\x03\
\x04\0\x1b[method]gpu.request-adapter\x01\x93\x03\x01@\x01\x04self\x8f\x03\0,\x04\
\0'[method]gpu.get-preferred-canvas-format\x01\x94\x03\x01i\x08\x01@\x01\x04self\
\x8f\x03\0\x95\x03\x04\0\"[method]gpu.wgsl-language-features\x01\x96\x03\x01h\x12\
\x01i\x07\x01@\x01\x04self\x97\x03\0\x98\x03\x04\0\x1c[method]gpu-adapter.featur\
es\x01\x99\x03\x01i\x06\x01@\x01\x04self\x97\x03\0\x9a\x03\x04\0\x1a[method]gpu-\
adapter.limits\x01\x9b\x03\x01i\x09\x01@\x01\x04self\x97\x03\0\x9c\x03\x04\0\x18\
[method]gpu-adapter.info\x01\x9d\x03\x01@\x01\x04self\x97\x03\0\x7f\x04\0'[metho\
d]gpu-adapter.is-fallback-adapter\x01\x9e\x03\x01k\xbc\x01\x01j\x01\xdc\x02\x01\xe4\
\x02\x01@\x02\x04self\x97\x03\x0adescriptor\x9f\x03\0\xa0\x03\x04\0\"[method]gpu\
-adapter.request-device\x01\xa1\x03\x01@\0\0\xb8\x01\x04\0%[constructor]record-o\
ption-gpu-size64\x01\xa2\x03\x01h\x13\x01@\x03\x04self\xa3\x03\x03keys\x05value\xe7\
\x01\x01\0\x04\0$[method]record-option-gpu-size64.add\x01\xa4\x03\x01k\xe7\x01\x01\
@\x02\x04self\xa3\x03\x03keys\0\xa5\x03\x04\0$[method]record-option-gpu-size64.g\
et\x01\xa6\x03\x01@\x02\x04self\xa3\x03\x03keys\0\x7f\x04\0$[method]record-optio\
n-gpu-size64.has\x01\xa7\x03\x01@\x02\x04self\xa3\x03\x03keys\x01\0\x04\0'[metho\
d]record-option-gpu-size64.remove\x01\xa8\x03\x01ps\x01@\x01\x04self\xa3\x03\0\xa9\
\x03\x04\0%[method]record-option-gpu-size64.keys\x01\xaa\x03\x01p\xe7\x01\x01@\x01\
\x04self\xa3\x03\0\xab\x03\x04\0'[method]record-option-gpu-size64.values\x01\xac\
\x03\x01o\x02s\xe7\x01\x01p\xad\x03\x01@\x01\x04self\xa3\x03\0\xae\x03\x04\0([me\
thod]record-option-gpu-size64.entries\x01\xaf\x03\x01@\x01\x04self\xd6\x02\0\x98\
\x03\x04\0\x1b[method]gpu-device.features\x01\xb0\x03\x01@\x01\x04self\xd6\x02\0\
\x9a\x03\x04\0\x19[method]gpu-device.limits\x01\xb1\x03\x01@\x01\x04self\xd6\x02\
\0\x9c\x03\x04\0\x1f[method]gpu-device.adapter-info\x01\xb2\x03\x01i\xbd\x01\x01\
@\x01\x04self\xd6\x02\0\xb3\x03\x04\0\x18[method]gpu-device.queue\x01\xb4\x03\x01\
@\x01\x04self\xd6\x02\x01\0\x04\0\x1a[method]gpu-device.destroy\x01\xb5\x03\x01i\
\x17\x01@\x02\x04self\xd6\x02\x0adescriptor\xe5\x01\0\xb6\x03\x04\0\x20[method]g\
pu-device.create-buffer\x01\xb7\x03\x01i\x20\x01@\x02\x04self\xd6\x02\x0adescrip\
tor\xd3\x02\0\xb8\x03\x04\0![method]gpu-device.create-texture\x01\xb9\x03\x01k=\x01\
i-\x01@\x02\x04self\xd6\x02\x0adescriptor\xba\x03\0\xbb\x03\x04\0![method]gpu-de\
vice.create-sampler\x01\xbc\x03\x01i>\x01@\x02\x04self\xd6\x02\x0adescriptor\x82\
\x02\0\xbd\x03\x04\0+[method]gpu-device.create-bind-group-layout\x01\xbe\x03\x01\
iU\x01@\x02\x04self\xd6\x02\x0adescriptor\xda\0\0\xbf\x03\x04\0)[method]gpu-devi\
ce.create-pipeline-layout\x01\xc0\x03\x01iT\x01@\x02\x04self\xd6\x02\x0adescript\
or\x87\x02\0\xc1\x03\x04\0$[method]gpu-device.create-bind-group\x01\xc2\x03\x01i\
[\x01@\x02\x04self\xd6\x02\x0adescriptor\xeb\0\0\xc3\x03\x04\0'[method]gpu-devic\
e.create-shader-module\x01\xc4\x03\x01it\x01@\x02\x04self\xd6\x02\x0adescriptor\xf6\
\0\0\xc5\x03\x04\0*[method]gpu-device.create-compute-pipeline\x01\xc6\x03\x01iw\x01\
@\x02\x04self\xd6\x02\x0adescriptor\x9e\x02\0\xc7\x03\x04\0)[method]gpu-device.c\
reate-render-pipeline\x01\xc8\x03\x01j\x01\xc5\x03\x01\xe8\x02\x01@\x02\x04self\xd6\
\x02\x0adescriptor\xf6\0\0\xc9\x03\x04\00[method]gpu-device.create-compute-pipel\
ine-async\x01\xca\x03\x01j\x01\xc7\x03\x01\xe8\x02\x01@\x02\x04self\xd6\x02\x0ad\
escriptor\x9e\x02\0\xcb\x03\x04\0/[method]gpu-device.create-render-pipeline-asyn\
c\x01\xcc\x03\x01k\xa9\x01\x01i\xa7\x01\x01@\x02\x04self\xd6\x02\x0adescriptor\xcd\
\x03\0\xce\x03\x04\0)[method]gpu-device.create-command-encoder\x01\xcf\x03\x01i\xb3\
\x01\x01@\x02\x04self\xd6\x02\x0adescriptor\xad\x02\0\xd0\x03\x04\0/[method]gpu-\
device.create-render-bundle-encoder\x01\xd1\x03\x01i\xbe\x01\x01j\x01\xd2\x03\x01\
\xec\x02\x01@\x02\x04self\xd6\x02\x0adescriptor\xaf\x02\0\xd3\x03\x04\0#[method]\
gpu-device.create-query-set\x01\xd4\x03\x01@\x01\x04self\xd6\x02\0s\x04\0\x18[me\
thod]gpu-device.label\x01\xd5\x03\x01@\x02\x04self\xd6\x02\x05labels\x01\0\x04\0\
\x1c[method]gpu-device.set-label\x01\xd6\x03\x01i\xcb\x01\x01@\x01\x04self\xd6\x02\
\0\xd7\x03\x04\0\x17[method]gpu-device.lost\x01\xd8\x03\x01@\x02\x04self\xd6\x02\
\x06filter\xce\x01\x01\0\x04\0#[method]gpu-device.push-error-scope\x01\xd9\x03\x01\
i\xcc\x01\x01k\xda\x03\x01j\x01\xdb\x03\x01\xf0\x02\x01@\x01\x04self\xd6\x02\0\xdc\
\x03\x04\0\"[method]gpu-device.pop-error-scope\x01\xdd\x03\x01i\x01\x01@\x01\x04\
self\xd6\x02\0\xde\x03\x04\0.[method]gpu-device.onuncapturederror-subscribe\x01\xdf\
\x03\x01h\x03\x01@\x02\x04self\xd6\x02\x07context\xe0\x03\x01\0\x04\0+[method]gp\
u-device.connect-graphics-context\x01\xe1\x03\x01@\x01\x04self\xea\x01\0\xb3\x02\
\x04\0\x17[method]gpu-buffer.size\x01\xe2\x03\x01@\x01\x04self\xea\x01\0\xb9\x02\
\x04\0\x18[method]gpu-buffer.usage\x01\xe3\x03\x01@\x01\x04self\xea\x01\0\x19\x04\
\0\x1c[method]gpu-buffer.map-state\x01\xe4\x03\x01j\0\x01\xf4\x02\x01@\x04\x04se\
lf\xea\x01\x04mode\x1e\x06offset\xe7\x01\x04size\xe7\x01\0\xe5\x03\x04\0\x1c[met\
hod]gpu-buffer.map-async\x01\xe6\x03\x01p}\x01j\x01\xe7\x03\x01\xf8\x02\x01@\x03\
\x04self\xea\x01\x06offset\xe7\x01\x04size\xe7\x01\0\xe8\x03\x04\01[method]gpu-b\
uffer.get-mapped-range-get-with-copy\x01\xe9\x03\x01j\0\x01\xfc\x02\x01@\x01\x04\
self\xea\x01\0\xea\x03\x04\0\x18[method]gpu-buffer.unmap\x01\xeb\x03\x01@\x01\x04\
self\xea\x01\x01\0\x04\0\x1a[method]gpu-buffer.destroy\x01\xec\x03\x01@\x01\x04s\
elf\xea\x01\0s\x04\0\x18[method]gpu-buffer.label\x01\xed\x03\x01@\x02\x04self\xea\
\x01\x05labels\x01\0\x04\0\x1c[method]gpu-buffer.set-label\x01\xee\x03\x01j\0\x01\
\xf8\x02\x01@\x04\x04self\xea\x01\x04data\xe7\x03\x06offset\xe7\x01\x04size\xe7\x01\
\0\xef\x03\x04\01[method]gpu-buffer.get-mapped-range-set-with-copy\x01\xf0\x03\x01\
@\0\0\xb9\x02\x04\0![static]gpu-buffer-usage.MAP-READ\x01\xf1\x03\x04\0\"[static\
]gpu-buffer-usage.MAP-WRITE\x01\xf1\x03\x04\0![static]gpu-buffer-usage.COPY-SRC\x01\
\xf1\x03\x04\0![static]gpu-buffer-usage.COPY-DST\x01\xf1\x03\x04\0\x1e[static]gp\
u-buffer-usage.INDEX\x01\xf1\x03\x04\0\x1f[static]gpu-buffer-usage.VERTEX\x01\xf1\
\x03\x04\0\x20[static]gpu-buffer-usage.UNIFORM\x01\xf1\x03\x04\0\x20[static]gpu-\
buffer-usage.STORAGE\x01\xf1\x03\x04\0![static]gpu-buffer-usage.INDIRECT\x01\xf1\
\x03\x04\0&[static]gpu-buffer-usage.QUERY-RESOLVE\x01\xf1\x03\x04\0\x19[static]g\
pu-map-mode.READ\x01\xf1\x03\x04\0\x1a[static]gpu-map-mode.WRITE\x01\xf1\x03\x01\
k\xf7\x01\x01i&\x01@\x02\x04self\xc9\x02\x0adescriptor\xf2\x03\0\xf3\x03\x04\0\x1f\
[method]gpu-texture.create-view\x01\xf4\x03\x01@\x01\x04self\xc9\x02\x01\0\x04\0\
\x1b[method]gpu-texture.destroy\x01\xf5\x03\x01@\x01\x04self\xc9\x02\0\xb5\x02\x04\
\0\x19[method]gpu-texture.width\x01\xf6\x03\x04\0\x1a[method]gpu-texture.height\x01\
\xf6\x03\x04\0)[method]gpu-texture.depth-or-array-layers\x01\xf6\x03\x04\0#[meth\
od]gpu-texture.mip-level-count\x01\xf6\x03\x01@\x01\x04self\xc9\x02\0\xb7\x02\x04\
\0\x20[method]gpu-texture.sample-count\x01\xf7\x03\x01@\x01\x04self\xc9\x02\0\"\x04\
\0\x1d[method]gpu-texture.dimension\x01\xf8\x03\x01@\x01\x04self\xc9\x02\0,\x04\0\
\x1a[method]gpu-texture.format\x01\xf9\x03\x01@\x01\x04self\xc9\x02\0\xb9\x02\x04\
\0\x19[method]gpu-texture.usage\x01\xfa\x03\x01@\x01\x04self\xc9\x02\0s\x04\0\x19\
[method]gpu-texture.label\x01\xfb\x03\x01@\x02\x04self\xc9\x02\x05labels\x01\0\x04\
\0\x1d[method]gpu-texture.set-label\x01\xfc\x03\x01i\x05\x01@\x01\x06buffer\xfd\x03\
\0\xb8\x03\x04\0([static]gpu-texture.from-graphics-buffer\x01\xfe\x03\x04\0\"[st\
atic]gpu-texture-usage.COPY-SRC\x01\xf1\x03\x04\0\"[static]gpu-texture-usage.COP\
Y-DST\x01\xf1\x03\x04\0)[static]gpu-texture-usage.TEXTURE-BINDING\x01\xf1\x03\x04\
\0)[static]gpu-texture-usage.STORAGE-BINDING\x01\xf1\x03\x04\0+[static]gpu-textu\
re-usage.RENDER-ATTACHMENT\x01\xf1\x03\x01@\x01\x04self\xd4\x01\0s\x04\0\x1e[met\
hod]gpu-texture-view.label\x01\xff\x03\x01@\x02\x04self\xd4\x01\x05labels\x01\0\x04\
\0\"[method]gpu-texture-view.set-label\x01\x80\x04\x01@\x01\x04self\xed\x01\0s\x04\
\0\x19[method]gpu-sampler.label\x01\x81\x04\x01@\x02\x04self\xed\x01\x05labels\x01\
\0\x04\0\x1d[method]gpu-sampler.set-label\x01\x82\x04\x01@\x01\x04self\xd6\0\0s\x04\
\0#[method]gpu-bind-group-layout.label\x01\x83\x04\x01@\x02\x04self\xd6\0\x05lab\
els\x01\0\x04\0'[method]gpu-bind-group-layout.set-label\x01\x84\x04\x04\0\x1f[st\
atic]gpu-shader-stage.VERTEX\x01\xf1\x03\x04\0![static]gpu-shader-stage.FRAGMENT\
\x01\xf1\x03\x04\0\x20[static]gpu-shader-stage.COMPUTE\x01\xf1\x03\x01hT\x01@\x01\
\x04self\x85\x04\0s\x04\0\x1c[method]gpu-bind-group.label\x01\x86\x04\x01@\x02\x04\
self\x85\x04\x05labels\x01\0\x04\0\x20[method]gpu-bind-group.set-label\x01\x87\x04\
\x01@\x01\x04self\xe2\0\0s\x04\0![method]gpu-pipeline-layout.label\x01\x88\x04\x01\
@\x02\x04self\xe2\0\x05labels\x01\0\x04\0%[method]gpu-pipeline-layout.set-label\x01\
\x89\x04\x01i_\x01@\x01\x04self\xed\0\0\x8a\x04\x04\0.[method]gpu-shader-module.\
get-compilation-info\x01\x8b\x04\x01@\x01\x04self\xed\0\0s\x04\0\x1f[method]gpu-\
shader-module.label\x01\x8c\x04\x01@\x02\x04self\xed\0\x05labels\x01\0\x04\0#[me\
thod]gpu-shader-module.set-label\x01\x8d\x04\x01h^\x01@\x01\x04self\x8e\x04\0s\x04\
\0'[method]gpu-compilation-message.message\x01\x8f\x04\x01@\x01\x04self\x8e\x04\0\
\xdd\0\x04\0$[method]gpu-compilation-message.type\x01\x90\x04\x01@\x01\x04self\x8e\
\x04\0w\x04\0([method]gpu-compilation-message.line-num\x01\x91\x04\x04\0([method\
]gpu-compilation-message.line-pos\x01\x91\x04\x04\0&[method]gpu-compilation-mess\
age.offset\x01\x91\x04\x04\0&[method]gpu-compilation-message.length\x01\x91\x04\x01\
h_\x01i^\x01p\x93\x04\x01@\x01\x04self\x92\x04\0\x94\x04\x04\0%[method]gpu-compi\
lation-info.messages\x01\x95\x04\x01@\0\0\xee\0\x04\0/[constructor]record-gpu-pi\
peline-constant-value\x01\x96\x04\x01hl\x01@\x03\x04self\x97\x04\x03keys\x05valu\
e\xf3\0\x01\0\x04\0.[method]record-gpu-pipeline-constant-value.add\x01\x98\x04\x01\
k\xf3\0\x01@\x02\x04self\x97\x04\x03keys\0\x99\x04\x04\0.[method]record-gpu-pipe\
line-constant-value.get\x01\x9a\x04\x01@\x02\x04self\x97\x04\x03keys\0\x7f\x04\0\
.[method]record-gpu-pipeline-constant-value.has\x01\x9b\x04\x01@\x02\x04self\x97\
\x04\x03keys\x01\0\x04\01[method]record-gpu-pipeline-constant-value.remove\x01\x9c\
\x04\x01@\x01\x04self\x97\x04\0\xa9\x03\x04\0/[method]record-gpu-pipeline-consta\
nt-value.keys\x01\x9d\x04\x01p\xf3\0\x01@\x01\x04self\x97\x04\0\x9e\x04\x04\01[m\
ethod]record-gpu-pipeline-constant-value.values\x01\x9f\x04\x01o\x02s\xf3\0\x01p\
\xa0\x04\x01@\x01\x04self\x97\x04\0\xa1\x04\x04\02[method]record-gpu-pipeline-co\
nstant-value.entries\x01\xa2\x04\x01ht\x01@\x01\x04self\xa3\x04\0s\x04\0\"[metho\
d]gpu-compute-pipeline.label\x01\xa4\x04\x01@\x02\x04self\xa3\x04\x05labels\x01\0\
\x04\0&[method]gpu-compute-pipeline.set-label\x01\xa5\x04\x01@\x02\x04self\xa3\x04\
\x05indexy\0\xbd\x03\x04\02[method]gpu-compute-pipeline.get-bind-group-layout\x01\
\xa6\x04\x01hw\x01@\x01\x04self\xa7\x04\0s\x04\0![method]gpu-render-pipeline.lab\
el\x01\xa8\x04\x01@\x02\x04self\xa7\x04\x05labels\x01\0\x04\0%[method]gpu-render\
-pipeline.set-label\x01\xa9\x04\x01@\x02\x04self\xa7\x04\x05indexy\0\xbd\x03\x04\
\01[method]gpu-render-pipeline.get-bind-group-layout\x01\xaa\x04\x04\0\x1b[stati\
c]gpu-color-write.RED\x01\xf1\x03\x04\0\x1d[static]gpu-color-write.GREEN\x01\xf1\
\x03\x04\0\x1c[static]gpu-color-write.BLUE\x01\xf1\x03\x04\0\x1d[static]gpu-colo\
r-write.ALPHA\x01\xf1\x03\x04\0\x1b[static]gpu-color-write.ALL\x01\xf1\x03\x01h\xa4\
\x01\x01@\x01\x04self\xab\x04\0s\x04\0\x20[method]gpu-command-buffer.label\x01\xac\
\x04\x01@\x02\x04self\xab\x04\x05labels\x01\0\x04\0$[method]gpu-command-buffer.s\
et-label\x01\xad\x04\x01h\xa7\x01\x01i\xab\x01\x01@\x02\x04self\xae\x04\x0adescr\
iptor\xc6\x02\0\xaf\x04\x04\0-[method]gpu-command-encoder.begin-render-pass\x01\xb0\
\x04\x01k\xa8\x02\x01i\xaa\x01\x01@\x02\x04self\xae\x04\x0adescriptor\xb1\x04\0\xb2\
\x04\x04\0.[method]gpu-command-encoder.begin-compute-pass\x01\xb3\x04\x01@\x06\x04\
self\xae\x04\x06source\xea\x01\x0dsource-offset\xe3\x01\x0bdestination\xea\x01\x12\
destination-offset\xe3\x01\x04size\xe3\x01\x01\0\x04\01[method]gpu-command-encod\
er.copy-buffer-to-buffer\x01\xb4\x04\x01@\x04\x04self\xae\x04\x06source\xa2\x02\x0b\
destination\xcc\x02\x09copy-size\xce\x02\x01\0\x04\02[method]gpu-command-encoder\
.copy-buffer-to-texture\x01\xb5\x04\x01@\x04\x04self\xae\x04\x06source\xcc\x02\x0b\
destination\xa2\x02\x09copy-size\xce\x02\x01\0\x04\02[method]gpu-command-encoder\
.copy-texture-to-buffer\x01\xb6\x04\x01@\x04\x04self\xae\x04\x06source\xcc\x02\x0b\
destination\xcc\x02\x09copy-size\xce\x02\x01\0\x04\03[method]gpu-command-encoder\
.copy-texture-to-texture\x01\xb7\x04\x01@\x04\x04self\xae\x04\x06buffer\xea\x01\x06\
offset\xe7\x01\x04size\xe7\x01\x01\0\x04\0([method]gpu-command-encoder.clear-buf\
fer\x01\xb8\x04\x01@\x06\x04self\xae\x04\x09query-set\xa3\x02\x0bfirst-query\x94\
\x02\x0bquery-count\x94\x02\x0bdestination\xea\x01\x12destination-offset\xe3\x01\
\x01\0\x04\0-[method]gpu-command-encoder.resolve-query-set\x01\xb9\x04\x01k\xa6\x01\
\x01i\xa4\x01\x01@\x02\x04self\xae\x04\x0adescriptor\xba\x04\0\xbb\x04\x04\0\"[m\
ethod]gpu-command-encoder.finish\x01\xbc\x04\x01@\x01\x04self\xae\x04\0s\x04\0![\
method]gpu-command-encoder.label\x01\xbd\x04\x01@\x02\x04self\xae\x04\x05labels\x01\
\0\x04\0%[method]gpu-command-encoder.set-label\x01\xbe\x04\x01@\x02\x04self\xae\x04\
\x0bgroup-labels\x01\0\x04\0,[method]gpu-command-encoder.push-debug-group\x01\xbf\
\x04\x01@\x01\x04self\xae\x04\x01\0\x04\0+[method]gpu-command-encoder.pop-debug-\
group\x01\xc0\x04\x01@\x02\x04self\xae\x04\x0cmarker-labels\x01\0\x04\0/[method]\
gpu-command-encoder.insert-debug-marker\x01\xc1\x04\x01h\xaa\x01\x01@\x02\x04sel\
f\xc2\x04\x08pipeline\xa3\x04\x01\0\x04\0-[method]gpu-compute-pass-encoder.set-p\
ipeline\x01\xc3\x04\x01@\x04\x04self\xc2\x04\x11workgroup-count-x\x94\x02\x11wor\
kgroup-count-y\x95\x02\x11workgroup-count-z\x95\x02\x01\0\x04\04[method]gpu-comp\
ute-pass-encoder.dispatch-workgroups\x01\xc4\x04\x01@\x03\x04self\xc2\x04\x0find\
irect-buffer\xea\x01\x0findirect-offset\xe3\x01\x01\0\x04\0=[method]gpu-compute-\
pass-encoder.dispatch-workgroups-indirect\x01\xc5\x04\x01@\x01\x04self\xc2\x04\x01\
\0\x04\0$[method]gpu-compute-pass-encoder.end\x01\xc6\x04\x01@\x01\x04self\xc2\x04\
\0s\x04\0&[method]gpu-compute-pass-encoder.label\x01\xc7\x04\x01@\x02\x04self\xc2\
\x04\x05labels\x01\0\x04\0*[method]gpu-compute-pass-encoder.set-label\x01\xc8\x04\
\x01@\x02\x04self\xc2\x04\x0bgroup-labels\x01\0\x04\01[method]gpu-compute-pass-e\
ncoder.push-debug-group\x01\xc9\x04\x04\00[method]gpu-compute-pass-encoder.pop-d\
ebug-group\x01\xc6\x04\x01@\x02\x04self\xc2\x04\x0cmarker-labels\x01\0\x04\04[me\
thod]gpu-compute-pass-encoder.insert-debug-marker\x01\xca\x04\x01k\x85\x04\x01p\xd1\
\x01\x01k\xcc\x04\x01j\0\x01\x80\x03\x01@\x06\x04self\xc2\x04\x05index\xf9\x01\x0a\
bind-group\xcb\x04\x14dynamic-offsets-data\xcd\x04\x1adynamic-offsets-data-start\
\xe7\x01\x1bdynamic-offsets-data-length\x95\x02\0\xce\x04\x04\0/[method]gpu-comp\
ute-pass-encoder.set-bind-group\x01\xcf\x04\x01h\xab\x01\x01@\x07\x04self\xd0\x04\
\x01xv\x01yv\x05widthv\x06heightv\x09min-depthv\x09max-depthv\x01\0\x04\0,[metho\
d]gpu-render-pass-encoder.set-viewport\x01\xd1\x04\x01@\x05\x04self\xd0\x04\x01x\
\xf1\x01\x01y\xf1\x01\x05width\xf1\x01\x06height\xf1\x01\x01\0\x04\00[method]gpu\
-render-pass-encoder.set-scissor-rect\x01\xd2\x04\x01@\x02\x04self\xd0\x04\x05co\
lor\xbb\x02\x01\0\x04\02[method]gpu-render-pass-encoder.set-blend-constant\x01\xd3\
\x04\x01@\x02\x04self\xd0\x04\x09reference\xd3\x01\x01\0\x04\05[method]gpu-rende\
r-pass-encoder.set-stencil-reference\x01\xd4\x04\x01@\x02\x04self\xd0\x04\x0bque\
ry-index\x94\x02\x01\0\x04\05[method]gpu-render-pass-encoder.begin-occlusion-que\
ry\x01\xd5\x04\x01@\x01\x04self\xd0\x04\x01\0\x04\03[method]gpu-render-pass-enco\
der.end-occlusion-query\x01\xd6\x04\x01h\xb0\x01\x01p\xd7\x04\x01@\x02\x04self\xd0\
\x04\x07bundles\xd8\x04\x01\0\x04\0/[method]gpu-render-pass-encoder.execute-bund\
les\x01\xd9\x04\x04\0#[method]gpu-render-pass-encoder.end\x01\xd6\x04\x01@\x01\x04\
self\xd0\x04\0s\x04\0%[method]gpu-render-pass-encoder.label\x01\xda\x04\x01@\x02\
\x04self\xd0\x04\x05labels\x01\0\x04\0)[method]gpu-render-pass-encoder.set-label\
\x01\xdb\x04\x01@\x02\x04self\xd0\x04\x0bgroup-labels\x01\0\x04\00[method]gpu-re\
nder-pass-encoder.push-debug-group\x01\xdc\x04\x04\0/[method]gpu-render-pass-enc\
oder.pop-debug-group\x01\xd6\x04\x01@\x02\x04self\xd0\x04\x0cmarker-labels\x01\0\
\x04\03[method]gpu-render-pass-encoder.insert-debug-marker\x01\xdd\x04\x01@\x06\x04\
self\xd0\x04\x05index\xf9\x01\x0abind-group\xcb\x04\x14dynamic-offsets-data\xcd\x04\
\x1adynamic-offsets-data-start\xe7\x01\x1bdynamic-offsets-data-length\x95\x02\0\xce\
\x04\x04\0.[method]gpu-render-pass-encoder.set-bind-group\x01\xde\x04\x01@\x02\x04\
self\xd0\x04\x08pipeline\xa7\x04\x01\0\x04\0,[method]gpu-render-pass-encoder.set\
-pipeline\x01\xdf\x04\x01@\x05\x04self\xd0\x04\x06buffer\xea\x01\x0cindex-format\
\x99\x01\x06offset\xe7\x01\x04size\xe7\x01\x01\0\x04\00[method]gpu-render-pass-e\
ncoder.set-index-buffer\x01\xe0\x04\x01k\xea\x01\x01@\x05\x04self\xd0\x04\x04slo\
t\xf9\x01\x06buffer\xe1\x04\x06offset\xe7\x01\x04size\xe7\x01\x01\0\x04\01[metho\
d]gpu-render-pass-encoder.set-vertex-buffer\x01\xe2\x04\x01@\x05\x04self\xd0\x04\
\x0cvertex-count\x94\x02\x0einstance-count\x95\x02\x0cfirst-vertex\x95\x02\x0efi\
rst-instance\x95\x02\x01\0\x04\0$[method]gpu-render-pass-encoder.draw\x01\xe3\x04\
\x01k\xb1\x02\x01@\x06\x04self\xd0\x04\x0bindex-count\x94\x02\x0einstance-count\x95\
\x02\x0bfirst-index\x95\x02\x0bbase-vertex\xe4\x04\x0efirst-instance\x95\x02\x01\
\0\x04\0,[method]gpu-render-pass-encoder.draw-indexed\x01\xe5\x04\x01@\x03\x04se\
lf\xd0\x04\x0findirect-buffer\xea\x01\x0findirect-offset\xe3\x01\x01\0\x04\0-[me\
thod]gpu-render-pass-encoder.draw-indirect\x01\xe6\x04\x04\05[method]gpu-render-\
pass-encoder.draw-indexed-indirect\x01\xe6\x04\x01@\x01\x04self\xd7\x04\0s\x04\0\
\x1f[method]gpu-render-bundle.label\x01\xe7\x04\x01@\x02\x04self\xd7\x04\x05labe\
ls\x01\0\x04\0#[method]gpu-render-bundle.set-label\x01\xe8\x04\x01h\xb3\x01\x01k\
\xb2\x01\x01i\xb0\x01\x01@\x02\x04self\xe9\x04\x0adescriptor\xea\x04\0\xeb\x04\x04\
\0([method]gpu-render-bundle-encoder.finish\x01\xec\x04\x01@\x01\x04self\xe9\x04\
\0s\x04\0'[method]gpu-render-bundle-encoder.label\x01\xed\x04\x01@\x02\x04self\xe9\
\x04\x05labels\x01\0\x04\0+[method]gpu-render-bundle-encoder.set-label\x01\xee\x04\
\x01@\x02\x04self\xe9\x04\x0bgroup-labels\x01\0\x04\02[method]gpu-render-bundle-\
encoder.push-debug-group\x01\xef\x04\x01@\x01\x04self\xe9\x04\x01\0\x04\01[metho\
d]gpu-render-bundle-encoder.pop-debug-group\x01\xf0\x04\x01@\x02\x04self\xe9\x04\
\x0cmarker-labels\x01\0\x04\05[method]gpu-render-bundle-encoder.insert-debug-mar\
ker\x01\xf1\x04\x01@\x06\x04self\xe9\x04\x05index\xf9\x01\x0abind-group\xcb\x04\x14\
dynamic-offsets-data\xcd\x04\x1adynamic-offsets-data-start\xe7\x01\x1bdynamic-of\
fsets-data-length\x95\x02\0\xce\x04\x04\00[method]gpu-render-bundle-encoder.set-\
bind-group\x01\xf2\x04\x01@\x02\x04self\xe9\x04\x08pipeline\xa7\x04\x01\0\x04\0.\
[method]gpu-render-bundle-encoder.set-pipeline\x01\xf3\x04\x01@\x05\x04self\xe9\x04\
\x06buffer\xea\x01\x0cindex-format\x99\x01\x06offset\xe7\x01\x04size\xe7\x01\x01\
\0\x04\02[method]gpu-render-bundle-encoder.set-index-buffer\x01\xf4\x04\x01@\x05\
\x04self\xe9\x04\x04slot\xf9\x01\x06buffer\xe1\x04\x06offset\xe7\x01\x04size\xe7\
\x01\x01\0\x04\03[method]gpu-render-bundle-encoder.set-vertex-buffer\x01\xf5\x04\
\x01@\x05\x04self\xe9\x04\x0cvertex-count\x94\x02\x0einstance-count\x95\x02\x0cf\
irst-vertex\x95\x02\x0efirst-instance\x95\x02\x01\0\x04\0&[method]gpu-render-bun\
dle-encoder.draw\x01\xf6\x04\x01@\x06\x04self\xe9\x04\x0bindex-count\x94\x02\x0e\
instance-count\x95\x02\x0bfirst-index\x95\x02\x0bbase-vertex\xe4\x04\x0efirst-in\
stance\x95\x02\x01\0\x04\0.[method]gpu-render-bundle-encoder.draw-indexed\x01\xf7\
\x04\x01@\x03\x04self\xe9\x04\x0findirect-buffer\xea\x01\x0findirect-offset\xe3\x01\
\x01\0\x04\0/[method]gpu-render-bundle-encoder.draw-indirect\x01\xf8\x04\x04\07[\
method]gpu-render-bundle-encoder.draw-indexed-indirect\x01\xf8\x04\x01h\xbd\x01\x01\
p\xab\x04\x01@\x02\x04self\xf9\x04\x0fcommand-buffers\xfa\x04\x01\0\x04\0\x18[me\
thod]gpu-queue.submit\x01\xfb\x04\x01@\x01\x04self\xf9\x04\x01\0\x04\0([method]g\
pu-queue.on-submitted-work-done\x01\xfc\x04\x01j\0\x01\x84\x03\x01@\x06\x04self\xf9\
\x04\x06buffer\xea\x01\x0dbuffer-offset\xe3\x01\x04data\xe7\x03\x0bdata-offset\xe7\
\x01\x04size\xe7\x01\0\xfd\x04\x04\0([method]gpu-queue.write-buffer-with-copy\x01\
\xfe\x04\x01@\x05\x04self\xf9\x04\x0bdestination\xcc\x02\x04data\xe7\x03\x0bdata\
-layout\xa0\x02\x04size\xce\x02\x01\0\x04\0)[method]gpu-queue.write-texture-with\
-copy\x01\xff\x04\x01@\x01\x04self\xf9\x04\0s\x04\0\x17[method]gpu-queue.label\x01\
\x80\x05\x01@\x02\x04self\xf9\x04\x05labels\x01\0\x04\0\x1b[method]gpu-queue.set\
-label\x01\x81\x05\x01@\x01\x04self\xa3\x02\x01\0\x04\0\x1d[method]gpu-query-set\
.destroy\x01\x82\x05\x01@\x01\x04self\xa3\x02\0\xc0\x01\x04\0\x1a[method]gpu-que\
ry-set.type\x01\x83\x05\x01@\x01\x04self\xa3\x02\0\xb7\x02\x04\0\x1b[method]gpu-\
query-set.count\x01\x84\x05\x01@\x01\x04self\xa3\x02\0s\x04\0\x1b[method]gpu-que\
ry-set.label\x01\x85\x05\x01@\x02\x04self\xa3\x02\x05labels\x01\0\x04\0\x1f[meth\
od]gpu-query-set.set-label\x01\x86\x05\x01h\xc1\x01\x01@\x02\x04self\x87\x05\x0d\
configuration\xdb\x02\x01\0\x04\0$[method]gpu-canvas-context.configure\x01\x88\x05\
\x01@\x01\x04self\x87\x05\x01\0\x04\0&[method]gpu-canvas-context.unconfigure\x01\
\x89\x05\x01k\xde\x02\x01@\x01\x04self\x87\x05\0\x8a\x05\x04\0,[method]gpu-canva\
s-context.get-configuration\x01\x8b\x05\x01@\x01\x04self\x87\x05\0\xb8\x03\x04\0\
.[method]gpu-canvas-context.get-current-texture\x01\x8c\x05\x01h\xcb\x01\x01@\x01\
\x04self\x8d\x05\0\xca\x01\x04\0#[method]gpu-device-lost-info.reason\x01\x8e\x05\
\x01@\x01\x04self\x8d\x05\0s\x04\0$[method]gpu-device-lost-info.message\x01\x8f\x05\
\x01h\xcc\x01\x01@\x01\x04self\x90\x05\0s\x04\0\x19[method]gpu-error.message\x01\
\x91\x05\x01@\x01\x04self\x90\x05\0\xe0\x02\x04\0\x16[method]gpu-error.kind\x01\x92\
\x05\x01h\xcf\x01\x01@\x01\x04self\x93\x05\0\xda\x03\x04\0([method]gpu-uncapture\
d-error-event.error\x01\x94\x05\x01i\x0a\x01@\0\0\x95\x05\x04\0\x07get-gpu\x01\x96\
\x05\x03\0\x18wasi:webgpu/webgpu@0.0.1\x05\x05\x02\x03\0\x02\x0agpu-device\x02\x03\
\0\x02\x12gpu-canvas-context\x02\x03\0\x02\x13gpu-render-pipeline\x02\x03\0\x02\x15\
gpu-bind-group-layout\x01B\x1f\x02\x03\x02\x01\x06\x04\0\x0agpu-device\x03\0\0\x02\
\x03\x02\x01\x07\x04\0\x12gpu-canvas-context\x03\0\x02\x02\x03\x02\x01\x08\x04\0\
\x13gpu-render-pipeline\x03\0\x04\x02\x03\x02\x01\x09\x04\0\x15gpu-bind-group-la\
yout\x03\0\x06\x01r\x02\x05widthy\x06heighty\x04\0\x0aframe-size\x03\0\x08\x04\0\
\x0erender-context\x03\x01\x01h\x0a\x01@\x01\x04self\x0b\0\x09\x04\0\x1b[method]\
render-context.size\x01\x0c\x01@\x01\x04self\x0b\0v\x04\0#[method]render-context\
.scale-factor\x01\x0d\x01@\x02\x04self\x0b\x04size\x09\x01\0\x04\0'[method]rende\
r-context.request-set-size\x01\x0e\x01i\x01\x01@\x01\x04self\x0b\0\x0f\x04\0![me\
thod]render-context.get-device\x01\x10\x01i\x03\x01@\x01\x04self\x0b\0\x11\x04\0\
![method]render-context.get-canvas\x01\x12\x01i\x05\x01@\x01\x04self\x0b\0\x13\x04\
\0#[method]render-context.get-pipeline\x01\x14\x01i\x07\x01@\x01\x04self\x0b\0\x15\
\x04\0)[method]render-context.get-uniform-layout\x01\x16\x04\0)[method]render-co\
ntext.get-texture-layout\x01\x16\x03\0\x1clocal:webgpu-runtime/surface\x05\x0a\x01\
B\x0c\x01n\x02\x04left\x05right\x04\0\x10modifier-pressed\x03\0\0\x01r\x04\x04ct\
rl\x01\x05shift\x01\x03alt\x01\x09super-key\x01\x04\0\x10modifier-options\x03\0\x02\
\x01r\x02\x01xv\x01yv\x04\0\x08location\x03\0\x04\x01m\x05\x04left\x05right\x06m\
iddle\x04back\x07forward\x04\0\x0cmouse-button\x03\0\x06\x01q\x04\x09modifiers\x01\
\x03\0\x07pointer\x01\x05\0\x0amouse-down\x01\x07\0\x08mouse-up\x01\x07\0\x04\0\x05\
event\x03\0\x08\x01q\x02\x05event\x01\x09\0\x0bopen-window\x01s\0\x04\0\x0eunhan\
dle-event\x03\0\x0a\x03\0\x1elocal:immediate-renderer/types\x05\x0b\x02\x03\0\x03\
\x0erender-context\x02\x03\0\x04\x05event\x02\x03\0\x04\x0eunhandle-event\x01B\x16\
\x02\x03\x02\x01\x0c\x04\0\x0erender-context\x03\0\0\x02\x03\x02\x01\x0d\x04\0\x05\
event\x03\0\x02\x02\x03\x02\x01\x0e\x04\0\x0eunhandle-event\x03\0\x04\x04\0\x0ad\
ispatcher\x03\x01\x01h\x06\x01@\x02\x04self\x07\x05event\x03\x01\0\x04\0\x1d[met\
hod]dispatcher.push-event\x01\x08\x01p\x03\x01@\x02\x04self\x07\x05event\x09\x01\
\0\x04\0![method]dispatcher.push-event-all\x01\x0a\x01p\x05\x01@\x01\x04self\x07\
\0\x0b\x04\0\x1b[method]dispatcher.dispatch\x01\x0c\x01i\x01\x01i\x06\x01@\x01\x07\
context\x0d\0\x0e\x04\0\x14create-main-renderer\x01\x0f\x04\0\x18create-triangle\
-renderer\x01\x0f\x04\0\x17create-counter-renderer\x01\x0f\x04\0\x1flocal:immedi\
ate-renderer/render\x05\x0f\x04\01local:immediate-renderer/immediate-renderer-wo\
rld\x04\0\x0b\x1e\x01\0\x18immediate-renderer-world\x03\0\0\0G\x09producers\x01\x0c\
processed-by\x02\x0dwit-component\x070.244.0\x10wit-bindgen-rust\x060.52.0";

                                                                  #[inline(never)]
                                                                  #[doc(hidden)]
                                                                  pub fn __link_custom_section_describing_imports() {
                                                                    wit_bindgen::rt::maybe_link_cabi_realloc();
                                                                  }
                                                                  
